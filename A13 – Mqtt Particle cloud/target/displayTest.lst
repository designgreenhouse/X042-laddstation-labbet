
/Users/heikki/Documents/Arduino/displayTest/target/displayTest.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .module_info  00000018  080a0000  080a0000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00002438  080a0018  080a0018  00010018  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .backup       00000004  40024000  080a2450  00014000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .data         00000478  20000300  080a2454  00020300  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .bss          000005bc  20000778  20000778  00030778  2**2
                  ALLOC
  5 .module_info_suffix 00000028  080a28cc  080a28cc  000228cc  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .module_info_crc 00000004  080a28f4  080a28f4  000228f4  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .debug_info   000a1d32  00000000  00000000  000228f8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0000f0b4  00000000  00000000  000c462a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    00014b69  00000000  00000000  000d36de  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 00002078  00000000  00000000  000e8247  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000033c8  00000000  00000000  000ea2bf  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  00024cbd  00000000  00000000  000ed687  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0002248f  00000000  00000000  00112344  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    00098250  00000000  00000000  001347d3  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  0000ba74  00000000  00000000  001cca24  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080a0018 <user_part_module>:
 80a0018:	50 1c 0a 08                                         P...

080a001c <module_user_pre_init>:
/**
 * Initializes this user module. Returns the start of the heap.
 */
void* module_user_pre_init() {

    if ( (&link_global_data_start!=&link_global_data_initial_values) && (link_global_data_size != 0))
 80a001c:	4809      	ldr	r0, [pc, #36]	; (80a0044 <module_user_pre_init+0x28>)
 80a001e:	490a      	ldr	r1, [pc, #40]	; (80a0048 <module_user_pre_init+0x2c>)
extern constructor_ptr_t link_constructors_end;

/**
 * Initializes this user module. Returns the start of the heap.
 */
void* module_user_pre_init() {
 80a0020:	b508      	push	{r3, lr}

    if ( (&link_global_data_start!=&link_global_data_initial_values) && (link_global_data_size != 0))
 80a0022:	4288      	cmp	r0, r1
 80a0024:	d005      	beq.n	80a0032 <module_user_pre_init+0x16>
 80a0026:	4a09      	ldr	r2, [pc, #36]	; (80a004c <module_user_pre_init+0x30>)
 80a0028:	4282      	cmp	r2, r0
 80a002a:	d002      	beq.n	80a0032 <module_user_pre_init+0x16>
    {
        memcpy(&link_global_data_start, &link_global_data_initial_values, link_global_data_size);
 80a002c:	1a12      	subs	r2, r2, r0
 80a002e:	f001 fdcb 	bl	80a1bc8 <memcpy>
    }

    memset(&link_bss_location, 0, link_bss_size );
 80a0032:	4807      	ldr	r0, [pc, #28]	; (80a0050 <module_user_pre_init+0x34>)
 80a0034:	4a07      	ldr	r2, [pc, #28]	; (80a0054 <module_user_pre_init+0x38>)
 80a0036:	2100      	movs	r1, #0
 80a0038:	1a12      	subs	r2, r2, r0
 80a003a:	f001 fdd0 	bl	80a1bde <memset>
    return &link_heap_start;
}
 80a003e:	4806      	ldr	r0, [pc, #24]	; (80a0058 <module_user_pre_init+0x3c>)
 80a0040:	bd08      	pop	{r3, pc}
 80a0042:	bf00      	nop
 80a0044:	20000300 	.word	0x20000300
 80a0048:	080a2454 	.word	0x080a2454
 80a004c:	20000778 	.word	0x20000778
 80a0050:	20000778 	.word	0x20000778
 80a0054:	20000d34 	.word	0x20000d34
 80a0058:	20000d34 	.word	0x20000d34

080a005c <module_user_init>:
extern constructor_ptr_t link_constructors_location[];
extern constructor_ptr_t link_constructors_end;
#define link_constructors_size   ((unsigned long)&link_constructors_end  -  (unsigned long)&link_constructors_location )

void module_user_init()
{
 80a005c:	b570      	push	{r4, r5, r6, lr}
    module_user_init_hook();
 80a005e:	f001 fb5f 	bl	80a1720 <module_user_init_hook>
 80a0062:	4b07      	ldr	r3, [pc, #28]	; (80a0080 <module_user_init+0x24>)
 80a0064:	4c07      	ldr	r4, [pc, #28]	; (80a0084 <module_user_init+0x28>)
 80a0066:	461e      	mov	r6, r3
 80a0068:	1ae4      	subs	r4, r4, r3
 80a006a:	08a4      	lsrs	r4, r4, #2

    // invoke constructors
    int ctor_num;
    for (ctor_num=0; ctor_num < link_constructors_size/sizeof(constructor_ptr_t); ctor_num++ )
 80a006c:	2500      	movs	r5, #0
 80a006e:	42a5      	cmp	r5, r4
 80a0070:	d004      	beq.n	80a007c <module_user_init+0x20>
    {
        link_constructors_location[ctor_num]();
 80a0072:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 80a0076:	4798      	blx	r3
{
    module_user_init_hook();

    // invoke constructors
    int ctor_num;
    for (ctor_num=0; ctor_num < link_constructors_size/sizeof(constructor_ptr_t); ctor_num++ )
 80a0078:	3501      	adds	r5, #1
 80a007a:	e7f8      	b.n	80a006e <module_user_init+0x12>
    {
        link_constructors_location[ctor_num]();
    }
}
 80a007c:	bd70      	pop	{r4, r5, r6, pc}
 80a007e:	bf00      	nop
 80a0080:	080a2414 	.word	0x080a2414
 80a0084:	080a244c 	.word	0x080a244c

080a0088 <module_user_setup>:

/**
 * Export these functions with a fuller name so they don't clash with the setup/loop wrappers in the system module.
 */
void module_user_setup() {
    setup();
 80a0088:	f000 b81e 	b.w	80a00c8 <setup>

080a008c <module_user_loop>:
}

void module_user_loop() {
 80a008c:	b508      	push	{r3, lr}
    loop();
 80a008e:	f000 f83f 	bl	80a0110 <loop>
    _post_loop();
}
 80a0092:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    setup();
}

void module_user_loop() {
    loop();
    _post_loop();
 80a0096:	f001 bb05 	b.w	80a16a4 <_post_loop>

080a009a <_ZdlPv>:
 80a009a:	f000 bf69 	b.w	80a0f70 <free>
	...

080a00a0 <__cxa_pure_virtual>:
        ;
    }
}

/* Default implementation for call made to pure virtual function. */
void __cxa_pure_virtual() {
 80a00a0:	b508      	push	{r3, lr}
  PANIC(PureVirtualCall,"Call on pure virtual");
 80a00a2:	4a03      	ldr	r2, [pc, #12]	; (80a00b0 <__cxa_pure_virtual+0x10>)
 80a00a4:	2100      	movs	r1, #0
 80a00a6:	200c      	movs	r0, #12
 80a00a8:	f000 ff1e 	bl	80a0ee8 <panic_>
 80a00ac:	e7fe      	b.n	80a00ac <__cxa_pure_virtual+0xc>
 80a00ae:	bf00      	nop
 80a00b0:	080a0c85 	.word	0x080a0c85

080a00b4 <__cxa_guard_acquire>:

/* Provide default implemenation for __cxa_guard_acquire() and
 * __cxa_guard_release(). Note: these must be revisited if a multitasking
 * OS is ported to this platform. */
__extension__ typedef int __guard __attribute__((mode (__DI__)));
int __cxa_guard_acquire(__guard *g) {return !*(char *)(g);};
 80a00b4:	7800      	ldrb	r0, [r0, #0]
 80a00b6:	fab0 f080 	clz	r0, r0
 80a00ba:	0940      	lsrs	r0, r0, #5
 80a00bc:	4770      	bx	lr

080a00be <__cxa_guard_release>:
void __cxa_guard_release (__guard *g) {*(char *)g = 1;};
 80a00be:	2301      	movs	r3, #1
 80a00c0:	7003      	strb	r3, [r0, #0]
 80a00c2:	4770      	bx	lr

080a00c4 <_ZN16Adafruit_SSD1306D1Ev>:
#define SSD1306_RIGHT_HORIZONTAL_SCROLL 0x26
#define SSD1306_LEFT_HORIZONTAL_SCROLL 0x27
#define SSD1306_VERTICAL_AND_RIGHT_HORIZONTAL_SCROLL 0x29
#define SSD1306_VERTICAL_AND_LEFT_HORIZONTAL_SCROLL 0x2A

class Adafruit_SSD1306 : public Adafruit_GFX {
 80a00c4:	4770      	bx	lr
	...

080a00c8 <setup>:

// create a software timer to get new prediction times every minute
Timer timer(60000, getBusTimes);
#endif 

void setup()   {
 80a00c8:	b510      	push	{r4, lr}

  //Particle.publish("get_nextbus"); // publish the event to trigger the data
  //delay(2000); // wait for data to arrive

  // by default, we'll generate the high voltage from the 3.3v line internally! (neat!)
  display.begin(SSD1306_SWITCHCAPVCC);
 80a00ca:	4c0d      	ldr	r4, [pc, #52]	; (80a0100 <setup+0x38>)
 80a00cc:	223c      	movs	r2, #60	; 0x3c
 80a00ce:	2102      	movs	r1, #2
 80a00d0:	4620      	mov	r0, r4
 80a00d2:	f000 fc6f 	bl	80a09b4 <_ZN16Adafruit_SSD13065beginEhh>

  display.setTextSize(7);       // text size
 80a00d6:	2107      	movs	r1, #7
 80a00d8:	4620      	mov	r0, r4
 80a00da:	f000 fa2d 	bl	80a0538 <_ZN12Adafruit_GFX11setTextSizeEh>
  display.setTextColor(WHITE); // text color
 80a00de:	2101      	movs	r1, #1
 80a00e0:	4620      	mov	r0, r4
 80a00e2:	f000 fa2e 	bl	80a0542 <_ZN12Adafruit_GFX12setTextColorEt>
  display.setTextWrap(false); // turn off text wrapping so we can do scrolling
 80a00e6:	2100      	movs	r1, #0
 80a00e8:	4620      	mov	r0, r4
 80a00ea:	f000 fa2d 	bl	80a0548 <_ZN12Adafruit_GFX11setTextWrapEb>
  x    = display.width(); // set scrolling frame to display width
 80a00ee:	4620      	mov	r0, r4
 80a00f0:	f000 fa2e 	bl	80a0550 <_ZN12Adafruit_GFX5widthEv>
 80a00f4:	4b03      	ldr	r3, [pc, #12]	; (80a0104 <setup+0x3c>)
  minX = -1500; // 630 = 6 pixels/character * text size 7 * 15 characters * 2x slower
 80a00f6:	4a04      	ldr	r2, [pc, #16]	; (80a0108 <setup+0x40>)
  display.begin(SSD1306_SWITCHCAPVCC);

  display.setTextSize(7);       // text size
  display.setTextColor(WHITE); // text color
  display.setTextWrap(false); // turn off text wrapping so we can do scrolling
  x    = display.width(); // set scrolling frame to display width
 80a00f8:	6018      	str	r0, [r3, #0]
  minX = -1500; // 630 = 6 pixels/character * text size 7 * 15 characters * 2x slower
 80a00fa:	4b04      	ldr	r3, [pc, #16]	; (80a010c <setup+0x44>)
 80a00fc:	601a      	str	r2, [r3, #0]
 80a00fe:	bd10      	pop	{r4, pc}
 80a0100:	20000794 	.word	0x20000794
 80a0104:	20000790 	.word	0x20000790
 80a0108:	fffffa24 	.word	0xfffffa24
 80a010c:	2000077c 	.word	0x2000077c

080a0110 <loop>:
}

void loop() {
 80a0110:	b510      	push	{r4, lr}

  // this code displays the next bus times on the OLED screen with fancy scrolling
  display.clearDisplay();
  display.setCursor(x/2, 7);
 80a0112:	4c11      	ldr	r4, [pc, #68]	; (80a0158 <loop+0x48>)
}

void loop() {

  // this code displays the next bus times on the OLED screen with fancy scrolling
  display.clearDisplay();
 80a0114:	4811      	ldr	r0, [pc, #68]	; (80a015c <loop+0x4c>)
 80a0116:	f000 fd93 	bl	80a0c40 <_ZN16Adafruit_SSD130612clearDisplayEv>
  display.setCursor(x/2, 7);
 80a011a:	6823      	ldr	r3, [r4, #0]
 80a011c:	2102      	movs	r1, #2
 80a011e:	fb93 f1f1 	sdiv	r1, r3, r1
 80a0122:	2207      	movs	r2, #7
 80a0124:	b209      	sxth	r1, r1
 80a0126:	480d      	ldr	r0, [pc, #52]	; (80a015c <loop+0x4c>)
 80a0128:	f000 fa03 	bl	80a0532 <_ZN12Adafruit_GFX9setCursorEss>
 80a012c:	4b0c      	ldr	r3, [pc, #48]	; (80a0160 <loop+0x50>)
  display.print(busName);
 80a012e:	480b      	ldr	r0, [pc, #44]	; (80a015c <loop+0x4c>)
 80a0130:	6819      	ldr	r1, [r3, #0]
 80a0132:	f000 fff7 	bl	80a1124 <_ZN5Print5printEPKc>
  display.print(", ");
  display.print(nextSoonestBusTime);
  display.print(" min   ");
  #endif 
  
  display.display();
 80a0136:	4809      	ldr	r0, [pc, #36]	; (80a015c <loop+0x4c>)
 80a0138:	f000 fd0c 	bl	80a0b54 <_ZN16Adafruit_SSD13067displayEv>
  if(--x < minX) x = display.width()*2;
 80a013c:	4a09      	ldr	r2, [pc, #36]	; (80a0164 <loop+0x54>)
 80a013e:	6823      	ldr	r3, [r4, #0]
 80a0140:	6812      	ldr	r2, [r2, #0]
 80a0142:	3b01      	subs	r3, #1
 80a0144:	4293      	cmp	r3, r2
 80a0146:	6023      	str	r3, [r4, #0]
 80a0148:	da04      	bge.n	80a0154 <loop+0x44>
 80a014a:	4804      	ldr	r0, [pc, #16]	; (80a015c <loop+0x4c>)
 80a014c:	f000 fa00 	bl	80a0550 <_ZN12Adafruit_GFX5widthEv>
 80a0150:	0040      	lsls	r0, r0, #1
 80a0152:	6020      	str	r0, [r4, #0]
 80a0154:	bd10      	pop	{r4, pc}
 80a0156:	bf00      	nop
 80a0158:	20000790 	.word	0x20000790
 80a015c:	20000794 	.word	0x20000794
 80a0160:	20000780 	.word	0x20000780
 80a0164:	2000077c 	.word	0x2000077c

080a0168 <_ZN16Adafruit_SSD1306D0Ev>:
 80a0168:	b510      	push	{r4, lr}
 80a016a:	4604      	mov	r4, r0
 80a016c:	f7ff ff95 	bl	80a009a <_ZdlPv>
 80a0170:	4620      	mov	r0, r4
 80a0172:	bd10      	pop	{r4, pc}

080a0174 <_GLOBAL__sub_I_display>:
  else if(soonestBusTime > leadTime && gaveWarning == true)
  {
      gaveWarning = false;
  }
  #endif 
}
 80a0174:	b538      	push	{r3, r4, r5, lr}

// use hardware SPI
#define OLED_DC     D3
#define OLED_CS     D4
#define OLED_RESET  D5
Adafruit_SSD1306 display(OLED_DC, OLED_RESET, OLED_CS);
 80a0176:	4c0d      	ldr	r4, [pc, #52]	; (80a01ac <_GLOBAL__sub_I_display+0x38>)
inline int32_t pinReadFast(pin_t _pin)
{
	return ((PIN_MAP[_pin].gpio_peripheral->IDR & PIN_MAP[_pin].gpio_pin) == 0 ? LOW : HIGH);
}
#elif defined(STM32F2XX)
static STM32_Pin_Info* PIN_MAP = HAL_Pin_Map();
 80a0178:	f000 fd94 	bl	80a0ca4 <HAL_Pin_Map>
 80a017c:	4d0c      	ldr	r5, [pc, #48]	; (80a01b0 <_GLOBAL__sub_I_display+0x3c>)
 80a017e:	2304      	movs	r3, #4
 80a0180:	2205      	movs	r2, #5
 80a0182:	2103      	movs	r1, #3
 80a0184:	4620      	mov	r0, r4
 80a0186:	f000 fbbb 	bl	80a0900 <_ZN16Adafruit_SSD1306C1Eaaa>
 80a018a:	4620      	mov	r0, r4

String busName = "Hello2 again"; 
 80a018c:	4c09      	ldr	r4, [pc, #36]	; (80a01b4 <_GLOBAL__sub_I_display+0x40>)

// use hardware SPI
#define OLED_DC     D3
#define OLED_CS     D4
#define OLED_RESET  D5
Adafruit_SSD1306 display(OLED_DC, OLED_RESET, OLED_CS);
 80a018e:	462a      	mov	r2, r5
 80a0190:	4909      	ldr	r1, [pc, #36]	; (80a01b8 <_GLOBAL__sub_I_display+0x44>)
 80a0192:	f001 fbbd 	bl	80a1910 <__aeabi_atexit>

String busName = "Hello2 again"; 
 80a0196:	4909      	ldr	r1, [pc, #36]	; (80a01bc <_GLOBAL__sub_I_display+0x48>)
 80a0198:	4620      	mov	r0, r4
 80a019a:	f001 f8dd 	bl	80a1358 <_ZN6StringC1EPK19__FlashStringHelper>
 80a019e:	462a      	mov	r2, r5
 80a01a0:	4620      	mov	r0, r4
  else if(soonestBusTime > leadTime && gaveWarning == true)
  {
      gaveWarning = false;
  }
  #endif 
}
 80a01a2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
#define OLED_DC     D3
#define OLED_CS     D4
#define OLED_RESET  D5
Adafruit_SSD1306 display(OLED_DC, OLED_RESET, OLED_CS);

String busName = "Hello2 again"; 
 80a01a6:	4906      	ldr	r1, [pc, #24]	; (80a01c0 <_GLOBAL__sub_I_display+0x4c>)
 80a01a8:	f001 bbb2 	b.w	80a1910 <__aeabi_atexit>
 80a01ac:	20000794 	.word	0x20000794
 80a01b0:	20000778 	.word	0x20000778
 80a01b4:	20000780 	.word	0x20000780
 80a01b8:	080a00c5 	.word	0x080a00c5
 80a01bc:	080a1c64 	.word	0x080a1c64
 80a01c0:	080a12cb 	.word	0x080a12cb

080a01c4 <_ZN12Adafruit_GFX8drawLineEsssst>:
}

// Bresenham's algorithm - thx wikpedia
void Adafruit_GFX::drawLine(int16_t x0, int16_t y0,
			    int16_t x1, int16_t y1,
			    uint16_t color) {
 80a01c4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a01c8:	461e      	mov	r6, r3
 80a01ca:	b085      	sub	sp, #20
 80a01cc:	f9bd 3038 	ldrsh.w	r3, [sp, #56]	; 0x38
 80a01d0:	4615      	mov	r5, r2
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
 80a01d2:	1a9a      	subs	r2, r3, r2
 80a01d4:	2a00      	cmp	r2, #0
 80a01d6:	bfb8      	it	lt
 80a01d8:	4252      	neglt	r2, r2
 80a01da:	9200      	str	r2, [sp, #0]
 80a01dc:	1a72      	subs	r2, r6, r1
 80a01de:	2a00      	cmp	r2, #0
 80a01e0:	bfb8      	it	lt
 80a01e2:	4252      	neglt	r2, r2
 80a01e4:	9201      	str	r2, [sp, #4]
}

// Bresenham's algorithm - thx wikpedia
void Adafruit_GFX::drawLine(int16_t x0, int16_t y0,
			    int16_t x1, int16_t y1,
			    uint16_t color) {
 80a01e6:	460c      	mov	r4, r1
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
  if (steep) {
 80a01e8:	9a00      	ldr	r2, [sp, #0]
 80a01ea:	9901      	ldr	r1, [sp, #4]
}

// Bresenham's algorithm - thx wikpedia
void Adafruit_GFX::drawLine(int16_t x0, int16_t y0,
			    int16_t x1, int16_t y1,
			    uint16_t color) {
 80a01ec:	4681      	mov	r9, r0
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
  if (steep) {
 80a01ee:	428a      	cmp	r2, r1
}

// Bresenham's algorithm - thx wikpedia
void Adafruit_GFX::drawLine(int16_t x0, int16_t y0,
			    int16_t x1, int16_t y1,
			    uint16_t color) {
 80a01f0:	f8bd a03c 	ldrh.w	sl, [sp, #60]	; 0x3c
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
  if (steep) {
 80a01f4:	dd05      	ble.n	80a0202 <_ZN12Adafruit_GFX8drawLineEsssst+0x3e>
 80a01f6:	4632      	mov	r2, r6
    swap(x0, y0);
    swap(x1, y1);
 80a01f8:	461e      	mov	r6, r3
 80a01fa:	4613      	mov	r3, r2
// Bresenham's algorithm - thx wikpedia
void Adafruit_GFX::drawLine(int16_t x0, int16_t y0,
			    int16_t x1, int16_t y1,
			    uint16_t color) {
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
  if (steep) {
 80a01fc:	4622      	mov	r2, r4
    swap(x0, y0);
 80a01fe:	462c      	mov	r4, r5
 80a0200:	4615      	mov	r5, r2
    swap(x1, y1);
  }

  if (x0 > x1) {
 80a0202:	42b4      	cmp	r4, r6
 80a0204:	dd05      	ble.n	80a0212 <_ZN12Adafruit_GFX8drawLineEsssst+0x4e>
 80a0206:	462a      	mov	r2, r5
    swap(x0, x1);
    swap(y0, y1);
 80a0208:	461d      	mov	r5, r3
 80a020a:	4613      	mov	r3, r2
  if (steep) {
    swap(x0, y0);
    swap(x1, y1);
  }

  if (x0 > x1) {
 80a020c:	4622      	mov	r2, r4
 80a020e:	4634      	mov	r4, r6
 80a0210:	4616      	mov	r6, r2
    swap(y0, y1);
  }

  int16_t dx, dy;
  dx = x1 - x0;
  dy = abs(y1 - y0);
 80a0212:	1b5a      	subs	r2, r3, r5
 80a0214:	2a00      	cmp	r2, #0
    swap(x0, x1);
    swap(y0, y1);
  }

  int16_t dx, dy;
  dx = x1 - x0;
 80a0216:	ebc4 0806 	rsb	r8, r4, r6
  dy = abs(y1 - y0);
 80a021a:	bfb8      	it	lt
 80a021c:	4252      	neglt	r2, r2
    swap(x0, x1);
    swap(y0, y1);
  }

  int16_t dx, dy;
  dx = x1 - x0;
 80a021e:	fa1f f888 	uxth.w	r8, r8
  dy = abs(y1 - y0);
 80a0222:	9203      	str	r2, [sp, #12]

  int16_t err = dx / 2;
 80a0224:	fa0f f788 	sxth.w	r7, r8
 80a0228:	2202      	movs	r2, #2
  int16_t ystep;

  if (y0 < y1) {
    ystep = 1;
  } else {
    ystep = -1;
 80a022a:	429d      	cmp	r5, r3
 80a022c:	bfb4      	ite	lt
 80a022e:	2301      	movlt	r3, #1
 80a0230:	f04f 33ff 	movge.w	r3, #4294967295	; 0xffffffff

  int16_t dx, dy;
  dx = x1 - x0;
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
 80a0234:	fb97 f7f2 	sdiv	r7, r7, r2
  int16_t ystep;

  if (y0 < y1) {
    ystep = 1;
  } else {
    ystep = -1;
 80a0238:	9302      	str	r3, [sp, #8]
  }

  for (; x0<=x1; x0++) {
 80a023a:	42b4      	cmp	r4, r6
 80a023c:	dc1f      	bgt.n	80a027e <_ZN12Adafruit_GFX8drawLineEsssst+0xba>
    if (steep) {
 80a023e:	9a01      	ldr	r2, [sp, #4]
 80a0240:	9b00      	ldr	r3, [sp, #0]
      drawPixel(y0, x0, color);
    } else {
      drawPixel(x0, y0, color);
 80a0242:	4648      	mov	r0, r9
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    if (steep) {
 80a0244:	4293      	cmp	r3, r2
 80a0246:	f8d9 3000 	ldr.w	r3, [r9]
      drawPixel(y0, x0, color);
 80a024a:	bfc8      	it	gt
 80a024c:	4622      	movgt	r2, r4
 80a024e:	f8d3 b010 	ldr.w	fp, [r3, #16]
 80a0252:	bfc8      	it	gt
 80a0254:	4629      	movgt	r1, r5
 80a0256:	4653      	mov	r3, sl
    } else {
      drawPixel(x0, y0, color);
 80a0258:	bfdc      	itt	le
 80a025a:	462a      	movle	r2, r5
 80a025c:	4621      	movle	r1, r4
 80a025e:	47d8      	blx	fp
    }
    err -= dy;
 80a0260:	9b03      	ldr	r3, [sp, #12]
 80a0262:	1aff      	subs	r7, r7, r3
 80a0264:	b2bb      	uxth	r3, r7
 80a0266:	b21f      	sxth	r7, r3
    if (err < 0) {
 80a0268:	2f00      	cmp	r7, #0
 80a026a:	da05      	bge.n	80a0278 <_ZN12Adafruit_GFX8drawLineEsssst+0xb4>
      y0 += ystep;
 80a026c:	9a02      	ldr	r2, [sp, #8]
      err += dx;
 80a026e:	eb08 0703 	add.w	r7, r8, r3
    } else {
      drawPixel(x0, y0, color);
    }
    err -= dy;
    if (err < 0) {
      y0 += ystep;
 80a0272:	4415      	add	r5, r2
 80a0274:	b22d      	sxth	r5, r5
      err += dx;
 80a0276:	b23f      	sxth	r7, r7
 80a0278:	3401      	adds	r4, #1
 80a027a:	b224      	sxth	r4, r4
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
 80a027c:	e7dd      	b.n	80a023a <_ZN12Adafruit_GFX8drawLineEsssst+0x76>
    if (err < 0) {
      y0 += ystep;
      err += dx;
    }
  }
}
 80a027e:	b005      	add	sp, #20
 80a0280:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080a0284 <_ZN12Adafruit_GFX8drawRectEsssst>:

// Draw a rectangle
void Adafruit_GFX::drawRect(int16_t x, int16_t y,
			    int16_t w, int16_t h,
			    uint16_t color) {
 80a0284:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 80a0288:	4604      	mov	r4, r0
 80a028a:	4691      	mov	r9, r2
 80a028c:	460d      	mov	r5, r1
 80a028e:	4698      	mov	r8, r3
 80a0290:	f8bd 602c 	ldrh.w	r6, [sp, #44]	; 0x2c
  drawFastHLine(x, y, w, color);
 80a0294:	6807      	ldr	r7, [r0, #0]
}

// Draw a rectangle
void Adafruit_GFX::drawRect(int16_t x, int16_t y,
			    int16_t w, int16_t h,
			    uint16_t color) {
 80a0296:	f9bd a028 	ldrsh.w	sl, [sp, #40]	; 0x28
  drawFastHLine(x, y, w, color);
 80a029a:	9600      	str	r6, [sp, #0]
 80a029c:	69ff      	ldr	r7, [r7, #28]
 80a029e:	47b8      	blx	r7
  drawFastHLine(x, y+h-1, w, color);
 80a02a0:	6823      	ldr	r3, [r4, #0]
 80a02a2:	f10a 32ff 	add.w	r2, sl, #4294967295	; 0xffffffff
 80a02a6:	9600      	str	r6, [sp, #0]
 80a02a8:	444a      	add	r2, r9
 80a02aa:	69df      	ldr	r7, [r3, #28]
 80a02ac:	4629      	mov	r1, r5
 80a02ae:	4643      	mov	r3, r8
 80a02b0:	4620      	mov	r0, r4
 80a02b2:	b212      	sxth	r2, r2
 80a02b4:	47b8      	blx	r7
  drawFastVLine(x, y, h, color);
 80a02b6:	6823      	ldr	r3, [r4, #0]
 80a02b8:	9600      	str	r6, [sp, #0]
 80a02ba:	699f      	ldr	r7, [r3, #24]
 80a02bc:	464a      	mov	r2, r9
 80a02be:	4653      	mov	r3, sl
 80a02c0:	4629      	mov	r1, r5
 80a02c2:	4620      	mov	r0, r4
 80a02c4:	47b8      	blx	r7
  drawFastVLine(x+w-1, y, h, color);
 80a02c6:	6823      	ldr	r3, [r4, #0]
 80a02c8:	f108 31ff 	add.w	r1, r8, #4294967295	; 0xffffffff
 80a02cc:	960a      	str	r6, [sp, #40]	; 0x28
 80a02ce:	4429      	add	r1, r5
 80a02d0:	699d      	ldr	r5, [r3, #24]
 80a02d2:	464a      	mov	r2, r9
 80a02d4:	4653      	mov	r3, sl
 80a02d6:	4620      	mov	r0, r4
 80a02d8:	46ac      	mov	ip, r5
 80a02da:	b209      	sxth	r1, r1
}
 80a02dc:	b002      	add	sp, #8
 80a02de:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
			    int16_t w, int16_t h,
			    uint16_t color) {
  drawFastHLine(x, y, w, color);
  drawFastHLine(x, y+h-1, w, color);
  drawFastVLine(x, y, h, color);
  drawFastVLine(x+w-1, y, h, color);
 80a02e2:	4760      	bx	ip

080a02e4 <_ZN12Adafruit_GFX13drawFastVLineEssst>:
}

void Adafruit_GFX::drawFastVLine(int16_t x, int16_t y,
				 int16_t h, uint16_t color) {
 80a02e4:	b537      	push	{r0, r1, r2, r4, r5, lr}
  // Update in subclasses if desired!
  drawLine(x, y, x, y+h-1, color);
 80a02e6:	3b01      	subs	r3, #1
 80a02e8:	f8bd 5018 	ldrh.w	r5, [sp, #24]
 80a02ec:	4413      	add	r3, r2
 80a02ee:	6804      	ldr	r4, [r0, #0]
 80a02f0:	b21b      	sxth	r3, r3
 80a02f2:	9300      	str	r3, [sp, #0]
 80a02f4:	9501      	str	r5, [sp, #4]
 80a02f6:	6964      	ldr	r4, [r4, #20]
 80a02f8:	460b      	mov	r3, r1
 80a02fa:	47a0      	blx	r4
}
 80a02fc:	b003      	add	sp, #12
 80a02fe:	bd30      	pop	{r4, r5, pc}

080a0300 <_ZN12Adafruit_GFX13drawFastHLineEssst>:

void Adafruit_GFX::drawFastHLine(int16_t x, int16_t y,
				 int16_t w, uint16_t color) {
 80a0300:	b537      	push	{r0, r1, r2, r4, r5, lr}
  // Update in subclasses if desired!
  drawLine(x, y, x+w-1, y, color);
 80a0302:	f8bd 5018 	ldrh.w	r5, [sp, #24]
 80a0306:	6804      	ldr	r4, [r0, #0]
 80a0308:	e88d 0024 	stmia.w	sp, {r2, r5}
 80a030c:	3b01      	subs	r3, #1
 80a030e:	440b      	add	r3, r1
 80a0310:	6964      	ldr	r4, [r4, #20]
 80a0312:	b21b      	sxth	r3, r3
 80a0314:	47a0      	blx	r4
}
 80a0316:	b003      	add	sp, #12
 80a0318:	bd30      	pop	{r4, r5, pc}

080a031a <_ZN12Adafruit_GFX8fillRectEsssst>:

void Adafruit_GFX::fillRect(int16_t x, int16_t y, int16_t w, int16_t h,
			    uint16_t color) {
 80a031a:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 80a031e:	4605      	mov	r5, r0
 80a0320:	4617      	mov	r7, r2
  // Update in subclasses if desired!
  for (int16_t i=x; i<x+w; i++) {
 80a0322:	460c      	mov	r4, r1
  // Update in subclasses if desired!
  drawLine(x, y, x+w-1, y, color);
}

void Adafruit_GFX::fillRect(int16_t x, int16_t y, int16_t w, int16_t h,
			    uint16_t color) {
 80a0324:	f9bd 8028 	ldrsh.w	r8, [sp, #40]	; 0x28
 80a0328:	f8bd 902c 	ldrh.w	r9, [sp, #44]	; 0x2c
  // Update in subclasses if desired!
  for (int16_t i=x; i<x+w; i++) {
 80a032c:	eb01 0a03 	add.w	sl, r1, r3
 80a0330:	4554      	cmp	r4, sl
 80a0332:	da0b      	bge.n	80a034c <_ZN12Adafruit_GFX8fillRectEsssst+0x32>
    drawFastVLine(i, y, h, color);
 80a0334:	682b      	ldr	r3, [r5, #0]
 80a0336:	f8cd 9000 	str.w	r9, [sp]
 80a033a:	699e      	ldr	r6, [r3, #24]
 80a033c:	4621      	mov	r1, r4
 80a033e:	4643      	mov	r3, r8
 80a0340:	463a      	mov	r2, r7
 80a0342:	4628      	mov	r0, r5
 80a0344:	3401      	adds	r4, #1
 80a0346:	47b0      	blx	r6
 80a0348:	b224      	sxth	r4, r4
}

void Adafruit_GFX::fillRect(int16_t x, int16_t y, int16_t w, int16_t h,
			    uint16_t color) {
  // Update in subclasses if desired!
  for (int16_t i=x; i<x+w; i++) {
 80a034a:	e7f1      	b.n	80a0330 <_ZN12Adafruit_GFX8fillRectEsssst+0x16>
    drawFastVLine(i, y, h, color);
  }
}
 80a034c:	b002      	add	sp, #8
 80a034e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

080a0352 <_ZN12Adafruit_GFX10fillScreenEt>:

void Adafruit_GFX::fillScreen(uint16_t color) {
 80a0352:	b513      	push	{r0, r1, r4, lr}
  fillRect(0, 0, _width, _height, color);
 80a0354:	f9b0 200e 	ldrsh.w	r2, [r0, #14]
 80a0358:	6804      	ldr	r4, [r0, #0]
 80a035a:	9101      	str	r1, [sp, #4]
 80a035c:	9200      	str	r2, [sp, #0]
 80a035e:	2200      	movs	r2, #0
 80a0360:	f9b0 300c 	ldrsh.w	r3, [r0, #12]
 80a0364:	6a64      	ldr	r4, [r4, #36]	; 0x24
 80a0366:	4611      	mov	r1, r2
 80a0368:	47a0      	blx	r4
}
 80a036a:	b002      	add	sp, #8
 80a036c:	bd10      	pop	{r4, pc}

080a036e <_ZN12Adafruit_GFX13invertDisplayEb>:
 
int16_t Adafruit_GFX::height(void) {
  return _height;
}

void Adafruit_GFX::invertDisplay(boolean i) {
 80a036e:	4770      	bx	lr

080a0370 <_ZN12Adafruit_GFXC1Ess>:
	0x00, 0x3C, 0x3C, 0x3C, 0x3C,
	0x00, 0x00, 0x00, 0x00, 0x00
};

Adafruit_GFX::Adafruit_GFX(int16_t w, int16_t h):
  WIDTH(w), HEIGHT(h)
 80a0370:	8101      	strh	r1, [r0, #8]
{
  _width    = WIDTH;
 80a0372:	8181      	strh	r1, [r0, #12]
  _height   = HEIGHT;
  rotation  = 0;
  cursor_y  = cursor_x    = 0;
  textsize  = 1;
  textcolor = textbgcolor = 0xFFFF;
 80a0374:	f64f 71ff 	movw	r1, #65535	; 0xffff
	0x00, 0x19, 0x1D, 0x17, 0x12,
	0x00, 0x3C, 0x3C, 0x3C, 0x3C,
	0x00, 0x00, 0x00, 0x00, 0x00
};

Adafruit_GFX::Adafruit_GFX(int16_t w, int16_t h):
 80a0378:	b530      	push	{r4, r5, lr}
  WIDTH(w), HEIGHT(h)
 80a037a:	4d07      	ldr	r5, [pc, #28]	; (80a0398 <_ZN12Adafruit_GFXC1Ess+0x28>)
  protected:
    void setWriteError(int err = 1) { write_error = err; }
    size_t printf_impl(bool newline, const char* format, ...);

  public:
    Print() : write_error(0) {}
 80a037c:	2400      	movs	r4, #0
 80a037e:	8142      	strh	r2, [r0, #10]
{
  _width    = WIDTH;
  _height   = HEIGHT;
 80a0380:	81c2      	strh	r2, [r0, #14]
  rotation  = 0;
  cursor_y  = cursor_x    = 0;
  textsize  = 1;
 80a0382:	2201      	movs	r2, #1
 80a0384:	6044      	str	r4, [r0, #4]
	0x00, 0x3C, 0x3C, 0x3C, 0x3C,
	0x00, 0x00, 0x00, 0x00, 0x00
};

Adafruit_GFX::Adafruit_GFX(int16_t w, int16_t h):
  WIDTH(w), HEIGHT(h)
 80a0386:	6005      	str	r5, [r0, #0]
{
  _width    = WIDTH;
  _height   = HEIGHT;
  rotation  = 0;
 80a0388:	7644      	strb	r4, [r0, #25]
  cursor_y  = cursor_x    = 0;
 80a038a:	8204      	strh	r4, [r0, #16]
 80a038c:	8244      	strh	r4, [r0, #18]
  textsize  = 1;
 80a038e:	7602      	strb	r2, [r0, #24]
  textcolor = textbgcolor = 0xFFFF;
 80a0390:	82c1      	strh	r1, [r0, #22]
 80a0392:	8281      	strh	r1, [r0, #20]
  wrap      = true;
 80a0394:	7682      	strb	r2, [r0, #26]
}
 80a0396:	bd30      	pop	{r4, r5, pc}
 80a0398:	080a1c7c 	.word	0x080a1c7c

080a039c <_ZN12Adafruit_GFX8drawCharEsshtth>:
  return 1;
}

// Draw a character
void Adafruit_GFX::drawChar(int16_t x, int16_t y, unsigned char c,
			    uint16_t color, uint16_t bg, uint8_t size) {
 80a039c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a03a0:	b08f      	sub	sp, #60	; 0x3c
 80a03a2:	9106      	str	r1, [sp, #24]
 80a03a4:	f8bd 1060 	ldrh.w	r1, [sp, #96]	; 0x60
 80a03a8:	4604      	mov	r4, r0
 80a03aa:	9107      	str	r1, [sp, #28]
 80a03ac:	f8bd 1064 	ldrh.w	r1, [sp, #100]	; 0x64
 80a03b0:	f89d 8068 	ldrb.w	r8, [sp, #104]	; 0x68
 80a03b4:	9108      	str	r1, [sp, #32]

  if((x >= _width)            || // Clip right
 80a03b6:	f9b0 100c 	ldrsh.w	r1, [r0, #12]
 80a03ba:	9806      	ldr	r0, [sp, #24]
 80a03bc:	4281      	cmp	r1, r0
 80a03be:	dd7d      	ble.n	80a04bc <_ZN12Adafruit_GFX8drawCharEsshtth+0x120>
 80a03c0:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 80a03c4:	4291      	cmp	r1, r2
 80a03c6:	dd79      	ble.n	80a04bc <_ZN12Adafruit_GFX8drawCharEsshtth+0x120>
     (y >= _height)           || // Clip bottom
 80a03c8:	2106      	movs	r1, #6
 80a03ca:	fb01 0008 	mla	r0, r1, r8, r0
 80a03ce:	2800      	cmp	r0, #0
 80a03d0:	dd74      	ble.n	80a04bc <_ZN12Adafruit_GFX8drawCharEsshtth+0x120>
     ((x + 6 * size - 1) < 0) || // Clip left
 80a03d2:	eb02 00c8 	add.w	r0, r2, r8, lsl #3
 80a03d6:	2800      	cmp	r0, #0
 80a03d8:	dd70      	ble.n	80a04bc <_ZN12Adafruit_GFX8drawCharEsshtth+0x120>
  for (int8_t i=0; i<6; i++ ) {
    uint8_t line;
    if (i == 5) 
      line = 0x0;
    else 
      line = pgm_read_byte(font+(c*5)+i);
 80a03da:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80a03de:	b295      	uxth	r5, r2
 80a03e0:	930c      	str	r3, [sp, #48]	; 0x30
 80a03e2:	f105 0308 	add.w	r3, r5, #8
 80a03e6:	b29b      	uxth	r3, r3
 80a03e8:	9109      	str	r1, [sp, #36]	; 0x24
 80a03ea:	2600      	movs	r6, #0
 80a03ec:	930d      	str	r3, [sp, #52]	; 0x34
 80a03ee:	462f      	mov	r7, r5
    for (int8_t j = 0; j<8; j++) {
      if (line & 0x1) {
        if (size == 1) // default size
          drawPixel(x+i, y+j, color);
        else {  // big size
          fillRect(x+(i*size), y+(j*size), size, size, color);
 80a03f0:	46a9      	mov	r9, r5
     ((y + 8 * size - 1) < 0))   // Clip top
    return;

  for (int8_t i=0; i<6; i++ ) {
    uint8_t line;
    if (i == 5) 
 80a03f2:	2e05      	cmp	r6, #5
      line = 0x0;
    else 
      line = pgm_read_byte(font+(c*5)+i);
 80a03f4:	bf1f      	itttt	ne
 80a03f6:	4b33      	ldrne	r3, [pc, #204]	; (80a04c4 <_ZN12Adafruit_GFX8drawCharEsshtth+0x128>)
 80a03f8:	9a0c      	ldrne	r2, [sp, #48]	; 0x30
 80a03fa:	199b      	addne	r3, r3, r6
 80a03fc:	f813 a002 	ldrbne.w	sl, [r3, r2]
    for (int8_t j = 0; j<8; j++) {
      if (line & 0x1) {
        if (size == 1) // default size
          drawPixel(x+i, y+j, color);
        else {  // big size
          fillRect(x+(i*size), y+(j*size), size, size, color);
 80a0400:	fa1f f388 	uxth.w	r3, r8
 80a0404:	9304      	str	r3, [sp, #16]
 80a0406:	9904      	ldr	r1, [sp, #16]
 80a0408:	f8bd 3018 	ldrh.w	r3, [sp, #24]
 80a040c:	b2b2      	uxth	r2, r6
 80a040e:	fb01 3102 	mla	r1, r1, r2, r3
        } 
      } else if (bg != color) {
        if (size == 1) // default size
          drawPixel(x+i, y+j, bg);
 80a0412:	4413      	add	r3, r2
    for (int8_t j = 0; j<8; j++) {
      if (line & 0x1) {
        if (size == 1) // default size
          drawPixel(x+i, y+j, color);
        else {  // big size
          fillRect(x+(i*size), y+(j*size), size, size, color);
 80a0414:	b209      	sxth	r1, r1
 80a0416:	910a      	str	r1, [sp, #40]	; 0x28
        } 
      } else if (bg != color) {
        if (size == 1) // default size
          drawPixel(x+i, y+j, bg);
 80a0418:	b21b      	sxth	r3, r3
        else {  // big size
          fillRect(x+i*size, y+j*size, size, size, bg);
 80a041a:	fa0f f188 	sxth.w	r1, r8
    return;

  for (int8_t i=0; i<6; i++ ) {
    uint8_t line;
    if (i == 5) 
      line = 0x0;
 80a041e:	bf08      	it	eq
 80a0420:	f04f 0a00 	moveq.w	sl, #0
    for (int8_t j = 0; j<8; j++) {
      if (line & 0x1) {
        if (size == 1) // default size
          drawPixel(x+i, y+j, color);
        else {  // big size
          fillRect(x+(i*size), y+(j*size), size, size, color);
 80a0424:	9505      	str	r5, [sp, #20]
        } 
      } else if (bg != color) {
        if (size == 1) // default size
          drawPixel(x+i, y+j, bg);
        else {  // big size
          fillRect(x+i*size, y+j*size, size, size, bg);
 80a0426:	9103      	str	r1, [sp, #12]
        else {  // big size
          fillRect(x+(i*size), y+(j*size), size, size, color);
        } 
      } else if (bg != color) {
        if (size == 1) // default size
          drawPixel(x+i, y+j, bg);
 80a0428:	930b      	str	r3, [sp, #44]	; 0x2c
    if (i == 5) 
      line = 0x0;
    else 
      line = pgm_read_byte(font+(c*5)+i);
    for (int8_t j = 0; j<8; j++) {
      if (line & 0x1) {
 80a042a:	f01a 0f01 	tst.w	sl, #1
 80a042e:	d011      	beq.n	80a0454 <_ZN12Adafruit_GFX8drawCharEsshtth+0xb8>
        if (size == 1) // default size
 80a0430:	f1b8 0f01 	cmp.w	r8, #1
 80a0434:	6823      	ldr	r3, [r4, #0]
 80a0436:	d103      	bne.n	80a0440 <_ZN12Adafruit_GFX8drawCharEsshtth+0xa4>
          drawPixel(x+i, y+j, color);
 80a0438:	f8d3 b010 	ldr.w	fp, [r3, #16]
 80a043c:	9b07      	ldr	r3, [sp, #28]
 80a043e:	e014      	b.n	80a046a <_ZN12Adafruit_GFX8drawCharEsshtth+0xce>
        else {  // big size
          fillRect(x+(i*size), y+(j*size), size, size, color);
 80a0440:	9a07      	ldr	r2, [sp, #28]
 80a0442:	9201      	str	r2, [sp, #4]
 80a0444:	9a03      	ldr	r2, [sp, #12]
 80a0446:	9200      	str	r2, [sp, #0]
 80a0448:	f8d3 b024 	ldr.w	fp, [r3, #36]	; 0x24
 80a044c:	4613      	mov	r3, r2
 80a044e:	fa0f f289 	sxth.w	r2, r9
 80a0452:	e018      	b.n	80a0486 <_ZN12Adafruit_GFX8drawCharEsshtth+0xea>
        } 
      } else if (bg != color) {
 80a0454:	9b07      	ldr	r3, [sp, #28]
 80a0456:	9a08      	ldr	r2, [sp, #32]
 80a0458:	4293      	cmp	r3, r2
 80a045a:	d017      	beq.n	80a048c <_ZN12Adafruit_GFX8drawCharEsshtth+0xf0>
        if (size == 1) // default size
 80a045c:	f1b8 0f01 	cmp.w	r8, #1
 80a0460:	6823      	ldr	r3, [r4, #0]
 80a0462:	d107      	bne.n	80a0474 <_ZN12Adafruit_GFX8drawCharEsshtth+0xd8>
          drawPixel(x+i, y+j, bg);
 80a0464:	f8d3 b010 	ldr.w	fp, [r3, #16]
 80a0468:	4613      	mov	r3, r2
 80a046a:	b23a      	sxth	r2, r7
 80a046c:	990b      	ldr	r1, [sp, #44]	; 0x2c
 80a046e:	4620      	mov	r0, r4
 80a0470:	47d8      	blx	fp
 80a0472:	e00b      	b.n	80a048c <_ZN12Adafruit_GFX8drawCharEsshtth+0xf0>
        else {  // big size
          fillRect(x+i*size, y+j*size, size, size, bg);
 80a0474:	9a08      	ldr	r2, [sp, #32]
 80a0476:	9201      	str	r2, [sp, #4]
 80a0478:	9a03      	ldr	r2, [sp, #12]
 80a047a:	9200      	str	r2, [sp, #0]
 80a047c:	f8d3 b024 	ldr.w	fp, [r3, #36]	; 0x24
 80a0480:	4613      	mov	r3, r2
 80a0482:	f9bd 2014 	ldrsh.w	r2, [sp, #20]
 80a0486:	990a      	ldr	r1, [sp, #40]	; 0x28
 80a0488:	4620      	mov	r0, r4
 80a048a:	47d8      	blx	fp
 80a048c:	9b04      	ldr	r3, [sp, #16]
 80a048e:	9a04      	ldr	r2, [sp, #16]
 80a0490:	4499      	add	r9, r3
 80a0492:	9b05      	ldr	r3, [sp, #20]
 80a0494:	3701      	adds	r7, #1
 80a0496:	4413      	add	r3, r2
 80a0498:	b29b      	uxth	r3, r3
 80a049a:	9305      	str	r3, [sp, #20]
    uint8_t line;
    if (i == 5) 
      line = 0x0;
    else 
      line = pgm_read_byte(font+(c*5)+i);
    for (int8_t j = 0; j<8; j++) {
 80a049c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80a049e:	b2bf      	uxth	r7, r7
 80a04a0:	429f      	cmp	r7, r3
          drawPixel(x+i, y+j, bg);
        else {  // big size
          fillRect(x+i*size, y+j*size, size, size, bg);
        }
      }
      line >>= 1;
 80a04a2:	ea4f 0a5a 	mov.w	sl, sl, lsr #1
 80a04a6:	fa1f f989 	uxth.w	r9, r9
    uint8_t line;
    if (i == 5) 
      line = 0x0;
    else 
      line = pgm_read_byte(font+(c*5)+i);
    for (int8_t j = 0; j<8; j++) {
 80a04aa:	d1be      	bne.n	80a042a <_ZN12Adafruit_GFX8drawCharEsshtth+0x8e>
 80a04ac:	9b09      	ldr	r3, [sp, #36]	; 0x24
     (y >= _height)           || // Clip bottom
     ((x + 6 * size - 1) < 0) || // Clip left
     ((y + 8 * size - 1) < 0))   // Clip top
    return;

  for (int8_t i=0; i<6; i++ ) {
 80a04ae:	3601      	adds	r6, #1
 80a04b0:	3b01      	subs	r3, #1
 80a04b2:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
 80a04b6:	b276      	sxtb	r6, r6
 80a04b8:	9309      	str	r3, [sp, #36]	; 0x24
 80a04ba:	d198      	bne.n	80a03ee <_ZN12Adafruit_GFX8drawCharEsshtth+0x52>
        }
      }
      line >>= 1;
    }
  }
}
 80a04bc:	b00f      	add	sp, #60	; 0x3c
 80a04be:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80a04c2:	bf00      	nop
 80a04c4:	080a1cac 	.word	0x080a1cac

080a04c8 <_ZN12Adafruit_GFX5writeEh>:
      }
    }
  }
}

size_t Adafruit_GFX::write(uint8_t c) {
 80a04c8:	b530      	push	{r4, r5, lr}

  if (c == '\n') {
 80a04ca:	290a      	cmp	r1, #10
      }
    }
  }
}

size_t Adafruit_GFX::write(uint8_t c) {
 80a04cc:	b085      	sub	sp, #20
 80a04ce:	4604      	mov	r4, r0
 80a04d0:	460b      	mov	r3, r1

  if (c == '\n') {
 80a04d2:	d104      	bne.n	80a04de <_ZN12Adafruit_GFX5writeEh+0x16>
    cursor_y += textsize*8;
 80a04d4:	7e02      	ldrb	r2, [r0, #24]
 80a04d6:	8a43      	ldrh	r3, [r0, #18]
 80a04d8:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 80a04dc:	e023      	b.n	80a0526 <_ZN12Adafruit_GFX5writeEh+0x5e>
    cursor_x  = 0;
  } else if (c == '\r') {
 80a04de:	290d      	cmp	r1, #13
 80a04e0:	d024      	beq.n	80a052c <_ZN12Adafruit_GFX5writeEh+0x64>
    // skip em
  } else {
    drawChar(cursor_x, cursor_y, c, textcolor, textbgcolor, textsize);
 80a04e2:	7e05      	ldrb	r5, [r0, #24]
 80a04e4:	f9b0 2012 	ldrsh.w	r2, [r0, #18]
 80a04e8:	f9b0 1010 	ldrsh.w	r1, [r0, #16]
 80a04ec:	9502      	str	r5, [sp, #8]
 80a04ee:	8ac5      	ldrh	r5, [r0, #22]
 80a04f0:	9501      	str	r5, [sp, #4]
 80a04f2:	8a85      	ldrh	r5, [r0, #20]
 80a04f4:	9500      	str	r5, [sp, #0]
 80a04f6:	f7ff ff51 	bl	80a039c <_ZN12Adafruit_GFX8drawCharEsshtth>
    cursor_x += textsize*6;
 80a04fa:	7e22      	ldrb	r2, [r4, #24]
 80a04fc:	8a23      	ldrh	r3, [r4, #16]
 80a04fe:	b291      	uxth	r1, r2
 80a0500:	eb01 0041 	add.w	r0, r1, r1, lsl #1
 80a0504:	eb03 0340 	add.w	r3, r3, r0, lsl #1
    if (wrap && (cursor_x > (_width - textsize*6))) {
 80a0508:	7ea0      	ldrb	r0, [r4, #26]
    cursor_x  = 0;
  } else if (c == '\r') {
    // skip em
  } else {
    drawChar(cursor_x, cursor_y, c, textcolor, textbgcolor, textsize);
    cursor_x += textsize*6;
 80a050a:	b21b      	sxth	r3, r3
 80a050c:	8223      	strh	r3, [r4, #16]
    if (wrap && (cursor_x > (_width - textsize*6))) {
 80a050e:	b168      	cbz	r0, 80a052c <_ZN12Adafruit_GFX5writeEh+0x64>
 80a0510:	f9b4 000c 	ldrsh.w	r0, [r4, #12]
 80a0514:	f06f 0505 	mvn.w	r5, #5
 80a0518:	fb05 0202 	mla	r2, r5, r2, r0
 80a051c:	4293      	cmp	r3, r2
 80a051e:	dd05      	ble.n	80a052c <_ZN12Adafruit_GFX5writeEh+0x64>
      cursor_y += textsize*8;
 80a0520:	8a63      	ldrh	r3, [r4, #18]
 80a0522:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
 80a0526:	8263      	strh	r3, [r4, #18]
      cursor_x = 0;
 80a0528:	2300      	movs	r3, #0
 80a052a:	8223      	strh	r3, [r4, #16]
    }
  }
  return 1;
}
 80a052c:	2001      	movs	r0, #1
 80a052e:	b005      	add	sp, #20
 80a0530:	bd30      	pop	{r4, r5, pc}

080a0532 <_ZN12Adafruit_GFX9setCursorEss>:
    }
  }
}

void Adafruit_GFX::setCursor(int16_t x, int16_t y) {
  cursor_x = x;
 80a0532:	8201      	strh	r1, [r0, #16]
  cursor_y = y;
 80a0534:	8242      	strh	r2, [r0, #18]
 80a0536:	4770      	bx	lr

080a0538 <_ZN12Adafruit_GFX11setTextSizeEh>:
}

void Adafruit_GFX::setTextSize(uint8_t s) {
  textsize = (s > 0) ? s : 1;
 80a0538:	2900      	cmp	r1, #0
 80a053a:	bf08      	it	eq
 80a053c:	2101      	moveq	r1, #1
 80a053e:	7601      	strb	r1, [r0, #24]
 80a0540:	4770      	bx	lr

080a0542 <_ZN12Adafruit_GFX12setTextColorEt>:
}

void Adafruit_GFX::setTextColor(uint16_t c) {
  // For 'transparent' background, we'll set the bg 
  // to the same as fg instead of using a flag
  textcolor = textbgcolor = c;
 80a0542:	82c1      	strh	r1, [r0, #22]
 80a0544:	8281      	strh	r1, [r0, #20]
 80a0546:	4770      	bx	lr

080a0548 <_ZN12Adafruit_GFX11setTextWrapEb>:
  textcolor   = c;
  textbgcolor = b; 
}

void Adafruit_GFX::setTextWrap(boolean w) {
  wrap = w;
 80a0548:	7681      	strb	r1, [r0, #26]
 80a054a:	4770      	bx	lr

080a054c <_ZN12Adafruit_GFX11getRotationEv>:
}

uint8_t Adafruit_GFX::getRotation(void) {
  return rotation;
}
 80a054c:	7e40      	ldrb	r0, [r0, #25]
 80a054e:	4770      	bx	lr

080a0550 <_ZN12Adafruit_GFX5widthEv>:
}

// Return the size of the display (per current rotation)
int16_t Adafruit_GFX::width(void) {
  return _width;
}
 80a0550:	f9b0 000c 	ldrsh.w	r0, [r0, #12]
 80a0554:	4770      	bx	lr

080a0556 <_ZN12Adafruit_GFX6heightEv>:
 
int16_t Adafruit_GFX::height(void) {
  return _height;
}
 80a0556:	f9b0 000e 	ldrsh.w	r0, [r0, #14]
 80a055a:	4770      	bx	lr

080a055c <_GLOBAL__sub_I__ZN12Adafruit_GFXC2Ess>:
 80a055c:	f000 bba2 	b.w	80a0ca4 <HAL_Pin_Map>

080a0560 <_ZN16Adafruit_SSD130613drawFastHLineEssst>:
  } else {
    shiftOut(sid, sclk, MSBFIRST, d);		// SSD1306 specs show MSB out first
  }
}

void Adafruit_SSD1306::drawFastHLine(int16_t x, int16_t y, int16_t w, uint16_t color) {
 80a0560:	b5f0      	push	{r4, r5, r6, r7, lr}
  boolean bSwap = false;
  switch(rotation) { 
 80a0562:	7e44      	ldrb	r4, [r0, #25]
  } else {
    shiftOut(sid, sclk, MSBFIRST, d);		// SSD1306 specs show MSB out first
  }
}

void Adafruit_SSD1306::drawFastHLine(int16_t x, int16_t y, int16_t w, uint16_t color) {
 80a0564:	f8bd 5014 	ldrh.w	r5, [sp, #20]
  boolean bSwap = false;
  switch(rotation) { 
 80a0568:	2c02      	cmp	r4, #2
 80a056a:	d008      	beq.n	80a057e <_ZN16Adafruit_SSD130613drawFastHLineEssst+0x1e>
 80a056c:	2c03      	cmp	r4, #3
 80a056e:	d00f      	beq.n	80a0590 <_ZN16Adafruit_SSD130613drawFastHLineEssst+0x30>
 80a0570:	2c01      	cmp	r4, #1
 80a0572:	d170      	bne.n	80a0656 <_ZN16Adafruit_SSD130613drawFastHLineEssst+0xf6>
      break;
    case 1:
      // 90 degree rotation, swap x & y for rotation, then invert x
      bSwap = true;
      swap(x, y);
      x = WIDTH - x - 1;
 80a0574:	8904      	ldrh	r4, [r0, #8]
 80a0576:	3c01      	subs	r4, #1
 80a0578:	1aa2      	subs	r2, r4, r2
 80a057a:	b212      	sxth	r2, r2
      break;
 80a057c:	e00c      	b.n	80a0598 <_ZN16Adafruit_SSD130613drawFastHLineEssst+0x38>
    case 2:
      // 180 degree rotation, invert x and y - then shift y around for height.
      x = WIDTH - x - 1;
      y = HEIGHT - y - 1;
 80a057e:	8944      	ldrh	r4, [r0, #10]
 80a0580:	3c01      	subs	r4, #1
 80a0582:	1aa2      	subs	r2, r4, r2
      x -= (w-1);
 80a0584:	8904      	ldrh	r4, [r0, #8]
      x = WIDTH - x - 1;
      break;
    case 2:
      // 180 degree rotation, invert x and y - then shift y around for height.
      x = WIDTH - x - 1;
      y = HEIGHT - y - 1;
 80a0586:	b212      	sxth	r2, r2
      x -= (w-1);
 80a0588:	1ae4      	subs	r4, r4, r3
 80a058a:	1a61      	subs	r1, r4, r1
 80a058c:	b209      	sxth	r1, r1
      break;
 80a058e:	e062      	b.n	80a0656 <_ZN16Adafruit_SSD130613drawFastHLineEssst+0xf6>
    case 3:
      // 270 degree rotation, swap x & y for rotation, then invert y  and adjust y for w (not to become h)
      bSwap = true;
      swap(x, y);
      y = HEIGHT - y - 1;
      y -= (w-1);
 80a0590:	8944      	ldrh	r4, [r0, #10]
 80a0592:	1ae4      	subs	r4, r4, r3
 80a0594:	1a61      	subs	r1, r4, r1
 80a0596:	b209      	sxth	r1, r1


void Adafruit_SSD1306::drawFastVLineInternal(int16_t x, int16_t __y, int16_t __h, uint16_t color) {

  // do nothing if we're off the left or right side of the screen
  if(x < 0 || x >= WIDTH) { return; }
 80a0598:	2a00      	cmp	r2, #0
 80a059a:	db5b      	blt.n	80a0654 <_ZN16Adafruit_SSD130613drawFastHLineEssst+0xf4>
 80a059c:	f9b0 4008 	ldrsh.w	r4, [r0, #8]
 80a05a0:	4294      	cmp	r4, r2
 80a05a2:	f340 8090 	ble.w	80a06c6 <_ZN16Adafruit_SSD130613drawFastHLineEssst+0x166>

  // make sure we don't try to draw below 0
  if(__y < 0) { 
 80a05a6:	2900      	cmp	r1, #0
    // __y is negative, this will subtract enough from __h to account for __y being 0
    __h += __y;
 80a05a8:	bfbe      	ittt	lt
 80a05aa:	185b      	addlt	r3, r3, r1
 80a05ac:	b21b      	sxthlt	r3, r3
    __y = 0;
 80a05ae:	2100      	movlt	r1, #0

  } 

  // make sure we don't go past the height of the display
  if( (__y + __h) > HEIGHT) { 
 80a05b0:	f9b0 000a 	ldrsh.w	r0, [r0, #10]
 80a05b4:	18cc      	adds	r4, r1, r3
 80a05b6:	4284      	cmp	r4, r0
    __h = (HEIGHT - __y);
 80a05b8:	bfc4      	itt	gt
 80a05ba:	1a43      	subgt	r3, r0, r1
 80a05bc:	b21b      	sxthgt	r3, r3
  }

  // if our height is now negative, punt 
  if(__h <= 0) { 
 80a05be:	2b00      	cmp	r3, #0
 80a05c0:	f340 8081 	ble.w	80a06c6 <_ZN16Adafruit_SSD130613drawFastHLineEssst+0x166>
    return;
  }

  // this display doesn't need ints for coordinates, use local byte registers for faster juggling
  register uint8_t y = __y;
 80a05c4:	b2c9      	uxtb	r1, r1
  // set up the pointer for fast movement through the buffer
  register uint8_t *pBuf = buffer;
  // adjust the buffer pointer for the current row
  pBuf += ((y/8) * SSD1306_LCDWIDTH);
  // and offset x columns in
  pBuf += x;
 80a05c6:	08c8      	lsrs	r0, r1, #3
 80a05c8:	4f3f      	ldr	r7, [pc, #252]	; (80a06c8 <_ZN16Adafruit_SSD130613drawFastHLineEssst+0x168>)
 80a05ca:	eb02 12c0 	add.w	r2, r2, r0, lsl #7

  // do the first partial byte, if necessary - this requires some masking
  register uint8_t mod = (y&7);
  if(mod) {
 80a05ce:	f011 0107 	ands.w	r1, r1, #7
    return;
  }

  // this display doesn't need ints for coordinates, use local byte registers for faster juggling
  register uint8_t y = __y;
  register uint8_t h = __h;
 80a05d2:	b2db      	uxtb	r3, r3
  // set up the pointer for fast movement through the buffer
  register uint8_t *pBuf = buffer;
  // adjust the buffer pointer for the current row
  pBuf += ((y/8) * SSD1306_LCDWIDTH);
  // and offset x columns in
  pBuf += x;
 80a05d4:	eb07 0402 	add.w	r4, r7, r2

  // do the first partial byte, if necessary - this requires some masking
  register uint8_t mod = (y&7);
  if(mod) {
 80a05d8:	d017      	beq.n	80a060a <_ZN16Adafruit_SSD130613drawFastHLineEssst+0xaa>
    // mask off the high n bits we want to set 
    mod = 8-mod;
 80a05da:	f1c1 0108 	rsb	r1, r1, #8
 80a05de:	b2c8      	uxtb	r0, r1

    // note - lookup table results in a nearly 10% performance improvement in fill* functions
    // register uint8_t mask = ~(0xFF >> (mod));
    static uint8_t premask[8] = {0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xFE };
    register uint8_t mask = premask[mod];
 80a05e0:	493a      	ldr	r1, [pc, #232]	; (80a06cc <_ZN16Adafruit_SSD130613drawFastHLineEssst+0x16c>)

    // adjust the mask if we're not going to reach the end of this byte
    if( h < mod) { 
 80a05e2:	4283      	cmp	r3, r0
    mod = 8-mod;

    // note - lookup table results in a nearly 10% performance improvement in fill* functions
    // register uint8_t mask = ~(0xFF >> (mod));
    static uint8_t premask[8] = {0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xFE };
    register uint8_t mask = premask[mod];
 80a05e4:	5c0e      	ldrb	r6, [r1, r0]

    // adjust the mask if we're not going to reach the end of this byte
    if( h < mod) { 
      mask &= (0XFF >> (mod-h));
 80a05e6:	bf3f      	itttt	cc
 80a05e8:	ebc3 0e00 	rsbcc	lr, r3, r0
 80a05ec:	21ff      	movcc	r1, #255	; 0xff
 80a05ee:	fa41 f10e 	asrcc.w	r1, r1, lr
 80a05f2:	400e      	andcc	r6, r1
 80a05f4:	5cb9      	ldrb	r1, [r7, r2]
    }

    if(color == WHITE) { 
 80a05f6:	2d01      	cmp	r5, #1
      *pBuf |= mask;
 80a05f8:	bf0c      	ite	eq
 80a05fa:	4331      	orreq	r1, r6
    } else {
      *pBuf &= ~mask;
 80a05fc:	43b1      	bicne	r1, r6
    }

    // fast exit if we're done here!
    if(h<mod) { return; }
 80a05fe:	4283      	cmp	r3, r0
    }

    if(color == WHITE) { 
      *pBuf |= mask;
    } else {
      *pBuf &= ~mask;
 80a0600:	54b9      	strb	r1, [r7, r2]
    }

    // fast exit if we're done here!
    if(h<mod) { return; }
 80a0602:	d360      	bcc.n	80a06c6 <_ZN16Adafruit_SSD130613drawFastHLineEssst+0x166>

    h -= mod;
 80a0604:	1a18      	subs	r0, r3, r0
 80a0606:	b2c3      	uxtb	r3, r0

    pBuf += SSD1306_LCDWIDTH;
 80a0608:	3480      	adds	r4, #128	; 0x80
  }


  // write solid bytes while we can - effectively doing 8 rows at a time
  if(h >= 8) { 
 80a060a:	2b07      	cmp	r3, #7
 80a060c:	d917      	bls.n	80a063e <_ZN16Adafruit_SSD130613drawFastHLineEssst+0xde>
    // store a local value to work with 
    register uint8_t val = (color == WHITE) ? 255 : 0;
 80a060e:	2d01      	cmp	r5, #1
 80a0610:	bf0c      	ite	eq
 80a0612:	20ff      	moveq	r0, #255	; 0xff
 80a0614:	2000      	movne	r0, #0
 80a0616:	461a      	mov	r2, r3
 80a0618:	f104 0180 	add.w	r1, r4, #128	; 0x80

      // adjust the buffer forward 8 rows worth of data
      pBuf += SSD1306_LCDWIDTH;

      // adjust h & y (there's got to be a faster way for me to do this, but this should still help a fair bit for now)
      h -= 8;
 80a061c:	3a08      	subs	r2, #8
 80a061e:	b2d2      	uxtb	r2, r2
    } while(h >= 8);
 80a0620:	2a07      	cmp	r2, #7
    // store a local value to work with 
    register uint8_t val = (color == WHITE) ? 255 : 0;

    do  {
      // write our value in
      *pBuf = val;
 80a0622:	f801 0c80 	strb.w	r0, [r1, #-128]
 80a0626:	f101 0180 	add.w	r1, r1, #128	; 0x80
      // adjust the buffer forward 8 rows worth of data
      pBuf += SSD1306_LCDWIDTH;

      // adjust h & y (there's got to be a faster way for me to do this, but this should still help a fair bit for now)
      h -= 8;
    } while(h >= 8);
 80a062a:	d8f7      	bhi.n	80a061c <_ZN16Adafruit_SSD130613drawFastHLineEssst+0xbc>
 80a062c:	f1a3 0208 	sub.w	r2, r3, #8
 80a0630:	f3c2 02c4 	ubfx	r2, r2, #3, #5
 80a0634:	3201      	adds	r2, #1
 80a0636:	eb04 14c2 	add.w	r4, r4, r2, lsl #7
 80a063a:	f003 0307 	and.w	r3, r3, #7
  }

  // now do the final partial byte, if necessary
  if(h) {
 80a063e:	2b00      	cmp	r3, #0
 80a0640:	d041      	beq.n	80a06c6 <_ZN16Adafruit_SSD130613drawFastHLineEssst+0x166>
    mod = h & 7;
    // this time we want to mask the low bits of the byte, vs the high bits we did above
    // register uint8_t mask = (1 << mod) - 1;
    // note - lookup table results in a nearly 10% performance improvement in fill* functions
    static uint8_t postmask[8] = {0x00, 0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F };
    register uint8_t mask = postmask[mod];
 80a0642:	4a23      	ldr	r2, [pc, #140]	; (80a06d0 <_ZN16Adafruit_SSD130613drawFastHLineEssst+0x170>)
    if(color == WHITE) { 
 80a0644:	2d01      	cmp	r5, #1
    mod = h & 7;
    // this time we want to mask the low bits of the byte, vs the high bits we did above
    // register uint8_t mask = (1 << mod) - 1;
    // note - lookup table results in a nearly 10% performance improvement in fill* functions
    static uint8_t postmask[8] = {0x00, 0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F };
    register uint8_t mask = postmask[mod];
 80a0646:	5cd2      	ldrb	r2, [r2, r3]
 80a0648:	7823      	ldrb	r3, [r4, #0]
    if(color == WHITE) { 
      *pBuf |= mask;
 80a064a:	bf0c      	ite	eq
 80a064c:	4313      	orreq	r3, r2
    } else { 
      *pBuf &= ~mask;
 80a064e:	4393      	bicne	r3, r2
 80a0650:	7023      	strb	r3, [r4, #0]
 80a0652:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a0654:	bdf0      	pop	{r4, r5, r6, r7, pc}
  }
}

void Adafruit_SSD1306::drawFastHLineInternal(int16_t x, int16_t y, int16_t w, uint16_t color) {
  // Do bounds/limit checks
  if(y < 0 || y >= HEIGHT) { return; }
 80a0656:	2a00      	cmp	r2, #0
 80a0658:	db35      	blt.n	80a06c6 <_ZN16Adafruit_SSD130613drawFastHLineEssst+0x166>
 80a065a:	f9b0 400a 	ldrsh.w	r4, [r0, #10]
 80a065e:	4294      	cmp	r4, r2
 80a0660:	dd31      	ble.n	80a06c6 <_ZN16Adafruit_SSD130613drawFastHLineEssst+0x166>

  // make sure we don't try to draw below 0
  if(x < 0) { 
 80a0662:	2900      	cmp	r1, #0
    w += x;
 80a0664:	bfbc      	itt	lt
 80a0666:	18c9      	addlt	r1, r1, r3
 80a0668:	b20b      	sxthlt	r3, r1
    x = 0;
  }

  // make sure we don't go off the edge of the display
  if( (x + w) > WIDTH) { 
 80a066a:	f9b0 7008 	ldrsh.w	r7, [r0, #8]
  if(y < 0 || y >= HEIGHT) { return; }

  // make sure we don't try to draw below 0
  if(x < 0) { 
    w += x;
    x = 0;
 80a066e:	bfb8      	it	lt
 80a0670:	2100      	movlt	r1, #0
  }

  // make sure we don't go off the edge of the display
  if( (x + w) > WIDTH) { 
 80a0672:	18ce      	adds	r6, r1, r3
 80a0674:	42be      	cmp	r6, r7
    w = (HEIGHT- x);
 80a0676:	bfc4      	itt	gt
 80a0678:	1a63      	subgt	r3, r4, r1
 80a067a:	b21b      	sxthgt	r3, r3
  }

  // if our width is now negative, punt
  if(w <= 0) { return; }
 80a067c:	2b00      	cmp	r3, #0
 80a067e:	dd22      	ble.n	80a06c6 <_ZN16Adafruit_SSD130613drawFastHLineEssst+0x166>
  // set up the pointer for  movement through the buffer
  register uint8_t *pBuf = buffer;
  // adjust the buffer pointer for the current row
  pBuf += ((y/8) * SSD1306_LCDWIDTH);
  // and offset x columns in
  pBuf += x;
 80a0680:	10d0      	asrs	r0, r2, #3
 80a0682:	eb01 11c0 	add.w	r1, r1, r0, lsl #7
 80a0686:	4810      	ldr	r0, [pc, #64]	; (80a06c8 <_ZN16Adafruit_SSD130613drawFastHLineEssst+0x168>)

  register uint8_t mask = 1 << (y&7);
 80a0688:	f002 0207 	and.w	r2, r2, #7
  // set up the pointer for  movement through the buffer
  register uint8_t *pBuf = buffer;
  // adjust the buffer pointer for the current row
  pBuf += ((y/8) * SSD1306_LCDWIDTH);
  // and offset x columns in
  pBuf += x;
 80a068c:	4401      	add	r1, r0

  register uint8_t mask = 1 << (y&7);
 80a068e:	2001      	movs	r0, #1
 80a0690:	fa00 f202 	lsl.w	r2, r0, r2

  if(color == WHITE) { 
 80a0694:	4285      	cmp	r5, r0
  // adjust the buffer pointer for the current row
  pBuf += ((y/8) * SSD1306_LCDWIDTH);
  // and offset x columns in
  pBuf += x;

  register uint8_t mask = 1 << (y&7);
 80a0696:	b2d2      	uxtb	r2, r2

  if(color == WHITE) { 
 80a0698:	d109      	bne.n	80a06ae <_ZN16Adafruit_SSD130613drawFastHLineEssst+0x14e>
 80a069a:	3b01      	subs	r3, #1
 80a069c:	b21b      	sxth	r3, r3
    while(w--) { *pBuf++ |= mask; }
 80a069e:	1c5c      	adds	r4, r3, #1
 80a06a0:	d011      	beq.n	80a06c6 <_ZN16Adafruit_SSD130613drawFastHLineEssst+0x166>
 80a06a2:	f811 0b01 	ldrb.w	r0, [r1], #1
 80a06a6:	4310      	orrs	r0, r2
 80a06a8:	f801 0c01 	strb.w	r0, [r1, #-1]
 80a06ac:	e7f5      	b.n	80a069a <_ZN16Adafruit_SSD130613drawFastHLineEssst+0x13a>
  } else {
    mask = ~mask;
 80a06ae:	43d2      	mvns	r2, r2
 80a06b0:	b2d2      	uxtb	r2, r2
 80a06b2:	3b01      	subs	r3, #1
 80a06b4:	b21b      	sxth	r3, r3
    while(w--) { *pBuf++ &= mask; }
 80a06b6:	1c58      	adds	r0, r3, #1
 80a06b8:	d005      	beq.n	80a06c6 <_ZN16Adafruit_SSD130613drawFastHLineEssst+0x166>
 80a06ba:	f811 0b01 	ldrb.w	r0, [r1], #1
 80a06be:	4010      	ands	r0, r2
 80a06c0:	f801 0c01 	strb.w	r0, [r1, #-1]
 80a06c4:	e7f5      	b.n	80a06b2 <_ZN16Adafruit_SSD130613drawFastHLineEssst+0x152>
 80a06c6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a06c8:	20000310 	.word	0x20000310
 80a06cc:	20000308 	.word	0x20000308
 80a06d0:	20000300 	.word	0x20000300

080a06d4 <_ZN16Adafruit_SSD130613drawFastVLineEssst>:
  }
}

void Adafruit_SSD1306::drawFastVLine(int16_t x, int16_t y, int16_t h, uint16_t color) {
 80a06d4:	b5f0      	push	{r4, r5, r6, r7, lr}
  bool bSwap = false;
  switch(rotation) { 
 80a06d6:	7e44      	ldrb	r4, [r0, #25]
    mask = ~mask;
    while(w--) { *pBuf++ &= mask; }
  }
}

void Adafruit_SSD1306::drawFastVLine(int16_t x, int16_t y, int16_t h, uint16_t color) {
 80a06d8:	f8bd 5014 	ldrh.w	r5, [sp, #20]
  bool bSwap = false;
  switch(rotation) { 
 80a06dc:	2c02      	cmp	r4, #2
 80a06de:	d008      	beq.n	80a06f2 <_ZN16Adafruit_SSD130613drawFastVLineEssst+0x1e>
 80a06e0:	2c03      	cmp	r4, #3
 80a06e2:	d00f      	beq.n	80a0704 <_ZN16Adafruit_SSD130613drawFastVLineEssst+0x30>
 80a06e4:	2c01      	cmp	r4, #1
 80a06e6:	d112      	bne.n	80a070e <_ZN16Adafruit_SSD130613drawFastVLineEssst+0x3a>
    case 1:
      // 90 degree rotation, swap x & y for rotation, then invert x and adjust x for h (now to become w)
      bSwap = true;
      swap(x, y);
      x = WIDTH - x - 1;
      x -= (h-1);
 80a06e8:	8904      	ldrh	r4, [r0, #8]
 80a06ea:	1ae4      	subs	r4, r4, r3
 80a06ec:	1aa2      	subs	r2, r4, r2
 80a06ee:	b212      	sxth	r2, r2
      break;
 80a06f0:	e06d      	b.n	80a07ce <_ZN16Adafruit_SSD130613drawFastVLineEssst+0xfa>
    case 2:
      // 180 degree rotation, invert x and y - then shift y around for height.
      x = WIDTH - x - 1;
 80a06f2:	8904      	ldrh	r4, [r0, #8]
 80a06f4:	3c01      	subs	r4, #1
 80a06f6:	1a61      	subs	r1, r4, r1
      y = HEIGHT - y - 1;
      y -= (h-1);
 80a06f8:	8944      	ldrh	r4, [r0, #10]
      x = WIDTH - x - 1;
      x -= (h-1);
      break;
    case 2:
      // 180 degree rotation, invert x and y - then shift y around for height.
      x = WIDTH - x - 1;
 80a06fa:	b209      	sxth	r1, r1
      y = HEIGHT - y - 1;
      y -= (h-1);
 80a06fc:	1ae4      	subs	r4, r4, r3
 80a06fe:	1aa2      	subs	r2, r4, r2
 80a0700:	b212      	sxth	r2, r2
      break;
 80a0702:	e004      	b.n	80a070e <_ZN16Adafruit_SSD130613drawFastVLineEssst+0x3a>
    case 3:
      // 270 degree rotation, swap x & y for rotation, then invert y 
      bSwap = true;
      swap(x, y);
      y = HEIGHT - y - 1;
 80a0704:	8944      	ldrh	r4, [r0, #10]
 80a0706:	3c01      	subs	r4, #1
 80a0708:	1a61      	subs	r1, r4, r1
 80a070a:	b209      	sxth	r1, r1
      break;
 80a070c:	e05f      	b.n	80a07ce <_ZN16Adafruit_SSD130613drawFastVLineEssst+0xfa>


void Adafruit_SSD1306::drawFastVLineInternal(int16_t x, int16_t __y, int16_t __h, uint16_t color) {

  // do nothing if we're off the left or right side of the screen
  if(x < 0 || x >= WIDTH) { return; }
 80a070e:	2900      	cmp	r1, #0
 80a0710:	db5c      	blt.n	80a07cc <_ZN16Adafruit_SSD130613drawFastVLineEssst+0xf8>
 80a0712:	f9b0 4008 	ldrsh.w	r4, [r0, #8]
 80a0716:	428c      	cmp	r4, r1
 80a0718:	f340 8091 	ble.w	80a083e <_ZN16Adafruit_SSD130613drawFastVLineEssst+0x16a>

  // make sure we don't try to draw below 0
  if(__y < 0) { 
 80a071c:	2a00      	cmp	r2, #0
    // __y is negative, this will subtract enough from __h to account for __y being 0
    __h += __y;
 80a071e:	bfbc      	itt	lt
 80a0720:	18d2      	addlt	r2, r2, r3
 80a0722:	b213      	sxthlt	r3, r2
    __y = 0;

  } 

  // make sure we don't go past the height of the display
  if( (__y + __h) > HEIGHT) { 
 80a0724:	f9b0 000a 	ldrsh.w	r0, [r0, #10]

  // make sure we don't try to draw below 0
  if(__y < 0) { 
    // __y is negative, this will subtract enough from __h to account for __y being 0
    __h += __y;
    __y = 0;
 80a0728:	bfb8      	it	lt
 80a072a:	2200      	movlt	r2, #0

  } 

  // make sure we don't go past the height of the display
  if( (__y + __h) > HEIGHT) { 
 80a072c:	18d4      	adds	r4, r2, r3
 80a072e:	4284      	cmp	r4, r0
    __h = (HEIGHT - __y);
 80a0730:	bfc4      	itt	gt
 80a0732:	1a83      	subgt	r3, r0, r2
 80a0734:	b21b      	sxthgt	r3, r3
  }

  // if our height is now negative, punt 
  if(__h <= 0) { 
 80a0736:	2b00      	cmp	r3, #0
 80a0738:	f340 8081 	ble.w	80a083e <_ZN16Adafruit_SSD130613drawFastVLineEssst+0x16a>
    return;
  }

  // this display doesn't need ints for coordinates, use local byte registers for faster juggling
  register uint8_t y = __y;
 80a073c:	b2d4      	uxtb	r4, r2
  // set up the pointer for fast movement through the buffer
  register uint8_t *pBuf = buffer;
  // adjust the buffer pointer for the current row
  pBuf += ((y/8) * SSD1306_LCDWIDTH);
  // and offset x columns in
  pBuf += x;
 80a073e:	4e40      	ldr	r6, [pc, #256]	; (80a0840 <_ZN16Adafruit_SSD130613drawFastVLineEssst+0x16c>)
    return;
  }

  // this display doesn't need ints for coordinates, use local byte registers for faster juggling
  register uint8_t y = __y;
  register uint8_t h = __h;
 80a0740:	b2da      	uxtb	r2, r3
  // set up the pointer for fast movement through the buffer
  register uint8_t *pBuf = buffer;
  // adjust the buffer pointer for the current row
  pBuf += ((y/8) * SSD1306_LCDWIDTH);
  // and offset x columns in
  pBuf += x;
 80a0742:	08e3      	lsrs	r3, r4, #3
 80a0744:	eb01 11c3 	add.w	r1, r1, r3, lsl #7

  // do the first partial byte, if necessary - this requires some masking
  register uint8_t mod = (y&7);
  if(mod) {
 80a0748:	f014 0407 	ands.w	r4, r4, #7
  // set up the pointer for fast movement through the buffer
  register uint8_t *pBuf = buffer;
  // adjust the buffer pointer for the current row
  pBuf += ((y/8) * SSD1306_LCDWIDTH);
  // and offset x columns in
  pBuf += x;
 80a074c:	eb06 0301 	add.w	r3, r6, r1

  // do the first partial byte, if necessary - this requires some masking
  register uint8_t mod = (y&7);
  if(mod) {
 80a0750:	d017      	beq.n	80a0782 <_ZN16Adafruit_SSD130613drawFastVLineEssst+0xae>
    // mask off the high n bits we want to set 
    mod = 8-mod;
 80a0752:	f1c4 0408 	rsb	r4, r4, #8
 80a0756:	b2e0      	uxtb	r0, r4

    // note - lookup table results in a nearly 10% performance improvement in fill* functions
    // register uint8_t mask = ~(0xFF >> (mod));
    static uint8_t premask[8] = {0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xFE };
    register uint8_t mask = premask[mod];
 80a0758:	4c3a      	ldr	r4, [pc, #232]	; (80a0844 <_ZN16Adafruit_SSD130613drawFastVLineEssst+0x170>)

    // adjust the mask if we're not going to reach the end of this byte
    if( h < mod) { 
 80a075a:	4282      	cmp	r2, r0
    mod = 8-mod;

    // note - lookup table results in a nearly 10% performance improvement in fill* functions
    // register uint8_t mask = ~(0xFF >> (mod));
    static uint8_t premask[8] = {0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xFE };
    register uint8_t mask = premask[mod];
 80a075c:	5c27      	ldrb	r7, [r4, r0]

    // adjust the mask if we're not going to reach the end of this byte
    if( h < mod) { 
      mask &= (0XFF >> (mod-h));
 80a075e:	bf3f      	itttt	cc
 80a0760:	ebc2 0e00 	rsbcc	lr, r2, r0
 80a0764:	24ff      	movcc	r4, #255	; 0xff
 80a0766:	fa44 f40e 	asrcc.w	r4, r4, lr
 80a076a:	4027      	andcc	r7, r4
 80a076c:	5c74      	ldrb	r4, [r6, r1]
    }

    if(color == WHITE) { 
 80a076e:	2d01      	cmp	r5, #1
      *pBuf |= mask;
 80a0770:	bf0c      	ite	eq
 80a0772:	433c      	orreq	r4, r7
    } else {
      *pBuf &= ~mask;
 80a0774:	43bc      	bicne	r4, r7
    }

    // fast exit if we're done here!
    if(h<mod) { return; }
 80a0776:	4282      	cmp	r2, r0
    }

    if(color == WHITE) { 
      *pBuf |= mask;
    } else {
      *pBuf &= ~mask;
 80a0778:	5474      	strb	r4, [r6, r1]
    }

    // fast exit if we're done here!
    if(h<mod) { return; }
 80a077a:	d360      	bcc.n	80a083e <_ZN16Adafruit_SSD130613drawFastVLineEssst+0x16a>

    h -= mod;
 80a077c:	1a10      	subs	r0, r2, r0
 80a077e:	b2c2      	uxtb	r2, r0

    pBuf += SSD1306_LCDWIDTH;
 80a0780:	3380      	adds	r3, #128	; 0x80
  }


  // write solid bytes while we can - effectively doing 8 rows at a time
  if(h >= 8) { 
 80a0782:	2a07      	cmp	r2, #7
 80a0784:	d917      	bls.n	80a07b6 <_ZN16Adafruit_SSD130613drawFastVLineEssst+0xe2>
    // store a local value to work with 
    register uint8_t val = (color == WHITE) ? 255 : 0;
 80a0786:	2d01      	cmp	r5, #1
 80a0788:	bf0c      	ite	eq
 80a078a:	24ff      	moveq	r4, #255	; 0xff
 80a078c:	2400      	movne	r4, #0
 80a078e:	4611      	mov	r1, r2
 80a0790:	f103 0080 	add.w	r0, r3, #128	; 0x80

      // adjust the buffer forward 8 rows worth of data
      pBuf += SSD1306_LCDWIDTH;

      // adjust h & y (there's got to be a faster way for me to do this, but this should still help a fair bit for now)
      h -= 8;
 80a0794:	3908      	subs	r1, #8
 80a0796:	b2c9      	uxtb	r1, r1
    } while(h >= 8);
 80a0798:	2907      	cmp	r1, #7
    // store a local value to work with 
    register uint8_t val = (color == WHITE) ? 255 : 0;

    do  {
      // write our value in
      *pBuf = val;
 80a079a:	f800 4c80 	strb.w	r4, [r0, #-128]
 80a079e:	f100 0080 	add.w	r0, r0, #128	; 0x80
      // adjust the buffer forward 8 rows worth of data
      pBuf += SSD1306_LCDWIDTH;

      // adjust h & y (there's got to be a faster way for me to do this, but this should still help a fair bit for now)
      h -= 8;
    } while(h >= 8);
 80a07a2:	d8f7      	bhi.n	80a0794 <_ZN16Adafruit_SSD130613drawFastVLineEssst+0xc0>
 80a07a4:	f1a2 0108 	sub.w	r1, r2, #8
 80a07a8:	f3c1 01c4 	ubfx	r1, r1, #3, #5
 80a07ac:	3101      	adds	r1, #1
 80a07ae:	eb03 13c1 	add.w	r3, r3, r1, lsl #7
 80a07b2:	f002 0207 	and.w	r2, r2, #7
  }

  // now do the final partial byte, if necessary
  if(h) {
 80a07b6:	2a00      	cmp	r2, #0
 80a07b8:	d041      	beq.n	80a083e <_ZN16Adafruit_SSD130613drawFastVLineEssst+0x16a>
    mod = h & 7;
    // this time we want to mask the low bits of the byte, vs the high bits we did above
    // register uint8_t mask = (1 << mod) - 1;
    // note - lookup table results in a nearly 10% performance improvement in fill* functions
    static uint8_t postmask[8] = {0x00, 0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F };
    register uint8_t mask = postmask[mod];
 80a07ba:	4923      	ldr	r1, [pc, #140]	; (80a0848 <_ZN16Adafruit_SSD130613drawFastVLineEssst+0x174>)
    if(color == WHITE) { 
 80a07bc:	2d01      	cmp	r5, #1
    mod = h & 7;
    // this time we want to mask the low bits of the byte, vs the high bits we did above
    // register uint8_t mask = (1 << mod) - 1;
    // note - lookup table results in a nearly 10% performance improvement in fill* functions
    static uint8_t postmask[8] = {0x00, 0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F };
    register uint8_t mask = postmask[mod];
 80a07be:	5c89      	ldrb	r1, [r1, r2]
 80a07c0:	781a      	ldrb	r2, [r3, #0]
    if(color == WHITE) { 
      *pBuf |= mask;
 80a07c2:	bf0c      	ite	eq
 80a07c4:	430a      	orreq	r2, r1
    } else { 
      *pBuf &= ~mask;
 80a07c6:	438a      	bicne	r2, r1
 80a07c8:	701a      	strb	r2, [r3, #0]
  if(bSwap) { 
    drawFastHLineInternal(x, y, h, color);
  } else {
    drawFastVLineInternal(x, y, h, color);
  }
}
 80a07ca:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a07cc:	bdf0      	pop	{r4, r5, r6, r7, pc}
  }
}

void Adafruit_SSD1306::drawFastHLineInternal(int16_t x, int16_t y, int16_t w, uint16_t color) {
  // Do bounds/limit checks
  if(y < 0 || y >= HEIGHT) { return; }
 80a07ce:	2900      	cmp	r1, #0
 80a07d0:	db35      	blt.n	80a083e <_ZN16Adafruit_SSD130613drawFastVLineEssst+0x16a>
 80a07d2:	f9b0 400a 	ldrsh.w	r4, [r0, #10]
 80a07d6:	428c      	cmp	r4, r1
 80a07d8:	dd31      	ble.n	80a083e <_ZN16Adafruit_SSD130613drawFastVLineEssst+0x16a>

  // make sure we don't try to draw below 0
  if(x < 0) { 
 80a07da:	2a00      	cmp	r2, #0
    w += x;
 80a07dc:	bfbc      	itt	lt
 80a07de:	18d2      	addlt	r2, r2, r3
 80a07e0:	b213      	sxthlt	r3, r2
    x = 0;
  }

  // make sure we don't go off the edge of the display
  if( (x + w) > WIDTH) { 
 80a07e2:	f9b0 7008 	ldrsh.w	r7, [r0, #8]
  if(y < 0 || y >= HEIGHT) { return; }

  // make sure we don't try to draw below 0
  if(x < 0) { 
    w += x;
    x = 0;
 80a07e6:	bfb8      	it	lt
 80a07e8:	2200      	movlt	r2, #0
  }

  // make sure we don't go off the edge of the display
  if( (x + w) > WIDTH) { 
 80a07ea:	18d6      	adds	r6, r2, r3
 80a07ec:	42be      	cmp	r6, r7
    w = (HEIGHT- x);
 80a07ee:	bfc4      	itt	gt
 80a07f0:	1aa3      	subgt	r3, r4, r2
 80a07f2:	b21b      	sxthgt	r3, r3
  }

  // if our width is now negative, punt
  if(w <= 0) { return; }
 80a07f4:	2b00      	cmp	r3, #0
 80a07f6:	dd22      	ble.n	80a083e <_ZN16Adafruit_SSD130613drawFastVLineEssst+0x16a>
  // set up the pointer for  movement through the buffer
  register uint8_t *pBuf = buffer;
  // adjust the buffer pointer for the current row
  pBuf += ((y/8) * SSD1306_LCDWIDTH);
  // and offset x columns in
  pBuf += x;
 80a07f8:	10c8      	asrs	r0, r1, #3
 80a07fa:	eb02 12c0 	add.w	r2, r2, r0, lsl #7
 80a07fe:	4810      	ldr	r0, [pc, #64]	; (80a0840 <_ZN16Adafruit_SSD130613drawFastVLineEssst+0x16c>)

  register uint8_t mask = 1 << (y&7);
 80a0800:	f001 0107 	and.w	r1, r1, #7
  // set up the pointer for  movement through the buffer
  register uint8_t *pBuf = buffer;
  // adjust the buffer pointer for the current row
  pBuf += ((y/8) * SSD1306_LCDWIDTH);
  // and offset x columns in
  pBuf += x;
 80a0804:	4410      	add	r0, r2

  register uint8_t mask = 1 << (y&7);
 80a0806:	2201      	movs	r2, #1
 80a0808:	fa02 f101 	lsl.w	r1, r2, r1

  if(color == WHITE) { 
 80a080c:	4295      	cmp	r5, r2
  // adjust the buffer pointer for the current row
  pBuf += ((y/8) * SSD1306_LCDWIDTH);
  // and offset x columns in
  pBuf += x;

  register uint8_t mask = 1 << (y&7);
 80a080e:	b2c9      	uxtb	r1, r1

  if(color == WHITE) { 
 80a0810:	d109      	bne.n	80a0826 <_ZN16Adafruit_SSD130613drawFastVLineEssst+0x152>
 80a0812:	1e5a      	subs	r2, r3, #1
 80a0814:	b213      	sxth	r3, r2
    while(w--) { *pBuf++ |= mask; }
 80a0816:	1c5c      	adds	r4, r3, #1
 80a0818:	d011      	beq.n	80a083e <_ZN16Adafruit_SSD130613drawFastVLineEssst+0x16a>
 80a081a:	f810 2b01 	ldrb.w	r2, [r0], #1
 80a081e:	430a      	orrs	r2, r1
 80a0820:	f800 2c01 	strb.w	r2, [r0, #-1]
 80a0824:	e7f5      	b.n	80a0812 <_ZN16Adafruit_SSD130613drawFastVLineEssst+0x13e>
  } else {
    mask = ~mask;
 80a0826:	43c9      	mvns	r1, r1
 80a0828:	b2c9      	uxtb	r1, r1
 80a082a:	1e5a      	subs	r2, r3, #1
 80a082c:	b213      	sxth	r3, r2
    while(w--) { *pBuf++ &= mask; }
 80a082e:	1c5a      	adds	r2, r3, #1
 80a0830:	d005      	beq.n	80a083e <_ZN16Adafruit_SSD130613drawFastVLineEssst+0x16a>
 80a0832:	f810 2b01 	ldrb.w	r2, [r0], #1
 80a0836:	400a      	ands	r2, r1
 80a0838:	f800 2c01 	strb.w	r2, [r0, #-1]
 80a083c:	e7f5      	b.n	80a082a <_ZN16Adafruit_SSD130613drawFastVLineEssst+0x156>
 80a083e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a0840:	20000310 	.word	0x20000310
 80a0844:	20000308 	.word	0x20000308
 80a0848:	20000300 	.word	0x20000300

080a084c <_ZN16Adafruit_SSD130612fastSPIwriteEh.isra.1>:
void Adafruit_SSD1306::clearDisplay(void) {
  memset(buffer, 0, (SSD1306_LCDWIDTH*SSD1306_LCDHEIGHT/8));
}


inline void Adafruit_SSD1306::fastSPIwrite(uint8_t d) {
 80a084c:	b410      	push	{r4}
  
  if(hwSPI) {
 80a084e:	b122      	cbz	r2, 80a085a <_ZN16Adafruit_SSD130612fastSPIwriteEh.isra.1+0xe>
    (void)SPI.transfer(d);
 80a0850:	4619      	mov	r1, r3
 80a0852:	4805      	ldr	r0, [pc, #20]	; (80a0868 <_ZN16Adafruit_SSD130612fastSPIwriteEh.isra.1+0x1c>)
  } else {
    shiftOut(sid, sclk, MSBFIRST, d);		// SSD1306 specs show MSB out first
  }
}
 80a0854:	bc10      	pop	{r4}


inline void Adafruit_SSD1306::fastSPIwrite(uint8_t d) {
  
  if(hwSPI) {
    (void)SPI.transfer(d);
 80a0856:	f000 bd2f 	b.w	80a12b8 <_ZN8SPIClass8transferEh>
  } else {
    shiftOut(sid, sclk, MSBFIRST, d);		// SSD1306 specs show MSB out first
 80a085a:	2201      	movs	r2, #1
 80a085c:	b2c9      	uxtb	r1, r1
 80a085e:	b2c0      	uxtb	r0, r0
  }
}
 80a0860:	bc10      	pop	{r4}
inline void Adafruit_SSD1306::fastSPIwrite(uint8_t d) {
  
  if(hwSPI) {
    (void)SPI.transfer(d);
  } else {
    shiftOut(sid, sclk, MSBFIRST, d);		// SSD1306 specs show MSB out first
 80a0862:	f000 bfd7 	b.w	80a1814 <shiftOut>
 80a0866:	bf00      	nop
 80a0868:	20000c74 	.word	0x20000c74

080a086c <_ZN16Adafruit_SSD13069drawPixelEsst>:
};



// the most basic function, set a single pixel
void Adafruit_SSD1306::drawPixel(int16_t x, int16_t y, uint16_t color) {
 80a086c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if ((x < 0) || (x >= width()) || (y < 0) || (y >= height()))
 80a086e:	1e0d      	subs	r5, r1, #0
};



// the most basic function, set a single pixel
void Adafruit_SSD1306::drawPixel(int16_t x, int16_t y, uint16_t color) {
 80a0870:	4606      	mov	r6, r0
 80a0872:	4614      	mov	r4, r2
 80a0874:	461f      	mov	r7, r3
  if ((x < 0) || (x >= width()) || (y < 0) || (y >= height()))
 80a0876:	db3f      	blt.n	80a08f8 <_ZN16Adafruit_SSD13069drawPixelEsst+0x8c>
 80a0878:	f7ff fe6a 	bl	80a0550 <_ZN12Adafruit_GFX5widthEv>
 80a087c:	4285      	cmp	r5, r0
 80a087e:	da3b      	bge.n	80a08f8 <_ZN16Adafruit_SSD13069drawPixelEsst+0x8c>
 80a0880:	2c00      	cmp	r4, #0
 80a0882:	db39      	blt.n	80a08f8 <_ZN16Adafruit_SSD13069drawPixelEsst+0x8c>
 80a0884:	4630      	mov	r0, r6
 80a0886:	f7ff fe66 	bl	80a0556 <_ZN12Adafruit_GFX6heightEv>
 80a088a:	4284      	cmp	r4, r0
 80a088c:	da34      	bge.n	80a08f8 <_ZN16Adafruit_SSD13069drawPixelEsst+0x8c>
    return;

  // check rotation, move pixel around if necessary
  switch (getRotation()) {
 80a088e:	4630      	mov	r0, r6
 80a0890:	f7ff fe5c 	bl	80a054c <_ZN12Adafruit_GFX11getRotationEv>
 80a0894:	2802      	cmp	r0, #2
 80a0896:	d127      	bne.n	80a08e8 <_ZN16Adafruit_SSD13069drawPixelEsst+0x7c>
  case 1:
    swap(x, y);
    x = WIDTH - x - 1;
    break;
  case 2:
    x = WIDTH - x - 1;
 80a0898:	8931      	ldrh	r1, [r6, #8]
    y = HEIGHT - y - 1;
 80a089a:	8970      	ldrh	r0, [r6, #10]
  case 1:
    swap(x, y);
    x = WIDTH - x - 1;
    break;
  case 2:
    x = WIDTH - x - 1;
 80a089c:	3901      	subs	r1, #1
    y = HEIGHT - y - 1;
 80a089e:	3801      	subs	r0, #1
  case 1:
    swap(x, y);
    x = WIDTH - x - 1;
    break;
  case 2:
    x = WIDTH - x - 1;
 80a08a0:	1b49      	subs	r1, r1, r5
    y = HEIGHT - y - 1;
 80a08a2:	1b00      	subs	r0, r0, r4
  case 1:
    swap(x, y);
    x = WIDTH - x - 1;
    break;
  case 2:
    x = WIDTH - x - 1;
 80a08a4:	b20d      	sxth	r5, r1
    y = HEIGHT - y - 1;
 80a08a6:	b204      	sxth	r4, r0
 80a08a8:	e006      	b.n	80a08b8 <_ZN16Adafruit_SSD13069drawPixelEsst+0x4c>
void Adafruit_SSD1306::drawPixel(int16_t x, int16_t y, uint16_t color) {
  if ((x < 0) || (x >= width()) || (y < 0) || (y >= height()))
    return;

  // check rotation, move pixel around if necessary
  switch (getRotation()) {
 80a08aa:	2801      	cmp	r0, #1
 80a08ac:	d104      	bne.n	80a08b8 <_ZN16Adafruit_SSD13069drawPixelEsst+0x4c>
  case 1:
    swap(x, y);
    x = WIDTH - x - 1;
 80a08ae:	8933      	ldrh	r3, [r6, #8]
 80a08b0:	3b01      	subs	r3, #1
 80a08b2:	1b1b      	subs	r3, r3, r4
 80a08b4:	462c      	mov	r4, r5
 80a08b6:	b21d      	sxth	r5, r3
 80a08b8:	2008      	movs	r0, #8
    break;
  }  

  // x is which column
  if (color == WHITE) 
    buffer[x+ (y/8)*SSD1306_LCDWIDTH] |= (1 << (y&7));  
 80a08ba:	fb94 f0f0 	sdiv	r0, r4, r0
    y = HEIGHT - y - 1;
    break;
  }  

  // x is which column
  if (color == WHITE) 
 80a08be:	2f01      	cmp	r7, #1
    buffer[x+ (y/8)*SSD1306_LCDWIDTH] |= (1 << (y&7));  
 80a08c0:	b200      	sxth	r0, r0
 80a08c2:	4b0e      	ldr	r3, [pc, #56]	; (80a08fc <_ZN16Adafruit_SSD13069drawPixelEsst+0x90>)
 80a08c4:	f004 0207 	and.w	r2, r4, #7
 80a08c8:	eb05 11c0 	add.w	r1, r5, r0, lsl #7
    y = HEIGHT - y - 1;
    break;
  }  

  // x is which column
  if (color == WHITE) 
 80a08cc:	d104      	bne.n	80a08d8 <_ZN16Adafruit_SSD13069drawPixelEsst+0x6c>
    buffer[x+ (y/8)*SSD1306_LCDWIDTH] |= (1 << (y&7));  
 80a08ce:	4097      	lsls	r7, r2
 80a08d0:	5c5a      	ldrb	r2, [r3, r1]
 80a08d2:	4317      	orrs	r7, r2
 80a08d4:	545f      	strb	r7, [r3, r1]
 80a08d6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  else
    buffer[x+ (y/8)*SSD1306_LCDWIDTH] &= ~(1 << (y&7)); 
 80a08d8:	5c58      	ldrb	r0, [r3, r1]
 80a08da:	2701      	movs	r7, #1
 80a08dc:	fa07 f202 	lsl.w	r2, r7, r2
 80a08e0:	ea20 0202 	bic.w	r2, r0, r2
 80a08e4:	545a      	strb	r2, [r3, r1]
 80a08e6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
void Adafruit_SSD1306::drawPixel(int16_t x, int16_t y, uint16_t color) {
  if ((x < 0) || (x >= width()) || (y < 0) || (y >= height()))
    return;

  // check rotation, move pixel around if necessary
  switch (getRotation()) {
 80a08e8:	2803      	cmp	r0, #3
 80a08ea:	d1de      	bne.n	80a08aa <_ZN16Adafruit_SSD13069drawPixelEsst+0x3e>
    x = WIDTH - x - 1;
    y = HEIGHT - y - 1;
    break;
  case 3:
    swap(x, y);
    y = HEIGHT - y - 1;
 80a08ec:	8973      	ldrh	r3, [r6, #10]
 80a08ee:	3b01      	subs	r3, #1
 80a08f0:	1b5b      	subs	r3, r3, r5
 80a08f2:	4625      	mov	r5, r4
 80a08f4:	b21c      	sxth	r4, r3
 80a08f6:	e7df      	b.n	80a08b8 <_ZN16Adafruit_SSD13069drawPixelEsst+0x4c>
 80a08f8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80a08fa:	bf00      	nop
 80a08fc:	20000310 	.word	0x20000310

080a0900 <_ZN16Adafruit_SSD1306C1Eaaa>:
  sid = SID;
  hwSPI = false;
}

// constructor for hardware SPI - we indicate DataCommand, ChipSelect, Reset 
Adafruit_SSD1306::Adafruit_SSD1306(int8_t DC, int8_t RST, int8_t CS) : Adafruit_GFX(SSD1306_LCDWIDTH, SSD1306_LCDHEIGHT) {
 80a0900:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a0902:	4604      	mov	r4, r0
 80a0904:	461d      	mov	r5, r3
 80a0906:	460f      	mov	r7, r1
 80a0908:	4616      	mov	r6, r2
 80a090a:	2180      	movs	r1, #128	; 0x80
 80a090c:	2240      	movs	r2, #64	; 0x40
 80a090e:	f7ff fd2f 	bl	80a0370 <_ZN12Adafruit_GFXC1Ess>
 80a0912:	4b06      	ldr	r3, [pc, #24]	; (80a092c <_ZN16Adafruit_SSD1306C1Eaaa+0x2c>)
  dc = DC;
 80a0914:	77e7      	strb	r7, [r4, #31]
  sid = SID;
  hwSPI = false;
}

// constructor for hardware SPI - we indicate DataCommand, ChipSelect, Reset 
Adafruit_SSD1306::Adafruit_SSD1306(int8_t DC, int8_t RST, int8_t CS) : Adafruit_GFX(SSD1306_LCDWIDTH, SSD1306_LCDHEIGHT) {
 80a0916:	6023      	str	r3, [r4, #0]
  dc = DC;
  rst = RST;
  cs = CS;
  hwSPI = true;
 80a0918:	2301      	movs	r3, #1
}

// constructor for hardware SPI - we indicate DataCommand, ChipSelect, Reset 
Adafruit_SSD1306::Adafruit_SSD1306(int8_t DC, int8_t RST, int8_t CS) : Adafruit_GFX(SSD1306_LCDWIDTH, SSD1306_LCDHEIGHT) {
  dc = DC;
  rst = RST;
 80a091a:	f884 6020 	strb.w	r6, [r4, #32]
  cs = CS;
 80a091e:	f884 5021 	strb.w	r5, [r4, #33]	; 0x21
  hwSPI = true;
 80a0922:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
}
 80a0926:	4620      	mov	r0, r4
 80a0928:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80a092a:	bf00      	nop
 80a092c:	080a21b0 	.word	0x080a21b0

080a0930 <_ZN16Adafruit_SSD130615ssd1306_commandEh>:
  } else {
    ssd1306_command(SSD1306_NORMALDISPLAY);
  }
}

void Adafruit_SSD1306::ssd1306_command(uint8_t c) { 
 80a0930:	b538      	push	{r3, r4, r5, lr}
  if (sid != -1)
 80a0932:	f990 301d 	ldrsb.w	r3, [r0, #29]
  } else {
    ssd1306_command(SSD1306_NORMALDISPLAY);
  }
}

void Adafruit_SSD1306::ssd1306_command(uint8_t c) { 
 80a0936:	4604      	mov	r4, r0
  if (sid != -1)
 80a0938:	3301      	adds	r3, #1
  } else {
    ssd1306_command(SSD1306_NORMALDISPLAY);
  }
}

void Adafruit_SSD1306::ssd1306_command(uint8_t c) { 
 80a093a:	460d      	mov	r5, r1
  if (sid != -1)
 80a093c:	d022      	beq.n	80a0984 <_ZN16Adafruit_SSD130615ssd1306_commandEh+0x54>
  {
    // SPI
    digitalWrite(cs, HIGH);
 80a093e:	f990 0021 	ldrsb.w	r0, [r0, #33]	; 0x21
 80a0942:	2101      	movs	r1, #1
 80a0944:	b280      	uxth	r0, r0
 80a0946:	f000 ff4c 	bl	80a17e2 <digitalWrite>
    digitalWrite(dc, LOW);
 80a094a:	f994 001f 	ldrsb.w	r0, [r4, #31]
 80a094e:	2100      	movs	r1, #0
 80a0950:	b280      	uxth	r0, r0
 80a0952:	f000 ff46 	bl	80a17e2 <digitalWrite>
    digitalWrite(cs, LOW);
 80a0956:	f994 0021 	ldrsb.w	r0, [r4, #33]	; 0x21
 80a095a:	2100      	movs	r1, #0
 80a095c:	b280      	uxth	r0, r0
 80a095e:	f000 ff40 	bl	80a17e2 <digitalWrite>
    fastSPIwrite(c);
 80a0962:	f994 101e 	ldrsb.w	r1, [r4, #30]
 80a0966:	f994 001d 	ldrsb.w	r0, [r4, #29]
 80a096a:	462b      	mov	r3, r5
 80a096c:	f894 2022 	ldrb.w	r2, [r4, #34]	; 0x22
 80a0970:	f7ff ff6c 	bl	80a084c <_ZN16Adafruit_SSD130612fastSPIwriteEh.isra.1>
    digitalWrite(cs, HIGH);
 80a0974:	f994 0021 	ldrsb.w	r0, [r4, #33]	; 0x21
 80a0978:	2101      	movs	r1, #1
 80a097a:	b280      	uxth	r0, r0
    Wire.beginTransmission(_i2caddr);
    Wire.write(control);
    Wire.write(c);
    Wire.endTransmission();
  }
}
 80a097c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    // SPI
    digitalWrite(cs, HIGH);
    digitalWrite(dc, LOW);
    digitalWrite(cs, LOW);
    fastSPIwrite(c);
    digitalWrite(cs, HIGH);
 80a0980:	f000 bf2f 	b.w	80a17e2 <digitalWrite>
  }
  else
  {
    // I2C
    uint8_t control = 0x00;   // Co = 0, D/C = 0
    Wire.beginTransmission(_i2caddr);
 80a0984:	f000 ff6a 	bl	80a185c <_Z19__fetch_global_Wirev>
 80a0988:	f994 101b 	ldrsb.w	r1, [r4, #27]
 80a098c:	f000 fb54 	bl	80a1038 <_ZN7TwoWire17beginTransmissionEi>
    Wire.write(control);
 80a0990:	f000 ff64 	bl	80a185c <_Z19__fetch_global_Wirev>
 80a0994:	6803      	ldr	r3, [r0, #0]
 80a0996:	2100      	movs	r1, #0
 80a0998:	689b      	ldr	r3, [r3, #8]
 80a099a:	4798      	blx	r3
    Wire.write(c);
 80a099c:	f000 ff5e 	bl	80a185c <_Z19__fetch_global_Wirev>
 80a09a0:	6803      	ldr	r3, [r0, #0]
 80a09a2:	4629      	mov	r1, r5
 80a09a4:	689b      	ldr	r3, [r3, #8]
 80a09a6:	4798      	blx	r3
    Wire.endTransmission();
 80a09a8:	f000 ff58 	bl	80a185c <_Z19__fetch_global_Wirev>
  }
}
 80a09ac:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    // I2C
    uint8_t control = 0x00;   // Co = 0, D/C = 0
    Wire.beginTransmission(_i2caddr);
    Wire.write(control);
    Wire.write(c);
    Wire.endTransmission();
 80a09b0:	f000 bb49 	b.w	80a1046 <_ZN7TwoWire15endTransmissionEv>

080a09b4 <_ZN16Adafruit_SSD13065beginEhh>:
  sclk = dc = cs = sid = -1;
  rst = reset;
}
  

void Adafruit_SSD1306::begin(uint8_t vccstate, uint8_t i2caddr) {
 80a09b4:	b538      	push	{r3, r4, r5, lr}
 80a09b6:	4604      	mov	r4, r0
  _vccstate = vccstate;
 80a09b8:	7721      	strb	r1, [r4, #28]
  _i2caddr = i2caddr;

  // set pin directions
  if (sid != -1){
 80a09ba:	f990 301d 	ldrsb.w	r3, [r0, #29]
  sclk = dc = cs = sid = -1;
  rst = reset;
}
  

void Adafruit_SSD1306::begin(uint8_t vccstate, uint8_t i2caddr) {
 80a09be:	460d      	mov	r5, r1
  _vccstate = vccstate;
  _i2caddr = i2caddr;

  // set pin directions
  if (sid != -1){
 80a09c0:	3301      	adds	r3, #1
}
  

void Adafruit_SSD1306::begin(uint8_t vccstate, uint8_t i2caddr) {
  _vccstate = vccstate;
  _i2caddr = i2caddr;
 80a09c2:	76c2      	strb	r2, [r0, #27]

  // set pin directions
  if (sid != -1){
 80a09c4:	d033      	beq.n	80a0a2e <_ZN16Adafruit_SSD13065beginEhh+0x7a>
    pinMode(dc, OUTPUT);
 80a09c6:	f990 001f 	ldrsb.w	r0, [r0, #31]
 80a09ca:	2101      	movs	r1, #1
 80a09cc:	b280      	uxth	r0, r0
 80a09ce:	f000 fef7 	bl	80a17c0 <pinMode>
    pinMode(cs, OUTPUT);
 80a09d2:	f994 0021 	ldrsb.w	r0, [r4, #33]	; 0x21
 80a09d6:	2101      	movs	r1, #1
 80a09d8:	b280      	uxth	r0, r0
 80a09da:	f000 fef1 	bl	80a17c0 <pinMode>
    if (!hwSPI){
 80a09de:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
 80a09e2:	b95b      	cbnz	r3, 80a09fc <_ZN16Adafruit_SSD13065beginEhh+0x48>
    	// set pins for software-SPI
    	pinMode(sid, OUTPUT);
 80a09e4:	f994 001d 	ldrsb.w	r0, [r4, #29]
 80a09e8:	2101      	movs	r1, #1
 80a09ea:	b280      	uxth	r0, r0
 80a09ec:	f000 fee8 	bl	80a17c0 <pinMode>
    	pinMode(sclk, OUTPUT);
 80a09f0:	f994 001e 	ldrsb.w	r0, [r4, #30]
 80a09f4:	2101      	movs	r1, #1
 80a09f6:	b280      	uxth	r0, r0
 80a09f8:	f000 fee2 	bl	80a17c0 <pinMode>
    	}
    if (hwSPI){
 80a09fc:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
 80a0a00:	b1cb      	cbz	r3, 80a0a36 <_ZN16Adafruit_SSD13065beginEhh+0x82>
        digitalWrite(cs, HIGH);
 80a0a02:	f994 0021 	ldrsb.w	r0, [r4, #33]	; 0x21
 80a0a06:	2101      	movs	r1, #1
 80a0a08:	b280      	uxth	r0, r0
 80a0a0a:	f000 feea 	bl	80a17e2 <digitalWrite>
        SPI.setBitOrder(MSBFIRST);
 80a0a0e:	2101      	movs	r1, #1
 80a0a10:	484f      	ldr	r0, [pc, #316]	; (80a0b50 <_ZN16Adafruit_SSD13065beginEhh+0x19c>)
 80a0a12:	f000 fbf0 	bl	80a11f6 <_ZN8SPIClass11setBitOrderEh>
        SPI.setClockDivider(SPI_CLOCK_DIV8);	// 72MHz / 8 = 9Mhz
 80a0a16:	2110      	movs	r1, #16
 80a0a18:	484d      	ldr	r0, [pc, #308]	; (80a0b50 <_ZN16Adafruit_SSD13065beginEhh+0x19c>)
 80a0a1a:	f000 fc39 	bl	80a1290 <_ZN8SPIClass15setClockDividerEh>
        SPI.setDataMode(0);
 80a0a1e:	2100      	movs	r1, #0
 80a0a20:	484b      	ldr	r0, [pc, #300]	; (80a0b50 <_ZN16Adafruit_SSD13065beginEhh+0x19c>)
 80a0a22:	f000 fbeb 	bl	80a11fc <_ZN8SPIClass11setDataModeEh>
        SPI.begin();	
 80a0a26:	484a      	ldr	r0, [pc, #296]	; (80a0b50 <_ZN16Adafruit_SSD13065beginEhh+0x19c>)
 80a0a28:	f000 fbe0 	bl	80a11ec <_ZN8SPIClass5beginEv>
 80a0a2c:	e003      	b.n	80a0a36 <_ZN16Adafruit_SSD13065beginEhh+0x82>
    	}
    }
  else
  {
    // I2C Init
    Wire.begin();
 80a0a2e:	f000 ff15 	bl	80a185c <_Z19__fetch_global_Wirev>
 80a0a32:	f000 faf7 	bl	80a1024 <_ZN7TwoWire5beginEv>
  }

  // Setup reset pin direction (used by both SPI and I2C)  
  pinMode(rst, OUTPUT);
 80a0a36:	f994 0020 	ldrsb.w	r0, [r4, #32]
 80a0a3a:	2101      	movs	r1, #1
 80a0a3c:	b280      	uxth	r0, r0
 80a0a3e:	f000 febf 	bl	80a17c0 <pinMode>
  digitalWrite(rst, HIGH);
 80a0a42:	f994 0020 	ldrsb.w	r0, [r4, #32]
 80a0a46:	2101      	movs	r1, #1
 80a0a48:	b280      	uxth	r0, r0
 80a0a4a:	f000 feca 	bl	80a17e2 <digitalWrite>
  // VDD (3.3V) goes high at start, lets just chill for a ms
  delay(1);
 80a0a4e:	2001      	movs	r0, #1
 80a0a50:	f000 fa9e 	bl	80a0f90 <delay>
  // bring reset low
  digitalWrite(rst, LOW);
 80a0a54:	f994 0020 	ldrsb.w	r0, [r4, #32]
 80a0a58:	2100      	movs	r1, #0
 80a0a5a:	b280      	uxth	r0, r0
 80a0a5c:	f000 fec1 	bl	80a17e2 <digitalWrite>
  // wait 10ms
  delay(10);
 80a0a60:	200a      	movs	r0, #10
 80a0a62:	f000 fa95 	bl	80a0f90 <delay>
  // bring out of reset
  digitalWrite(rst, HIGH);
 80a0a66:	f994 0020 	ldrsb.w	r0, [r4, #32]
 80a0a6a:	2101      	movs	r1, #1
 80a0a6c:	b280      	uxth	r0, r0
 80a0a6e:	f000 feb8 	bl	80a17e2 <digitalWrite>
    ssd1306_command(SSD1306_NORMALDISPLAY);                 // 0xA6
  #endif

  #if defined SSD1306_128_64
    // Init sequence for 128x64 OLED module
    ssd1306_command(SSD1306_DISPLAYOFF);                    // 0xAE
 80a0a72:	4620      	mov	r0, r4
 80a0a74:	21ae      	movs	r1, #174	; 0xae
 80a0a76:	f7ff ff5b 	bl	80a0930 <_ZN16Adafruit_SSD130615ssd1306_commandEh>
    ssd1306_command(SSD1306_SETDISPLAYCLOCKDIV);            // 0xD5
 80a0a7a:	4620      	mov	r0, r4
 80a0a7c:	21d5      	movs	r1, #213	; 0xd5
 80a0a7e:	f7ff ff57 	bl	80a0930 <_ZN16Adafruit_SSD130615ssd1306_commandEh>
    ssd1306_command(0x80);                                  // the suggested ratio 0x80
 80a0a82:	4620      	mov	r0, r4
 80a0a84:	2180      	movs	r1, #128	; 0x80
 80a0a86:	f7ff ff53 	bl	80a0930 <_ZN16Adafruit_SSD130615ssd1306_commandEh>
    ssd1306_command(SSD1306_SETMULTIPLEX);                  // 0xA8
 80a0a8a:	4620      	mov	r0, r4
 80a0a8c:	21a8      	movs	r1, #168	; 0xa8
 80a0a8e:	f7ff ff4f 	bl	80a0930 <_ZN16Adafruit_SSD130615ssd1306_commandEh>
    ssd1306_command(0x3F);
 80a0a92:	4620      	mov	r0, r4
 80a0a94:	213f      	movs	r1, #63	; 0x3f
 80a0a96:	f7ff ff4b 	bl	80a0930 <_ZN16Adafruit_SSD130615ssd1306_commandEh>
    ssd1306_command(SSD1306_SETDISPLAYOFFSET);              // 0xD3
 80a0a9a:	4620      	mov	r0, r4
 80a0a9c:	21d3      	movs	r1, #211	; 0xd3
 80a0a9e:	f7ff ff47 	bl	80a0930 <_ZN16Adafruit_SSD130615ssd1306_commandEh>
    ssd1306_command(0x0);                                   // no offset
 80a0aa2:	4620      	mov	r0, r4
 80a0aa4:	2100      	movs	r1, #0
 80a0aa6:	f7ff ff43 	bl	80a0930 <_ZN16Adafruit_SSD130615ssd1306_commandEh>
    ssd1306_command(SSD1306_SETSTARTLINE | 0x0);            // line #0
 80a0aaa:	4620      	mov	r0, r4
 80a0aac:	2140      	movs	r1, #64	; 0x40
 80a0aae:	f7ff ff3f 	bl	80a0930 <_ZN16Adafruit_SSD130615ssd1306_commandEh>
    ssd1306_command(SSD1306_CHARGEPUMP);                    // 0x8D
 80a0ab2:	218d      	movs	r1, #141	; 0x8d
 80a0ab4:	4620      	mov	r0, r4
 80a0ab6:	f7ff ff3b 	bl	80a0930 <_ZN16Adafruit_SSD130615ssd1306_commandEh>
    if (vccstate == SSD1306_EXTERNALVCC) 
 80a0aba:	2d01      	cmp	r5, #1
      { ssd1306_command(0x10); }
 80a0abc:	bf0c      	ite	eq
 80a0abe:	2110      	moveq	r1, #16
    else 
      { ssd1306_command(0x14); }
 80a0ac0:	2114      	movne	r1, #20
 80a0ac2:	4620      	mov	r0, r4
 80a0ac4:	f7ff ff34 	bl	80a0930 <_ZN16Adafruit_SSD130615ssd1306_commandEh>
    ssd1306_command(SSD1306_MEMORYMODE);                    // 0x20
 80a0ac8:	4620      	mov	r0, r4
 80a0aca:	2120      	movs	r1, #32
 80a0acc:	f7ff ff30 	bl	80a0930 <_ZN16Adafruit_SSD130615ssd1306_commandEh>
    ssd1306_command(0x00);                                  // 0x0 act like ks0108
 80a0ad0:	4620      	mov	r0, r4
 80a0ad2:	2100      	movs	r1, #0
 80a0ad4:	f7ff ff2c 	bl	80a0930 <_ZN16Adafruit_SSD130615ssd1306_commandEh>
    ssd1306_command(SSD1306_SEGREMAP | 0x1);
 80a0ad8:	4620      	mov	r0, r4
 80a0ada:	21a1      	movs	r1, #161	; 0xa1
 80a0adc:	f7ff ff28 	bl	80a0930 <_ZN16Adafruit_SSD130615ssd1306_commandEh>
    ssd1306_command(SSD1306_COMSCANDEC);
 80a0ae0:	4620      	mov	r0, r4
 80a0ae2:	21c8      	movs	r1, #200	; 0xc8
 80a0ae4:	f7ff ff24 	bl	80a0930 <_ZN16Adafruit_SSD130615ssd1306_commandEh>
    ssd1306_command(SSD1306_SETCOMPINS);                    // 0xDA
 80a0ae8:	4620      	mov	r0, r4
 80a0aea:	21da      	movs	r1, #218	; 0xda
 80a0aec:	f7ff ff20 	bl	80a0930 <_ZN16Adafruit_SSD130615ssd1306_commandEh>
    ssd1306_command(0x12);
 80a0af0:	4620      	mov	r0, r4
 80a0af2:	2112      	movs	r1, #18
 80a0af4:	f7ff ff1c 	bl	80a0930 <_ZN16Adafruit_SSD130615ssd1306_commandEh>
    ssd1306_command(SSD1306_SETCONTRAST);                   // 0x81
 80a0af8:	2181      	movs	r1, #129	; 0x81
 80a0afa:	4620      	mov	r0, r4
 80a0afc:	f7ff ff18 	bl	80a0930 <_ZN16Adafruit_SSD130615ssd1306_commandEh>
    if (vccstate == SSD1306_EXTERNALVCC) 
 80a0b00:	2d01      	cmp	r5, #1
      { ssd1306_command(0x9F); }
 80a0b02:	bf0c      	ite	eq
 80a0b04:	219f      	moveq	r1, #159	; 0x9f
    else 
      { ssd1306_command(0xCF); }
 80a0b06:	21cf      	movne	r1, #207	; 0xcf
 80a0b08:	4620      	mov	r0, r4
 80a0b0a:	f7ff ff11 	bl	80a0930 <_ZN16Adafruit_SSD130615ssd1306_commandEh>
    ssd1306_command(SSD1306_SETPRECHARGE);                  // 0xd9
 80a0b0e:	21d9      	movs	r1, #217	; 0xd9
 80a0b10:	4620      	mov	r0, r4
 80a0b12:	f7ff ff0d 	bl	80a0930 <_ZN16Adafruit_SSD130615ssd1306_commandEh>
    if (vccstate == SSD1306_EXTERNALVCC) 
 80a0b16:	2d01      	cmp	r5, #1
      { ssd1306_command(0x22); }
 80a0b18:	bf0c      	ite	eq
 80a0b1a:	2122      	moveq	r1, #34	; 0x22
    else 
      { ssd1306_command(0xF1); }
 80a0b1c:	21f1      	movne	r1, #241	; 0xf1
 80a0b1e:	4620      	mov	r0, r4
 80a0b20:	f7ff ff06 	bl	80a0930 <_ZN16Adafruit_SSD130615ssd1306_commandEh>
    ssd1306_command(SSD1306_SETVCOMDETECT);                 // 0xDB
 80a0b24:	4620      	mov	r0, r4
 80a0b26:	21db      	movs	r1, #219	; 0xdb
 80a0b28:	f7ff ff02 	bl	80a0930 <_ZN16Adafruit_SSD130615ssd1306_commandEh>
    ssd1306_command(0x40);
 80a0b2c:	4620      	mov	r0, r4
 80a0b2e:	2140      	movs	r1, #64	; 0x40
 80a0b30:	f7ff fefe 	bl	80a0930 <_ZN16Adafruit_SSD130615ssd1306_commandEh>
    ssd1306_command(SSD1306_DISPLAYALLON_RESUME);           // 0xA4
 80a0b34:	4620      	mov	r0, r4
 80a0b36:	21a4      	movs	r1, #164	; 0xa4
 80a0b38:	f7ff fefa 	bl	80a0930 <_ZN16Adafruit_SSD130615ssd1306_commandEh>
    ssd1306_command(SSD1306_NORMALDISPLAY);                 // 0xA6
 80a0b3c:	4620      	mov	r0, r4
 80a0b3e:	21a6      	movs	r1, #166	; 0xa6
 80a0b40:	f7ff fef6 	bl	80a0930 <_ZN16Adafruit_SSD130615ssd1306_commandEh>
  #endif
  
  ssd1306_command(SSD1306_DISPLAYON);//--turn on oled panel
 80a0b44:	4620      	mov	r0, r4
}
 80a0b46:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    ssd1306_command(0x40);
    ssd1306_command(SSD1306_DISPLAYALLON_RESUME);           // 0xA4
    ssd1306_command(SSD1306_NORMALDISPLAY);                 // 0xA6
  #endif
  
  ssd1306_command(SSD1306_DISPLAYON);//--turn on oled panel
 80a0b4a:	21af      	movs	r1, #175	; 0xaf
 80a0b4c:	f7ff bef0 	b.w	80a0930 <_ZN16Adafruit_SSD130615ssd1306_commandEh>
 80a0b50:	20000c74 	.word	0x20000c74

080a0b54 <_ZN16Adafruit_SSD13067displayEv>:
    Wire.write(c);
    Wire.endTransmission();
  }
}

void Adafruit_SSD1306::display(void) {
 80a0b54:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80a0b58:	4604      	mov	r4, r0
  ssd1306_command(SSD1306_COLUMNADDR);
 80a0b5a:	2121      	movs	r1, #33	; 0x21
 80a0b5c:	f7ff fee8 	bl	80a0930 <_ZN16Adafruit_SSD130615ssd1306_commandEh>
  ssd1306_command(0);   // Column start address (0 = reset)
 80a0b60:	2100      	movs	r1, #0
 80a0b62:	4620      	mov	r0, r4
 80a0b64:	f7ff fee4 	bl	80a0930 <_ZN16Adafruit_SSD130615ssd1306_commandEh>
  ssd1306_command(127); // Column end address (127 = reset)
 80a0b68:	217f      	movs	r1, #127	; 0x7f
 80a0b6a:	4620      	mov	r0, r4
 80a0b6c:	f7ff fee0 	bl	80a0930 <_ZN16Adafruit_SSD130615ssd1306_commandEh>

  ssd1306_command(SSD1306_PAGEADDR);
 80a0b70:	2122      	movs	r1, #34	; 0x22
 80a0b72:	4620      	mov	r0, r4
 80a0b74:	f7ff fedc 	bl	80a0930 <_ZN16Adafruit_SSD130615ssd1306_commandEh>
  ssd1306_command(0); // Page start address (0 = reset)
 80a0b78:	2100      	movs	r1, #0
 80a0b7a:	4620      	mov	r0, r4
 80a0b7c:	f7ff fed8 	bl	80a0930 <_ZN16Adafruit_SSD130615ssd1306_commandEh>
  ssd1306_command((SSD1306_LCDHEIGHT == 64) ? 7 : 3); // Page end address
 80a0b80:	2107      	movs	r1, #7
 80a0b82:	4620      	mov	r0, r4
 80a0b84:	f7ff fed4 	bl	80a0930 <_ZN16Adafruit_SSD130615ssd1306_commandEh>

  if (sid != -1)
 80a0b88:	f994 301d 	ldrsb.w	r3, [r4, #29]
 80a0b8c:	f8df 80ac 	ldr.w	r8, [pc, #172]	; 80a0c3c <_ZN16Adafruit_SSD13067displayEv+0xe8>
 80a0b90:	3301      	adds	r3, #1
 80a0b92:	d02e      	beq.n	80a0bf2 <_ZN16Adafruit_SSD13067displayEv+0x9e>
  {
    // SPI
    digitalWrite(cs, HIGH);
 80a0b94:	f994 0021 	ldrsb.w	r0, [r4, #33]	; 0x21
 80a0b98:	2101      	movs	r1, #1
 80a0b9a:	b280      	uxth	r0, r0
 80a0b9c:	f000 fe21 	bl	80a17e2 <digitalWrite>
    digitalWrite(dc, HIGH);
 80a0ba0:	f994 001f 	ldrsb.w	r0, [r4, #31]
 80a0ba4:	2101      	movs	r1, #1
 80a0ba6:	b280      	uxth	r0, r0
 80a0ba8:	f000 fe1b 	bl	80a17e2 <digitalWrite>
    digitalWrite(cs, LOW);
 80a0bac:	f994 0021 	ldrsb.w	r0, [r4, #33]	; 0x21
 80a0bb0:	2100      	movs	r1, #0
 80a0bb2:	b280      	uxth	r0, r0
 80a0bb4:	f000 fe15 	bl	80a17e2 <digitalWrite>
#include "delay_hal.h"

inline system_tick_t millis(void) { return HAL_Timer_Get_Milli_Seconds(); }
inline unsigned long micros(void) { return HAL_Timer_Get_Micro_Seconds(); }
void delay(unsigned long ms);
inline void delayMicroseconds(unsigned int us) { HAL_Delay_Microseconds(us); }
 80a0bb8:	2001      	movs	r0, #1
 80a0bba:	f000 f863 	bl	80a0c84 <HAL_Delay_Microseconds>
 80a0bbe:	2500      	movs	r5, #0
	delayMicroseconds(1);		// May not be necessary - needs testing

    for (uint16_t i=0; i<(SSD1306_LCDWIDTH*SSD1306_LCDHEIGHT/8); i++) {
      fastSPIwrite(buffer[i]);
 80a0bc0:	f818 3005 	ldrb.w	r3, [r8, r5]
 80a0bc4:	f894 2022 	ldrb.w	r2, [r4, #34]	; 0x22
 80a0bc8:	f994 101e 	ldrsb.w	r1, [r4, #30]
 80a0bcc:	f994 001d 	ldrsb.w	r0, [r4, #29]
 80a0bd0:	3501      	adds	r5, #1
 80a0bd2:	f7ff fe3b 	bl	80a084c <_ZN16Adafruit_SSD130612fastSPIwriteEh.isra.1>
    digitalWrite(cs, HIGH);
    digitalWrite(dc, HIGH);
    digitalWrite(cs, LOW);
	delayMicroseconds(1);		// May not be necessary - needs testing

    for (uint16_t i=0; i<(SSD1306_LCDWIDTH*SSD1306_LCDHEIGHT/8); i++) {
 80a0bd6:	f5b5 6f80 	cmp.w	r5, #1024	; 0x400
 80a0bda:	d1f1      	bne.n	80a0bc0 <_ZN16Adafruit_SSD13067displayEv+0x6c>
 80a0bdc:	2001      	movs	r0, #1
 80a0bde:	f000 f851 	bl	80a0c84 <HAL_Delay_Microseconds>
      fastSPIwrite(buffer[i]);
      //ssd1306_data(buffer[i]);
    }
	delayMicroseconds(1);		// May not be necessary - needs testing
    digitalWrite(cs, HIGH);
 80a0be2:	f994 0021 	ldrsb.w	r0, [r4, #33]	; 0x21
 80a0be6:	2101      	movs	r1, #1
 80a0be8:	b280      	uxth	r0, r0
		}
	i--;
	Wire.endTransmission();
	}
  }
}
 80a0bea:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    for (uint16_t i=0; i<(SSD1306_LCDWIDTH*SSD1306_LCDHEIGHT/8); i++) {
      fastSPIwrite(buffer[i]);
      //ssd1306_data(buffer[i]);
    }
	delayMicroseconds(1);		// May not be necessary - needs testing
    digitalWrite(cs, HIGH);
 80a0bee:	f000 bdf8 	b.w	80a17e2 <digitalWrite>
 80a0bf2:	2500      	movs	r5, #0
  else
  {
    // I2C
    for (uint16_t i=0; i<(SSD1306_LCDWIDTH*SSD1306_LCDHEIGHT/8); i++) {
      // send a bunch of data in one xmission
      Wire.beginTransmission(_i2caddr);
 80a0bf4:	f000 fe32 	bl	80a185c <_Z19__fetch_global_Wirev>
 80a0bf8:	f994 101b 	ldrsb.w	r1, [r4, #27]
 80a0bfc:	f000 fa1c 	bl	80a1038 <_ZN7TwoWire17beginTransmissionEi>
      Wire.write(0x40);
 80a0c00:	f000 fe2c 	bl	80a185c <_Z19__fetch_global_Wirev>
  bool unlock();

  inline size_t write(unsigned long n) { return write((uint8_t)n); }
  inline size_t write(long n) { return write((uint8_t)n); }
  inline size_t write(unsigned int n) { return write((uint8_t)n); }
  inline size_t write(int n) { return write((uint8_t)n); }
 80a0c04:	6803      	ldr	r3, [r0, #0]
 80a0c06:	2140      	movs	r1, #64	; 0x40
 80a0c08:	689b      	ldr	r3, [r3, #8]
 80a0c0a:	4798      	blx	r3
 80a0c0c:	2600      	movs	r6, #0
      for (uint8_t x=0; x<16; x++) {
		Wire.write(buffer[i]);
 80a0c0e:	f000 fe25 	bl	80a185c <_Z19__fetch_global_Wirev>
 80a0c12:	19af      	adds	r7, r5, r6
 80a0c14:	6803      	ldr	r3, [r0, #0]
 80a0c16:	b2bf      	uxth	r7, r7
 80a0c18:	689b      	ldr	r3, [r3, #8]
 80a0c1a:	f818 1007 	ldrb.w	r1, [r8, r7]
 80a0c1e:	3601      	adds	r6, #1
 80a0c20:	4798      	blx	r3
    // I2C
    for (uint16_t i=0; i<(SSD1306_LCDWIDTH*SSD1306_LCDHEIGHT/8); i++) {
      // send a bunch of data in one xmission
      Wire.beginTransmission(_i2caddr);
      Wire.write(0x40);
      for (uint8_t x=0; x<16; x++) {
 80a0c22:	2e10      	cmp	r6, #16
 80a0c24:	d1f3      	bne.n	80a0c0e <_ZN16Adafruit_SSD13067displayEv+0xba>
 80a0c26:	3510      	adds	r5, #16
		Wire.write(buffer[i]);
		i++;
		}
	i--;
	Wire.endTransmission();
 80a0c28:	f000 fe18 	bl	80a185c <_Z19__fetch_global_Wirev>
 80a0c2c:	b2ad      	uxth	r5, r5
 80a0c2e:	f000 fa0a 	bl	80a1046 <_ZN7TwoWire15endTransmissionEv>
    digitalWrite(cs, HIGH);
  }
  else
  {
    // I2C
    for (uint16_t i=0; i<(SSD1306_LCDWIDTH*SSD1306_LCDHEIGHT/8); i++) {
 80a0c32:	f5b5 6f80 	cmp.w	r5, #1024	; 0x400
 80a0c36:	d1dd      	bne.n	80a0bf4 <_ZN16Adafruit_SSD13067displayEv+0xa0>
		}
	i--;
	Wire.endTransmission();
	}
  }
}
 80a0c38:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80a0c3c:	20000310 	.word	0x20000310

080a0c40 <_ZN16Adafruit_SSD130612clearDisplayEv>:

// clear everything
void Adafruit_SSD1306::clearDisplay(void) {
  memset(buffer, 0, (SSD1306_LCDWIDTH*SSD1306_LCDHEIGHT/8));
 80a0c40:	f44f 6280 	mov.w	r2, #1024	; 0x400
 80a0c44:	2100      	movs	r1, #0
 80a0c46:	4801      	ldr	r0, [pc, #4]	; (80a0c4c <_ZN16Adafruit_SSD130612clearDisplayEv+0xc>)
 80a0c48:	f000 bfc9 	b.w	80a1bde <memset>
 80a0c4c:	20000310 	.word	0x20000310

080a0c50 <_GLOBAL__sub_I__ZN16Adafruit_SSD13069drawPixelEsst>:
 80a0c50:	f000 b828 	b.w	80a0ca4 <HAL_Pin_Map>

080a0c54 <os_mutex_create>:
DYNALIB_FN(8, hal_concurrent, os_timer_create, int(os_timer_t*, unsigned, void(*)(os_timer_t), void*, bool, void*))
DYNALIB_FN(9, hal_concurrent, os_timer_destroy, int(os_timer_t, void*))
DYNALIB_FN(10, hal_concurrent, os_timer_get_id, int(os_timer_t, void**))
DYNALIB_FN(11, hal_concurrent, os_timer_change, int(os_timer_t, os_timer_change_t, bool, unsigned, unsigned, void*))

DYNALIB_FN(12, hal_concurrent, os_mutex_create, int(os_mutex_t*))
 80a0c54:	b508      	push	{r3, lr}
 80a0c56:	4b02      	ldr	r3, [pc, #8]	; (80a0c60 <os_mutex_create+0xc>)
 80a0c58:	681b      	ldr	r3, [r3, #0]
 80a0c5a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a0c5c:	9301      	str	r3, [sp, #4]
 80a0c5e:	bd08      	pop	{r3, pc}
 80a0c60:	080601d0 	.word	0x080601d0

080a0c64 <HAL_Core_Get_Last_Reset_Info>:
DYNALIB_FN(22, hal_core, HAL_Set_System_Config, int(hal_system_config_t, const void*, unsigned))
DYNALIB_FN(23, hal_core, HAL_Core_Enter_Safe_Mode, void(void*))
DYNALIB_FN(24, hal_core, HAL_Feature_Get, bool(HAL_Feature))
DYNALIB_FN(25, hal_core, HAL_Feature_Set, int(HAL_Feature, bool))
DYNALIB_FN(26, hal_core, HAL_Core_System_Reset_Ex, void(int, uint32_t, void*))
DYNALIB_FN(27, hal_core, HAL_Core_Get_Last_Reset_Info, int(int*, uint32_t*, void*))
 80a0c64:	b508      	push	{r3, lr}
 80a0c66:	4b02      	ldr	r3, [pc, #8]	; (80a0c70 <HAL_Core_Get_Last_Reset_Info+0xc>)
 80a0c68:	681b      	ldr	r3, [r3, #0]
 80a0c6a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80a0c6c:	9301      	str	r3, [sp, #4]
 80a0c6e:	bd08      	pop	{r3, pc}
 80a0c70:	080601b8 	.word	0x080601b8

080a0c74 <HAL_RNG_GetRandomNumber>:

DYNALIB_BEGIN(hal)

#if PLATFORM_ID > 3
DYNALIB_FN(0, hal, HAL_RNG_Configuration, void(void))
DYNALIB_FN(1, hal, HAL_RNG_GetRandomNumber, uint32_t(void))
 80a0c74:	b508      	push	{r3, lr}
 80a0c76:	4b02      	ldr	r3, [pc, #8]	; (80a0c80 <HAL_RNG_GetRandomNumber+0xc>)
 80a0c78:	681b      	ldr	r3, [r3, #0]
 80a0c7a:	685b      	ldr	r3, [r3, #4]
 80a0c7c:	9301      	str	r3, [sp, #4]
 80a0c7e:	bd08      	pop	{r3, pc}
 80a0c80:	0806019c 	.word	0x0806019c

080a0c84 <HAL_Delay_Microseconds>:
#else
#define BASE_IDX 0
#endif

DYNALIB_FN(BASE_IDX + 0, hal, HAL_Delay_Milliseconds, void(uint32_t))
DYNALIB_FN(BASE_IDX + 1, hal, HAL_Delay_Microseconds, void(uint32_t))
 80a0c84:	b508      	push	{r3, lr}
 80a0c86:	4b02      	ldr	r3, [pc, #8]	; (80a0c90 <HAL_Delay_Microseconds+0xc>)
 80a0c88:	681b      	ldr	r3, [r3, #0]
 80a0c8a:	68db      	ldr	r3, [r3, #12]
 80a0c8c:	9301      	str	r3, [sp, #4]
 80a0c8e:	bd08      	pop	{r3, pc}
 80a0c90:	0806019c 	.word	0x0806019c

080a0c94 <HAL_Timer_Get_Milli_Seconds>:
DYNALIB_FN(BASE_IDX + 2, hal, HAL_Timer_Get_Micro_Seconds, system_tick_t(void))
DYNALIB_FN(BASE_IDX + 3, hal, HAL_Timer_Get_Milli_Seconds, system_tick_t(void))
 80a0c94:	b508      	push	{r3, lr}
 80a0c96:	4b02      	ldr	r3, [pc, #8]	; (80a0ca0 <HAL_Timer_Get_Milli_Seconds+0xc>)
 80a0c98:	681b      	ldr	r3, [r3, #0]
 80a0c9a:	695b      	ldr	r3, [r3, #20]
 80a0c9c:	9301      	str	r3, [sp, #4]
 80a0c9e:	bd08      	pop	{r3, pc}
 80a0ca0:	0806019c 	.word	0x0806019c

080a0ca4 <HAL_Pin_Map>:
// New HAL functions must be added to the end of this list.
// GNINRAW

DYNALIB_BEGIN(hal_gpio)

DYNALIB_FN(0, hal_gpio, HAL_Pin_Map, STM32_Pin_Info*(void))
 80a0ca4:	b508      	push	{r3, lr}
 80a0ca6:	4b02      	ldr	r3, [pc, #8]	; (80a0cb0 <HAL_Pin_Map+0xc>)
 80a0ca8:	681b      	ldr	r3, [r3, #0]
 80a0caa:	681b      	ldr	r3, [r3, #0]
 80a0cac:	9301      	str	r3, [sp, #4]
 80a0cae:	bd08      	pop	{r3, pc}
 80a0cb0:	080601b0 	.word	0x080601b0

080a0cb4 <HAL_Pin_Mode>:
DYNALIB_FN(1, hal_gpio, HAL_Validate_Pin_Function, PinFunction(pin_t, PinFunction))
DYNALIB_FN(2, hal_gpio, HAL_Pin_Mode, void(pin_t, PinMode))
 80a0cb4:	b508      	push	{r3, lr}
 80a0cb6:	4b02      	ldr	r3, [pc, #8]	; (80a0cc0 <HAL_Pin_Mode+0xc>)
 80a0cb8:	681b      	ldr	r3, [r3, #0]
 80a0cba:	689b      	ldr	r3, [r3, #8]
 80a0cbc:	9301      	str	r3, [sp, #4]
 80a0cbe:	bd08      	pop	{r3, pc}
 80a0cc0:	080601b0 	.word	0x080601b0

080a0cc4 <HAL_Get_Pin_Mode>:
DYNALIB_FN(3, hal_gpio, HAL_Get_Pin_Mode, PinMode(pin_t))
 80a0cc4:	b508      	push	{r3, lr}
 80a0cc6:	4b02      	ldr	r3, [pc, #8]	; (80a0cd0 <HAL_Get_Pin_Mode+0xc>)
 80a0cc8:	681b      	ldr	r3, [r3, #0]
 80a0cca:	68db      	ldr	r3, [r3, #12]
 80a0ccc:	9301      	str	r3, [sp, #4]
 80a0cce:	bd08      	pop	{r3, pc}
 80a0cd0:	080601b0 	.word	0x080601b0

080a0cd4 <HAL_GPIO_Write>:
DYNALIB_FN(4, hal_gpio, HAL_GPIO_Write, void(pin_t, uint8_t))
 80a0cd4:	b508      	push	{r3, lr}
 80a0cd6:	4b02      	ldr	r3, [pc, #8]	; (80a0ce0 <HAL_GPIO_Write+0xc>)
 80a0cd8:	681b      	ldr	r3, [r3, #0]
 80a0cda:	691b      	ldr	r3, [r3, #16]
 80a0cdc:	9301      	str	r3, [sp, #4]
 80a0cde:	bd08      	pop	{r3, pc}
 80a0ce0:	080601b0 	.word	0x080601b0

080a0ce4 <HAL_I2C_Begin>:
#endif

DYNALIB_FN(BASE_IDX + 0, hal_i2c, HAL_I2C_Set_Speed, void(HAL_I2C_Interface, uint32_t, void*))
DYNALIB_FN(BASE_IDX + 1, hal_i2c, HAL_I2C_Enable_DMA_Mode, void(HAL_I2C_Interface, bool, void*))
DYNALIB_FN(BASE_IDX + 2, hal_i2c, HAL_I2C_Stretch_Clock, void(HAL_I2C_Interface, bool, void*))
DYNALIB_FN(BASE_IDX + 3, hal_i2c, HAL_I2C_Begin, void(HAL_I2C_Interface, I2C_Mode, uint8_t, void*))
 80a0ce4:	b508      	push	{r3, lr}
 80a0ce6:	4b02      	ldr	r3, [pc, #8]	; (80a0cf0 <HAL_I2C_Begin+0xc>)
 80a0ce8:	681b      	ldr	r3, [r3, #0]
 80a0cea:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80a0cec:	9301      	str	r3, [sp, #4]
 80a0cee:	bd08      	pop	{r3, pc}
 80a0cf0:	080601ac 	.word	0x080601ac

080a0cf4 <HAL_I2C_Begin_Transmission>:
DYNALIB_FN(BASE_IDX + 4, hal_i2c, HAL_I2C_End, void(HAL_I2C_Interface, void*))
DYNALIB_FN(BASE_IDX + 5, hal_i2c, HAL_I2C_Request_Data, uint32_t(HAL_I2C_Interface, uint8_t, uint8_t, uint8_t, void*))
DYNALIB_FN(BASE_IDX + 6, hal_i2c, HAL_I2C_Begin_Transmission, void(HAL_I2C_Interface, uint8_t, void*))
 80a0cf4:	b508      	push	{r3, lr}
 80a0cf6:	4b02      	ldr	r3, [pc, #8]	; (80a0d00 <HAL_I2C_Begin_Transmission+0xc>)
 80a0cf8:	681b      	ldr	r3, [r3, #0]
 80a0cfa:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80a0cfc:	9301      	str	r3, [sp, #4]
 80a0cfe:	bd08      	pop	{r3, pc}
 80a0d00:	080601ac 	.word	0x080601ac

080a0d04 <HAL_I2C_End_Transmission>:
DYNALIB_FN(BASE_IDX + 7, hal_i2c, HAL_I2C_End_Transmission, uint8_t(HAL_I2C_Interface, uint8_t, void*))
 80a0d04:	b508      	push	{r3, lr}
 80a0d06:	4b02      	ldr	r3, [pc, #8]	; (80a0d10 <HAL_I2C_End_Transmission+0xc>)
 80a0d08:	681b      	ldr	r3, [r3, #0]
 80a0d0a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80a0d0c:	9301      	str	r3, [sp, #4]
 80a0d0e:	bd08      	pop	{r3, pc}
 80a0d10:	080601ac 	.word	0x080601ac

080a0d14 <HAL_I2C_Write_Data>:
DYNALIB_FN(BASE_IDX + 8, hal_i2c, HAL_I2C_Write_Data, uint32_t(HAL_I2C_Interface, uint8_t, void*))
 80a0d14:	b508      	push	{r3, lr}
 80a0d16:	4b02      	ldr	r3, [pc, #8]	; (80a0d20 <HAL_I2C_Write_Data+0xc>)
 80a0d18:	681b      	ldr	r3, [r3, #0]
 80a0d1a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80a0d1c:	9301      	str	r3, [sp, #4]
 80a0d1e:	bd08      	pop	{r3, pc}
 80a0d20:	080601ac 	.word	0x080601ac

080a0d24 <HAL_I2C_Available_Data>:
DYNALIB_FN(BASE_IDX + 9, hal_i2c, HAL_I2C_Available_Data, int32_t(HAL_I2C_Interface, void*))
 80a0d24:	b508      	push	{r3, lr}
 80a0d26:	4b02      	ldr	r3, [pc, #8]	; (80a0d30 <HAL_I2C_Available_Data+0xc>)
 80a0d28:	681b      	ldr	r3, [r3, #0]
 80a0d2a:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 80a0d2c:	9301      	str	r3, [sp, #4]
 80a0d2e:	bd08      	pop	{r3, pc}
 80a0d30:	080601ac 	.word	0x080601ac

080a0d34 <HAL_I2C_Read_Data>:
DYNALIB_FN(BASE_IDX + 10, hal_i2c, HAL_I2C_Read_Data, int32_t(HAL_I2C_Interface, void*))
 80a0d34:	b508      	push	{r3, lr}
 80a0d36:	4b02      	ldr	r3, [pc, #8]	; (80a0d40 <HAL_I2C_Read_Data+0xc>)
 80a0d38:	681b      	ldr	r3, [r3, #0]
 80a0d3a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80a0d3c:	9301      	str	r3, [sp, #4]
 80a0d3e:	bd08      	pop	{r3, pc}
 80a0d40:	080601ac 	.word	0x080601ac

080a0d44 <HAL_I2C_Peek_Data>:
DYNALIB_FN(BASE_IDX + 11, hal_i2c, HAL_I2C_Peek_Data, int32_t(HAL_I2C_Interface, void*))
 80a0d44:	b508      	push	{r3, lr}
 80a0d46:	4b02      	ldr	r3, [pc, #8]	; (80a0d50 <HAL_I2C_Peek_Data+0xc>)
 80a0d48:	681b      	ldr	r3, [r3, #0]
 80a0d4a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80a0d4c:	9301      	str	r3, [sp, #4]
 80a0d4e:	bd08      	pop	{r3, pc}
 80a0d50:	080601ac 	.word	0x080601ac

080a0d54 <HAL_I2C_Flush_Data>:
DYNALIB_FN(BASE_IDX + 12, hal_i2c, HAL_I2C_Flush_Data, void(HAL_I2C_Interface, void*))
 80a0d54:	b508      	push	{r3, lr}
 80a0d56:	4b02      	ldr	r3, [pc, #8]	; (80a0d60 <HAL_I2C_Flush_Data+0xc>)
 80a0d58:	681b      	ldr	r3, [r3, #0]
 80a0d5a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80a0d5c:	9301      	str	r3, [sp, #4]
 80a0d5e:	bd08      	pop	{r3, pc}
 80a0d60:	080601ac 	.word	0x080601ac

080a0d64 <HAL_I2C_Is_Enabled>:
DYNALIB_FN(BASE_IDX + 13, hal_i2c, HAL_I2C_Is_Enabled, bool(HAL_I2C_Interface, void*))
 80a0d64:	b508      	push	{r3, lr}
 80a0d66:	4b02      	ldr	r3, [pc, #8]	; (80a0d70 <HAL_I2C_Is_Enabled+0xc>)
 80a0d68:	681b      	ldr	r3, [r3, #0]
 80a0d6a:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80a0d6c:	9301      	str	r3, [sp, #4]
 80a0d6e:	bd08      	pop	{r3, pc}
 80a0d70:	080601ac 	.word	0x080601ac

080a0d74 <HAL_I2C_Init>:
DYNALIB_FN(BASE_IDX + 14, hal_i2c, HAL_I2C_Set_Callback_On_Receive, void(HAL_I2C_Interface, void(*)(int), void*))
DYNALIB_FN(BASE_IDX + 15, hal_i2c, HAL_I2C_Set_Callback_On_Request, void(HAL_I2C_Interface, void(*)(void), void*))
DYNALIB_FN(BASE_IDX + 16, hal_i2c, HAL_I2C_Init, void(HAL_I2C_Interface, void*))
 80a0d74:	b508      	push	{r3, lr}
 80a0d76:	4b03      	ldr	r3, [pc, #12]	; (80a0d84 <HAL_I2C_Init+0x10>)
 80a0d78:	681b      	ldr	r3, [r3, #0]
 80a0d7a:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 80a0d7e:	9301      	str	r3, [sp, #4]
 80a0d80:	bd08      	pop	{r3, pc}
 80a0d82:	0000      	.short	0x0000
 80a0d84:	080601ac 	.word	0x080601ac

080a0d88 <HAL_SPI_Begin>:
// New HAL functions must be added to the end of this list.
// GNINRAW

DYNALIB_BEGIN(hal_spi)

DYNALIB_FN(0, hal_spi, HAL_SPI_Begin, void(HAL_SPI_Interface, uint16_t))
 80a0d88:	b508      	push	{r3, lr}
 80a0d8a:	4b02      	ldr	r3, [pc, #8]	; (80a0d94 <HAL_SPI_Begin+0xc>)
 80a0d8c:	681b      	ldr	r3, [r3, #0]
 80a0d8e:	681b      	ldr	r3, [r3, #0]
 80a0d90:	9301      	str	r3, [sp, #4]
 80a0d92:	bd08      	pop	{r3, pc}
 80a0d94:	080601b4 	.word	0x080601b4

080a0d98 <HAL_SPI_Set_Bit_Order>:
DYNALIB_FN(1, hal_spi, HAL_SPI_End, void(HAL_SPI_Interface))
DYNALIB_FN(2, hal_spi, HAL_SPI_Set_Bit_Order, void(HAL_SPI_Interface, uint8_t))
 80a0d98:	b508      	push	{r3, lr}
 80a0d9a:	4b02      	ldr	r3, [pc, #8]	; (80a0da4 <HAL_SPI_Set_Bit_Order+0xc>)
 80a0d9c:	681b      	ldr	r3, [r3, #0]
 80a0d9e:	689b      	ldr	r3, [r3, #8]
 80a0da0:	9301      	str	r3, [sp, #4]
 80a0da2:	bd08      	pop	{r3, pc}
 80a0da4:	080601b4 	.word	0x080601b4

080a0da8 <HAL_SPI_Set_Data_Mode>:
DYNALIB_FN(3, hal_spi, HAL_SPI_Set_Data_Mode, void(HAL_SPI_Interface, uint8_t))
 80a0da8:	b508      	push	{r3, lr}
 80a0daa:	4b02      	ldr	r3, [pc, #8]	; (80a0db4 <HAL_SPI_Set_Data_Mode+0xc>)
 80a0dac:	681b      	ldr	r3, [r3, #0]
 80a0dae:	68db      	ldr	r3, [r3, #12]
 80a0db0:	9301      	str	r3, [sp, #4]
 80a0db2:	bd08      	pop	{r3, pc}
 80a0db4:	080601b4 	.word	0x080601b4

080a0db8 <HAL_SPI_Set_Clock_Divider>:
DYNALIB_FN(4, hal_spi, HAL_SPI_Set_Clock_Divider, void(HAL_SPI_Interface, uint8_t))
 80a0db8:	b508      	push	{r3, lr}
 80a0dba:	4b02      	ldr	r3, [pc, #8]	; (80a0dc4 <HAL_SPI_Set_Clock_Divider+0xc>)
 80a0dbc:	681b      	ldr	r3, [r3, #0]
 80a0dbe:	691b      	ldr	r3, [r3, #16]
 80a0dc0:	9301      	str	r3, [sp, #4]
 80a0dc2:	bd08      	pop	{r3, pc}
 80a0dc4:	080601b4 	.word	0x080601b4

080a0dc8 <HAL_SPI_Send_Receive_Data>:
DYNALIB_FN(5, hal_spi, HAL_SPI_Send_Receive_Data, uint16_t(HAL_SPI_Interface, uint16_t))
 80a0dc8:	b508      	push	{r3, lr}
 80a0dca:	4b02      	ldr	r3, [pc, #8]	; (80a0dd4 <HAL_SPI_Send_Receive_Data+0xc>)
 80a0dcc:	681b      	ldr	r3, [r3, #0]
 80a0dce:	695b      	ldr	r3, [r3, #20]
 80a0dd0:	9301      	str	r3, [sp, #4]
 80a0dd2:	bd08      	pop	{r3, pc}
 80a0dd4:	080601b4 	.word	0x080601b4

080a0dd8 <HAL_SPI_Init>:
DYNALIB_FN(6, hal_spi, HAL_SPI_Is_Enabled_Old, bool(void))
DYNALIB_FN(7, hal_spi, HAL_SPI_Init, void(HAL_SPI_Interface))
 80a0dd8:	b508      	push	{r3, lr}
 80a0dda:	4b02      	ldr	r3, [pc, #8]	; (80a0de4 <HAL_SPI_Init+0xc>)
 80a0ddc:	681b      	ldr	r3, [r3, #0]
 80a0dde:	69db      	ldr	r3, [r3, #28]
 80a0de0:	9301      	str	r3, [sp, #4]
 80a0de2:	bd08      	pop	{r3, pc}
 80a0de4:	080601b4 	.word	0x080601b4

080a0de8 <HAL_SPI_Is_Enabled>:
DYNALIB_FN(8, hal_spi, HAL_SPI_Is_Enabled, bool(HAL_SPI_Interface))
 80a0de8:	b508      	push	{r3, lr}
 80a0dea:	4b02      	ldr	r3, [pc, #8]	; (80a0df4 <HAL_SPI_Is_Enabled+0xc>)
 80a0dec:	681b      	ldr	r3, [r3, #0]
 80a0dee:	6a1b      	ldr	r3, [r3, #32]
 80a0df0:	9301      	str	r3, [sp, #4]
 80a0df2:	bd08      	pop	{r3, pc}
 80a0df4:	080601b4 	.word	0x080601b4

080a0df8 <HAL_SPI_Info>:
DYNALIB_FN(9, hal_spi, HAL_SPI_Info, void(HAL_SPI_Interface, hal_spi_info_t*, void*))
 80a0df8:	b508      	push	{r3, lr}
 80a0dfa:	4b02      	ldr	r3, [pc, #8]	; (80a0e04 <HAL_SPI_Info+0xc>)
 80a0dfc:	681b      	ldr	r3, [r3, #0]
 80a0dfe:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80a0e00:	9301      	str	r3, [sp, #4]
 80a0e02:	bd08      	pop	{r3, pc}
 80a0e04:	080601b4 	.word	0x080601b4

080a0e08 <HAL_USART_Init>:
#define BASE_IDX 6 // Base index for all subsequent functions
#else
#define BASE_IDX 0
#endif

DYNALIB_FN(BASE_IDX + 0, hal_usart, HAL_USART_Init, void(HAL_USART_Serial, Ring_Buffer*, Ring_Buffer*))
 80a0e08:	b508      	push	{r3, lr}
 80a0e0a:	4b02      	ldr	r3, [pc, #8]	; (80a0e14 <HAL_USART_Init+0xc>)
 80a0e0c:	681b      	ldr	r3, [r3, #0]
 80a0e0e:	699b      	ldr	r3, [r3, #24]
 80a0e10:	9301      	str	r3, [sp, #4]
 80a0e12:	bd08      	pop	{r3, pc}
 80a0e14:	080601c4 	.word	0x080601c4

080a0e18 <HAL_USART_Write_Data>:
DYNALIB_FN(BASE_IDX + 1, hal_usart, HAL_USART_Begin, void(HAL_USART_Serial, uint32_t))
DYNALIB_FN(BASE_IDX + 2, hal_usart, HAL_USART_End, void(HAL_USART_Serial))
DYNALIB_FN(BASE_IDX + 3, hal_usart, HAL_USART_Write_Data, uint32_t(HAL_USART_Serial, uint8_t))
 80a0e18:	b508      	push	{r3, lr}
 80a0e1a:	4b02      	ldr	r3, [pc, #8]	; (80a0e24 <HAL_USART_Write_Data+0xc>)
 80a0e1c:	681b      	ldr	r3, [r3, #0]
 80a0e1e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80a0e20:	9301      	str	r3, [sp, #4]
 80a0e22:	bd08      	pop	{r3, pc}
 80a0e24:	080601c4 	.word	0x080601c4

080a0e28 <HAL_USART_Available_Data>:
DYNALIB_FN(BASE_IDX + 4, hal_usart, HAL_USART_Available_Data, int32_t(HAL_USART_Serial))
 80a0e28:	b508      	push	{r3, lr}
 80a0e2a:	4b02      	ldr	r3, [pc, #8]	; (80a0e34 <HAL_USART_Available_Data+0xc>)
 80a0e2c:	681b      	ldr	r3, [r3, #0]
 80a0e2e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80a0e30:	9301      	str	r3, [sp, #4]
 80a0e32:	bd08      	pop	{r3, pc}
 80a0e34:	080601c4 	.word	0x080601c4

080a0e38 <HAL_USART_Read_Data>:
DYNALIB_FN(BASE_IDX + 5, hal_usart, HAL_USART_Read_Data, int32_t(HAL_USART_Serial))
 80a0e38:	b508      	push	{r3, lr}
 80a0e3a:	4b02      	ldr	r3, [pc, #8]	; (80a0e44 <HAL_USART_Read_Data+0xc>)
 80a0e3c:	681b      	ldr	r3, [r3, #0]
 80a0e3e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80a0e40:	9301      	str	r3, [sp, #4]
 80a0e42:	bd08      	pop	{r3, pc}
 80a0e44:	080601c4 	.word	0x080601c4

080a0e48 <HAL_USART_Peek_Data>:
DYNALIB_FN(BASE_IDX + 6, hal_usart, HAL_USART_Peek_Data, int32_t(HAL_USART_Serial))
 80a0e48:	b508      	push	{r3, lr}
 80a0e4a:	4b02      	ldr	r3, [pc, #8]	; (80a0e54 <HAL_USART_Peek_Data+0xc>)
 80a0e4c:	681b      	ldr	r3, [r3, #0]
 80a0e4e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a0e50:	9301      	str	r3, [sp, #4]
 80a0e52:	bd08      	pop	{r3, pc}
 80a0e54:	080601c4 	.word	0x080601c4

080a0e58 <HAL_USART_Flush_Data>:
DYNALIB_FN(BASE_IDX + 7, hal_usart, HAL_USART_Flush_Data, void(HAL_USART_Serial))
 80a0e58:	b508      	push	{r3, lr}
 80a0e5a:	4b02      	ldr	r3, [pc, #8]	; (80a0e64 <HAL_USART_Flush_Data+0xc>)
 80a0e5c:	681b      	ldr	r3, [r3, #0]
 80a0e5e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80a0e60:	9301      	str	r3, [sp, #4]
 80a0e62:	bd08      	pop	{r3, pc}
 80a0e64:	080601c4 	.word	0x080601c4

080a0e68 <HAL_USART_Is_Enabled>:
DYNALIB_FN(BASE_IDX + 8, hal_usart, HAL_USART_Is_Enabled, bool(HAL_USART_Serial))
 80a0e68:	b508      	push	{r3, lr}
 80a0e6a:	4b02      	ldr	r3, [pc, #8]	; (80a0e74 <HAL_USART_Is_Enabled+0xc>)
 80a0e6c:	681b      	ldr	r3, [r3, #0]
 80a0e6e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80a0e70:	9301      	str	r3, [sp, #4]
 80a0e72:	bd08      	pop	{r3, pc}
 80a0e74:	080601c4 	.word	0x080601c4

080a0e78 <HAL_USART_Available_Data_For_Write>:
DYNALIB_FN(BASE_IDX + 9, hal_usart, HAL_USART_Half_Duplex, void(HAL_USART_Serial, bool))
DYNALIB_FN(BASE_IDX + 10, hal_usart, HAL_USART_Available_Data_For_Write, int32_t(HAL_USART_Serial))
 80a0e78:	b508      	push	{r3, lr}
 80a0e7a:	4b02      	ldr	r3, [pc, #8]	; (80a0e84 <HAL_USART_Available_Data_For_Write+0xc>)
 80a0e7c:	681b      	ldr	r3, [r3, #0]
 80a0e7e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80a0e80:	9301      	str	r3, [sp, #4]
 80a0e82:	bd08      	pop	{r3, pc}
 80a0e84:	080601c4 	.word	0x080601c4

080a0e88 <HAL_USB_USART_Init>:
#endif

DYNALIB_BEGIN(hal_usb)

#ifdef USB_CDC_ENABLE
DYNALIB_FN(0, hal_usb, HAL_USB_USART_Init, void(HAL_USB_USART_Serial, const HAL_USB_USART_Config*))
 80a0e88:	b508      	push	{r3, lr}
 80a0e8a:	4b02      	ldr	r3, [pc, #8]	; (80a0e94 <HAL_USB_USART_Init+0xc>)
 80a0e8c:	681b      	ldr	r3, [r3, #0]
 80a0e8e:	681b      	ldr	r3, [r3, #0]
 80a0e90:	9301      	str	r3, [sp, #4]
 80a0e92:	bd08      	pop	{r3, pc}
 80a0e94:	080601d8 	.word	0x080601d8

080a0e98 <HAL_USB_USART_Available_Data>:
DYNALIB_FN(1, hal_usb, HAL_USB_USART_Begin, void(HAL_USB_USART_Serial, uint32_t, void *))
DYNALIB_FN(2, hal_usb, HAL_USB_USART_End, void(HAL_USB_USART_Serial))
DYNALIB_FN(3, hal_usb, HAL_USB_USART_Baud_Rate, unsigned int(HAL_USB_USART_Serial))
DYNALIB_FN(4, hal_usb, HAL_USB_USART_Available_Data, int32_t(HAL_USB_USART_Serial))
 80a0e98:	b508      	push	{r3, lr}
 80a0e9a:	4b02      	ldr	r3, [pc, #8]	; (80a0ea4 <HAL_USB_USART_Available_Data+0xc>)
 80a0e9c:	681b      	ldr	r3, [r3, #0]
 80a0e9e:	691b      	ldr	r3, [r3, #16]
 80a0ea0:	9301      	str	r3, [sp, #4]
 80a0ea2:	bd08      	pop	{r3, pc}
 80a0ea4:	080601d8 	.word	0x080601d8

080a0ea8 <HAL_USB_USART_Available_Data_For_Write>:
DYNALIB_FN(5, hal_usb, HAL_USB_USART_Available_Data_For_Write, int32_t(HAL_USB_USART_Serial))
 80a0ea8:	b508      	push	{r3, lr}
 80a0eaa:	4b02      	ldr	r3, [pc, #8]	; (80a0eb4 <HAL_USB_USART_Available_Data_For_Write+0xc>)
 80a0eac:	681b      	ldr	r3, [r3, #0]
 80a0eae:	695b      	ldr	r3, [r3, #20]
 80a0eb0:	9301      	str	r3, [sp, #4]
 80a0eb2:	bd08      	pop	{r3, pc}
 80a0eb4:	080601d8 	.word	0x080601d8

080a0eb8 <HAL_USB_USART_Receive_Data>:
DYNALIB_FN(6, hal_usb, HAL_USB_USART_Receive_Data, int32_t(HAL_USB_USART_Serial, uint8_t))
 80a0eb8:	b508      	push	{r3, lr}
 80a0eba:	4b02      	ldr	r3, [pc, #8]	; (80a0ec4 <HAL_USB_USART_Receive_Data+0xc>)
 80a0ebc:	681b      	ldr	r3, [r3, #0]
 80a0ebe:	699b      	ldr	r3, [r3, #24]
 80a0ec0:	9301      	str	r3, [sp, #4]
 80a0ec2:	bd08      	pop	{r3, pc}
 80a0ec4:	080601d8 	.word	0x080601d8

080a0ec8 <HAL_USB_USART_Send_Data>:
DYNALIB_FN(7, hal_usb, HAL_USB_USART_Send_Data, int32_t(HAL_USB_USART_Serial, uint8_t))
 80a0ec8:	b508      	push	{r3, lr}
 80a0eca:	4b02      	ldr	r3, [pc, #8]	; (80a0ed4 <HAL_USB_USART_Send_Data+0xc>)
 80a0ecc:	681b      	ldr	r3, [r3, #0]
 80a0ece:	69db      	ldr	r3, [r3, #28]
 80a0ed0:	9301      	str	r3, [sp, #4]
 80a0ed2:	bd08      	pop	{r3, pc}
 80a0ed4:	080601d8 	.word	0x080601d8

080a0ed8 <HAL_USB_USART_Flush_Data>:
DYNALIB_FN(8, hal_usb, HAL_USB_USART_Flush_Data, void(HAL_USB_USART_Serial))
 80a0ed8:	b508      	push	{r3, lr}
 80a0eda:	4b02      	ldr	r3, [pc, #8]	; (80a0ee4 <HAL_USB_USART_Flush_Data+0xc>)
 80a0edc:	681b      	ldr	r3, [r3, #0]
 80a0ede:	6a1b      	ldr	r3, [r3, #32]
 80a0ee0:	9301      	str	r3, [sp, #4]
 80a0ee2:	bd08      	pop	{r3, pc}
 80a0ee4:	080601d8 	.word	0x080601d8

080a0ee8 <panic_>:
DYNALIB_FN(9, services, LED_Toggle, void(Led_TypeDef))
DYNALIB_FN(10, services, LED_Fade, void(Led_TypeDef))
DYNALIB_FN(11, services, Get_LED_Brightness, uint8_t(void))

DYNALIB_FN(12, services, set_logger_output, void(debug_output_fn, LoggerOutputLevel)) // Deprecated
DYNALIB_FN(13, services, panic_, void(ePanicCode, void*, void(*)(uint32_t)))
 80a0ee8:	b508      	push	{r3, lr}
 80a0eea:	4b02      	ldr	r3, [pc, #8]	; (80a0ef4 <panic_+0xc>)
 80a0eec:	681b      	ldr	r3, [r3, #0]
 80a0eee:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80a0ef0:	9301      	str	r3, [sp, #4]
 80a0ef2:	bd08      	pop	{r3, pc}
 80a0ef4:	080201a8 	.word	0x080201a8

080a0ef8 <set_system_mode>:
#endif

DYNALIB_BEGIN(system)

DYNALIB_FN(0, system, system_mode, System_Mode_TypeDef(void))
DYNALIB_FN(1, system, set_system_mode, void(System_Mode_TypeDef))
 80a0ef8:	b508      	push	{r3, lr}
 80a0efa:	4b02      	ldr	r3, [pc, #8]	; (80a0f04 <set_system_mode+0xc>)
 80a0efc:	681b      	ldr	r3, [r3, #0]
 80a0efe:	685b      	ldr	r3, [r3, #4]
 80a0f00:	9301      	str	r3, [sp, #4]
 80a0f02:	bd08      	pop	{r3, pc}
 80a0f04:	080601a4 	.word	0x080601a4

080a0f08 <system_delay_ms>:

DYNALIB_FN(2, system, set_ymodem_serial_flash_update_handler, void(ymodem_serial_flash_update_handler))
DYNALIB_FN(3, system, system_firmwareUpdate, bool(Stream*, void*))
DYNALIB_FN(4, system, system_fileTransfer, bool(system_file_transfer_t*, void*))

DYNALIB_FN(5, system, system_delay_ms, void(unsigned long, bool))
 80a0f08:	b508      	push	{r3, lr}
 80a0f0a:	4b02      	ldr	r3, [pc, #8]	; (80a0f14 <system_delay_ms+0xc>)
 80a0f0c:	681b      	ldr	r3, [r3, #0]
 80a0f0e:	695b      	ldr	r3, [r3, #20]
 80a0f10:	9301      	str	r3, [sp, #4]
 80a0f12:	bd08      	pop	{r3, pc}
 80a0f14:	080601a4 	.word	0x080601a4

080a0f18 <system_ctrl_set_app_request_handler>:
DYNALIB_FN(BASE_IDX + 6, system, led_pattern_period, uint16_t(int, int, void*))
DYNALIB_FN(BASE_IDX + 7, system, system_set_tester_handlers, int(system_tester_handlers_t*, void*))
DYNALIB_FN(BASE_IDX + 8, system, system_format_diag_data, int(const uint16_t*, size_t, unsigned, appender_fn, void*, void*))

// Control requests
DYNALIB_FN(BASE_IDX + 9, system, system_ctrl_set_app_request_handler, int(ctrl_request_handler_fn, void*))
 80a0f18:	b508      	push	{r3, lr}
 80a0f1a:	4b03      	ldr	r3, [pc, #12]	; (80a0f28 <system_ctrl_set_app_request_handler+0x10>)
 80a0f1c:	681b      	ldr	r3, [r3, #0]
 80a0f1e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80a0f22:	9301      	str	r3, [sp, #4]
 80a0f24:	bd08      	pop	{r3, pc}
 80a0f26:	0000      	.short	0x0000
 80a0f28:	080601a4 	.word	0x080601a4

080a0f2c <system_ctrl_set_result>:
DYNALIB_FN(BASE_IDX + 10, system, system_ctrl_alloc_reply_data, int(ctrl_request*, size_t, void*))
DYNALIB_FN(BASE_IDX + 11, system, system_ctrl_free_request_data, void(ctrl_request*, void*))
DYNALIB_FN(BASE_IDX + 12, system, system_ctrl_set_result, void(ctrl_request*, int, ctrl_completion_handler_fn, void*, void*))
 80a0f2c:	b508      	push	{r3, lr}
 80a0f2e:	4b03      	ldr	r3, [pc, #12]	; (80a0f3c <system_ctrl_set_result+0x10>)
 80a0f30:	681b      	ldr	r3, [r3, #0]
 80a0f32:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 80a0f36:	9301      	str	r3, [sp, #4]
 80a0f38:	bd08      	pop	{r3, pc}
 80a0f3a:	0000      	.short	0x0000
 80a0f3c:	080601a4 	.word	0x080601a4

080a0f40 <spark_set_random_seed_from_cloud_handler>:
DYNALIB_FN(10, system_cloud, spark_unsubscribe, void(void*))
DYNALIB_FN(11, system_cloud, spark_sync_time, bool(void*))
DYNALIB_FN(12, system_cloud, spark_sync_time_pending, bool(void*))
DYNALIB_FN(13, system_cloud, spark_sync_time_last, system_tick_t(time_t*, void*))
DYNALIB_FN(14, system_cloud, spark_set_connection_property, int(unsigned, unsigned, particle::protocol::connection_properties_t*, void*))
DYNALIB_FN(15, system_cloud, spark_set_random_seed_from_cloud_handler, int(void (*handler)(unsigned int), void*))
 80a0f40:	b508      	push	{r3, lr}
 80a0f42:	4b02      	ldr	r3, [pc, #8]	; (80a0f4c <spark_set_random_seed_from_cloud_handler+0xc>)
 80a0f44:	681b      	ldr	r3, [r3, #0]
 80a0f46:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80a0f48:	9301      	str	r3, [sp, #4]
 80a0f4a:	bd08      	pop	{r3, pc}
 80a0f4c:	080601cc 	.word	0x080601cc

080a0f50 <network_ready>:

DYNALIB_FN(0, system_net, network_config, const void*(network_handle_t, uint32_t, void*))
DYNALIB_FN(1, system_net, network_connect, void(network_handle_t, uint32_t, uint32_t, void*))
DYNALIB_FN(2, system_net, network_connecting, bool(network_handle_t, uint32_t, void*))
DYNALIB_FN(3, system_net, network_disconnect, void(network_handle_t, uint32_t, void*))
DYNALIB_FN(4, system_net, network_ready, bool(network_handle_t, uint32_t, void*))
 80a0f50:	b508      	push	{r3, lr}
 80a0f52:	4b02      	ldr	r3, [pc, #8]	; (80a0f5c <network_ready+0xc>)
 80a0f54:	681b      	ldr	r3, [r3, #0]
 80a0f56:	691b      	ldr	r3, [r3, #16]
 80a0f58:	9301      	str	r3, [sp, #4]
 80a0f5a:	bd08      	pop	{r3, pc}
 80a0f5c:	080601c8 	.word	0x080601c8

080a0f60 <malloc>:

#include "dynalib.h"

DYNALIB_BEGIN(rt)

DYNALIB_FN(0, rt, malloc, void*(size_t))
 80a0f60:	b508      	push	{r3, lr}
 80a0f62:	4b02      	ldr	r3, [pc, #8]	; (80a0f6c <malloc+0xc>)
 80a0f64:	681b      	ldr	r3, [r3, #0]
 80a0f66:	681b      	ldr	r3, [r3, #0]
 80a0f68:	9301      	str	r3, [sp, #4]
 80a0f6a:	bd08      	pop	{r3, pc}
 80a0f6c:	080601a0 	.word	0x080601a0

080a0f70 <free>:
DYNALIB_FN(1, rt, free, void(void*))
 80a0f70:	b508      	push	{r3, lr}
 80a0f72:	4b02      	ldr	r3, [pc, #8]	; (80a0f7c <free+0xc>)
 80a0f74:	681b      	ldr	r3, [r3, #0]
 80a0f76:	685b      	ldr	r3, [r3, #4]
 80a0f78:	9301      	str	r3, [sp, #4]
 80a0f7a:	bd08      	pop	{r3, pc}
 80a0f7c:	080601a0 	.word	0x080601a0

080a0f80 <realloc>:
DYNALIB_FN(2, rt, realloc, void*(void*, size_t))
 80a0f80:	b508      	push	{r3, lr}
 80a0f82:	4b02      	ldr	r3, [pc, #8]	; (80a0f8c <realloc+0xc>)
 80a0f84:	681b      	ldr	r3, [r3, #0]
 80a0f86:	689b      	ldr	r3, [r3, #8]
 80a0f88:	9301      	str	r3, [sp, #4]
 80a0f8a:	bd08      	pop	{r3, pc}
 80a0f8c:	080601a0 	.word	0x080601a0

080a0f90 <delay>:
    return (value - fromStart) * (toEnd - toStart) / (fromEnd - fromStart) + toStart;
}

void delay(unsigned long ms)
{
    system_delay_ms(ms, false);
 80a0f90:	2100      	movs	r1, #0
 80a0f92:	f7ff bfb9 	b.w	80a0f08 <system_delay_ms>

080a0f96 <_ZNSt14_Function_baseD1Ev>:
	}
      };

    _Function_base() : _M_manager(nullptr) { }

    ~_Function_base()
 80a0f96:	b510      	push	{r4, lr}
    {
      if (_M_manager)
 80a0f98:	6883      	ldr	r3, [r0, #8]
	}
      };

    _Function_base() : _M_manager(nullptr) { }

    ~_Function_base()
 80a0f9a:	4604      	mov	r4, r0
    {
      if (_M_manager)
 80a0f9c:	b113      	cbz	r3, 80a0fa4 <_ZNSt14_Function_baseD1Ev+0xe>
	_M_manager(_M_functor, _M_functor, __destroy_functor);
 80a0f9e:	2203      	movs	r2, #3
 80a0fa0:	4601      	mov	r1, r0
 80a0fa2:	4798      	blx	r3
    }
 80a0fa4:	4620      	mov	r0, r4
 80a0fa6:	bd10      	pop	{r4, pc}

080a0fa8 <_ZN7TwoWireD1Ev>:
private:
  HAL_I2C_Interface _i2c;

public:
  TwoWire(HAL_I2C_Interface i2c);
  virtual ~TwoWire() {};
 80a0fa8:	4770      	bx	lr

080a0faa <_ZN7TwoWire5writeEPKhj>:

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
 80a0faa:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a0fac:	4606      	mov	r6, r0
 80a0fae:	4615      	mov	r5, r2
 80a0fb0:	460c      	mov	r4, r1
 80a0fb2:	188f      	adds	r7, r1, r2
  // in master/slave transmitter mode
  for(size_t i = 0; i < quantity; ++i)
 80a0fb4:	42bc      	cmp	r4, r7
 80a0fb6:	d006      	beq.n	80a0fc6 <_ZN7TwoWire5writeEPKhj+0x1c>
  {
    write(data[i]);
 80a0fb8:	6833      	ldr	r3, [r6, #0]
 80a0fba:	f814 1b01 	ldrb.w	r1, [r4], #1
 80a0fbe:	689b      	ldr	r3, [r3, #8]
 80a0fc0:	4630      	mov	r0, r6
 80a0fc2:	4798      	blx	r3
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
  // in master/slave transmitter mode
  for(size_t i = 0; i < quantity; ++i)
 80a0fc4:	e7f6      	b.n	80a0fb4 <_ZN7TwoWire5writeEPKhj+0xa>
  {
    write(data[i]);
  }

  return quantity;
}
 80a0fc6:	4628      	mov	r0, r5
 80a0fc8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a0fca <_ZN7TwoWire5writeEh>:
// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(uint8_t data)
{
  return HAL_I2C_Write_Data(_i2c, data, NULL);
 80a0fca:	2200      	movs	r2, #0
 80a0fcc:	7c00      	ldrb	r0, [r0, #16]
 80a0fce:	f7ff bea1 	b.w	80a0d14 <HAL_I2C_Write_Data>

080a0fd2 <_ZN7TwoWire9availableEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::available(void)
{
  return HAL_I2C_Available_Data(_i2c, NULL);
 80a0fd2:	2100      	movs	r1, #0
 80a0fd4:	7c00      	ldrb	r0, [r0, #16]
 80a0fd6:	f7ff bea5 	b.w	80a0d24 <HAL_I2C_Available_Data>

080a0fda <_ZN7TwoWire4readEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::read(void)
{
  return HAL_I2C_Read_Data(_i2c, NULL);
 80a0fda:	2100      	movs	r1, #0
 80a0fdc:	7c00      	ldrb	r0, [r0, #16]
 80a0fde:	f7ff bea9 	b.w	80a0d34 <HAL_I2C_Read_Data>

080a0fe2 <_ZN7TwoWire4peekEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::peek(void)
{
  return HAL_I2C_Peek_Data(_i2c, NULL);
 80a0fe2:	2100      	movs	r1, #0
 80a0fe4:	7c00      	ldrb	r0, [r0, #16]
 80a0fe6:	f7ff bead 	b.w	80a0d44 <HAL_I2C_Peek_Data>

080a0fea <_ZN7TwoWire5flushEv>:
}

void TwoWire::flush(void)
{
  HAL_I2C_Flush_Data(_i2c, NULL);
 80a0fea:	2100      	movs	r1, #0
 80a0fec:	7c00      	ldrb	r0, [r0, #16]
 80a0fee:	f7ff beb1 	b.w	80a0d54 <HAL_I2C_Flush_Data>

080a0ff2 <_ZN7TwoWireD0Ev>:
 80a0ff2:	b510      	push	{r4, lr}
 80a0ff4:	4604      	mov	r4, r0
 80a0ff6:	f7ff f850 	bl	80a009a <_ZdlPv>
 80a0ffa:	4620      	mov	r0, r4
 80a0ffc:	bd10      	pop	{r4, pc}
	...

080a1000 <_ZN7TwoWireC1E17HAL_I2C_Interface>:
#include "i2c_hal.h"
#include "spark_wiring_thread.h"

// Constructors ////////////////////////////////////////////////////////////////

TwoWire::TwoWire(HAL_I2C_Interface i2c)
 80a1000:	b510      	push	{r4, lr}
 80a1002:	4604      	mov	r4, r0
 80a1004:	4608      	mov	r0, r1
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {_timeout=1000;}
 80a1006:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80a100a:	60a3      	str	r3, [r4, #8]
 80a100c:	4b04      	ldr	r3, [pc, #16]	; (80a1020 <_ZN7TwoWireC1E17HAL_I2C_Interface+0x20>)
  protected:
    void setWriteError(int err = 1) { write_error = err; }
    size_t printf_impl(bool newline, const char* format, ...);

  public:
    Print() : write_error(0) {}
 80a100e:	2100      	movs	r1, #0
{
  _i2c = i2c;
 80a1010:	7420      	strb	r0, [r4, #16]
 80a1012:	6061      	str	r1, [r4, #4]
#include "i2c_hal.h"
#include "spark_wiring_thread.h"

// Constructors ////////////////////////////////////////////////////////////////

TwoWire::TwoWire(HAL_I2C_Interface i2c)
 80a1014:	6023      	str	r3, [r4, #0]
{
  _i2c = i2c;
  HAL_I2C_Init(_i2c, NULL);
 80a1016:	f7ff fead 	bl	80a0d74 <HAL_I2C_Init>

}
 80a101a:	4620      	mov	r0, r4
 80a101c:	bd10      	pop	{r4, pc}
 80a101e:	bf00      	nop
 80a1020:	080a21e8 	.word	0x080a21e8

080a1024 <_ZN7TwoWire5beginEv>:
  HAL_I2C_Stretch_Clock(_i2c, stretch, NULL);
}

void TwoWire::begin(void)
{
	HAL_I2C_Begin(_i2c, I2C_MODE_MASTER, 0x00, NULL);
 80a1024:	2300      	movs	r3, #0
 80a1026:	461a      	mov	r2, r3
 80a1028:	4619      	mov	r1, r3
 80a102a:	7c00      	ldrb	r0, [r0, #16]
 80a102c:	f7ff be5a 	b.w	80a0ce4 <HAL_I2C_Begin>

080a1030 <_ZN7TwoWire17beginTransmissionEh>:
  return requestFrom((uint8_t)address, (uint8_t)quantity, (uint8_t)sendStop);
}

void TwoWire::beginTransmission(uint8_t address)
{
	HAL_I2C_Begin_Transmission(_i2c, address, NULL);
 80a1030:	2200      	movs	r2, #0
 80a1032:	7c00      	ldrb	r0, [r0, #16]
 80a1034:	f7ff be5e 	b.w	80a0cf4 <HAL_I2C_Begin_Transmission>

080a1038 <_ZN7TwoWire17beginTransmissionEi>:
}

void TwoWire::beginTransmission(int address)
{
  beginTransmission((uint8_t)address);
 80a1038:	b2c9      	uxtb	r1, r1
 80a103a:	f7ff bff9 	b.w	80a1030 <_ZN7TwoWire17beginTransmissionEh>

080a103e <_ZN7TwoWire15endTransmissionEh>:
//	no call to endTransmission(true) is made. Some I2C
//	devices will behave oddly if they do not see a STOP.
//
uint8_t TwoWire::endTransmission(uint8_t sendStop)
{
	return HAL_I2C_End_Transmission(_i2c, sendStop, NULL);
 80a103e:	2200      	movs	r2, #0
 80a1040:	7c00      	ldrb	r0, [r0, #16]
 80a1042:	f7ff be5f 	b.w	80a0d04 <HAL_I2C_End_Transmission>

080a1046 <_ZN7TwoWire15endTransmissionEv>:
//	This provides backwards compatibility with the original
//	definition, and expected behaviour, of endTransmission
//
uint8_t TwoWire::endTransmission(void)
{
  return endTransmission(true);
 80a1046:	2101      	movs	r1, #1
 80a1048:	f7ff bff9 	b.w	80a103e <_ZN7TwoWire15endTransmissionEh>

080a104c <_ZN7TwoWire9isEnabledEv>:
  HAL_I2C_Set_Callback_On_Request(_i2c, function, NULL);
}

bool TwoWire::isEnabled()
{
  return HAL_I2C_Is_Enabled(_i2c, NULL);
 80a104c:	2100      	movs	r1, #0
 80a104e:	7c00      	ldrb	r0, [r0, #16]
 80a1050:	f7ff be88 	b.w	80a0d64 <HAL_I2C_Is_Enabled>

080a1054 <_ZN9IPAddressD1Ev>:
    IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet);
    IPAddress(uint32_t address);
    IPAddress(const uint8_t* address);
    IPAddress(const HAL_IPAddress& address);

    virtual ~IPAddress() {}
 80a1054:	4770      	bx	lr

080a1056 <_ZN9IPAddressD0Ev>:
 80a1056:	b510      	push	{r4, lr}
 80a1058:	4604      	mov	r4, r0
 80a105a:	f7ff f81e 	bl	80a009a <_ZdlPv>
 80a105e:	4620      	mov	r0, r4
 80a1060:	bd10      	pop	{r4, pc}

080a1062 <_ZNK9IPAddress7printToER5Print>:
#endif
	return address.ipv4==that.address.ipv4;
}

size_t IPAddress::printTo(Print& p) const
{
 80a1062:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a1064:	460f      	mov	r7, r1
 80a1066:	f100 0608 	add.w	r6, r0, #8
 80a106a:	1d05      	adds	r5, r0, #4
 80a106c:	2400      	movs	r4, #0
    size_t n = 0;
    for (int i = 0; i < 4; i++)
    {
        if (n)
            n += p.print('.');
        n += p.print((*this)[i], DEC);
 80a106e:	f816 1d01 	ldrb.w	r1, [r6, #-1]!
 80a1072:	220a      	movs	r2, #10
 80a1074:	4638      	mov	r0, r7
 80a1076:	f000 f886 	bl	80a1186 <_ZN5Print5printEhi>
}

size_t IPAddress::printTo(Print& p) const
{
    size_t n = 0;
    for (int i = 0; i < 4; i++)
 80a107a:	42ae      	cmp	r6, r5
    {
        if (n)
            n += p.print('.');
        n += p.print((*this)[i], DEC);
 80a107c:	4404      	add	r4, r0
}

size_t IPAddress::printTo(Print& p) const
{
    size_t n = 0;
    for (int i = 0; i < 4; i++)
 80a107e:	d007      	beq.n	80a1090 <_ZNK9IPAddress7printToER5Print+0x2e>
    {
        if (n)
 80a1080:	2c00      	cmp	r4, #0
 80a1082:	d0f4      	beq.n	80a106e <_ZNK9IPAddress7printToER5Print+0xc>
            n += p.print('.');
 80a1084:	212e      	movs	r1, #46	; 0x2e
 80a1086:	4638      	mov	r0, r7
 80a1088:	f000 f850 	bl	80a112c <_ZN5Print5printEc>
 80a108c:	4404      	add	r4, r0
 80a108e:	e7ee      	b.n	80a106e <_ZNK9IPAddress7printToER5Print+0xc>
        n += p.print((*this)[i], DEC);
    }
    return n;
}
 80a1090:	4620      	mov	r0, r4
 80a1092:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a1094 <_ZN9IPAddress8set_ipv4Ehhhh>:
    return address.ipv4!=0;
#endif
}

void IPAddress::set_ipv4(uint8_t b0, uint8_t b1, uint8_t b2, uint8_t b3)
{
 80a1094:	b510      	push	{r4, lr}
    address.ipv4 = b0<<24 | b1 << 16 | b2 << 8 | b3;
 80a1096:	f89d 4008 	ldrb.w	r4, [sp, #8]
 80a109a:	ea44 2303 	orr.w	r3, r4, r3, lsl #8
 80a109e:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
 80a10a2:	ea42 6101 	orr.w	r1, r2, r1, lsl #24
        return &address;
    }

    inline void setVersion(uint8_t version) {
#if HAL_IPv6
        address.v = version;
 80a10a6:	2304      	movs	r3, #4
 80a10a8:	6041      	str	r1, [r0, #4]
 80a10aa:	7503      	strb	r3, [r0, #20]
 80a10ac:	bd10      	pop	{r4, pc}
	...

080a10b0 <_ZN9IPAddressC1Ehhhh>:
{
    memcpy(&this->address, &address, sizeof(address));
}


IPAddress::IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet)
 80a10b0:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a10b2:	4d04      	ldr	r5, [pc, #16]	; (80a10c4 <_ZN9IPAddressC1Ehhhh+0x14>)
 80a10b4:	6005      	str	r5, [r0, #0]
{
    set_ipv4(first_octet, second_octet, third_octet, fourth_octet);
 80a10b6:	f89d 5018 	ldrb.w	r5, [sp, #24]
 80a10ba:	9500      	str	r5, [sp, #0]
 80a10bc:	f7ff ffea 	bl	80a1094 <_ZN9IPAddress8set_ipv4Ehhhh>
}
 80a10c0:	b003      	add	sp, #12
 80a10c2:	bd30      	pop	{r4, r5, pc}
 80a10c4:	080a2210 	.word	0x080a2210

080a10c8 <_GLOBAL__sub_I__ZN5spark3LogE>:
    // This handler doesn't support direct logging
}

// spark::Logger
inline spark::Logger::Logger(const char *name) :
        name_(name) {
 80a10c8:	4a01      	ldr	r2, [pc, #4]	; (80a10d0 <_GLOBAL__sub_I__ZN5spark3LogE+0x8>)
 80a10ca:	4b02      	ldr	r3, [pc, #8]	; (80a10d4 <_GLOBAL__sub_I__ZN5spark3LogE+0xc>)
 80a10cc:	601a      	str	r2, [r3, #0]
 80a10ce:	4770      	bx	lr
 80a10d0:	080a22d7 	.word	0x080a22d7
 80a10d4:	200007b8 	.word	0x200007b8

080a10d8 <_ZN5Print5writeEPKhj>:

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
 80a10d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a10da:	4606      	mov	r6, r0
 80a10dc:	460d      	mov	r5, r1
 80a10de:	188f      	adds	r7, r1, r2
  size_t n = 0;
 80a10e0:	2400      	movs	r4, #0
  while (size--) {
 80a10e2:	42bd      	cmp	r5, r7
 80a10e4:	d00c      	beq.n	80a1100 <_ZN5Print5writeEPKhj+0x28>
     int chunk = write(*buffer++);
 80a10e6:	6833      	ldr	r3, [r6, #0]
 80a10e8:	f815 1b01 	ldrb.w	r1, [r5], #1
 80a10ec:	689b      	ldr	r3, [r3, #8]
 80a10ee:	4630      	mov	r0, r6
 80a10f0:	4798      	blx	r3
     if (chunk>=0)
 80a10f2:	2800      	cmp	r0, #0
 80a10f4:	db01      	blt.n	80a10fa <_ZN5Print5writeEPKhj+0x22>
         n += chunk;
 80a10f6:	4404      	add	r4, r0

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
  size_t n = 0;
  while (size--) {
 80a10f8:	e7f3      	b.n	80a10e2 <_ZN5Print5writeEPKhj+0xa>
     int chunk = write(*buffer++);
 80a10fa:	2c00      	cmp	r4, #0
 80a10fc:	bf08      	it	eq
 80a10fe:	4604      	moveq	r4, r0
             n = chunk;
         break;
     }
  }
  return n;
}
 80a1100:	4620      	mov	r0, r4
 80a1102:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a1104 <_ZN5Print5writeEPKc>:

    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
 80a1104:	b570      	push	{r4, r5, r6, lr}
 80a1106:	4605      	mov	r5, r0
      if (str == NULL) return 0;
 80a1108:	460c      	mov	r4, r1
      return write((const uint8_t *)str, strlen(str));
    }
 80a110a:	4608      	mov	r0, r1
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
 80a110c:	b149      	cbz	r1, 80a1122 <_ZN5Print5writeEPKc+0x1e>
      return write((const uint8_t *)str, strlen(str));
 80a110e:	f000 fd97 	bl	80a1c40 <strlen>
 80a1112:	682b      	ldr	r3, [r5, #0]
 80a1114:	4602      	mov	r2, r0
 80a1116:	4621      	mov	r1, r4
 80a1118:	4628      	mov	r0, r5
    }
 80a111a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
      return write((const uint8_t *)str, strlen(str));
 80a111e:	68db      	ldr	r3, [r3, #12]
 80a1120:	4718      	bx	r3
    }
 80a1122:	bd70      	pop	{r4, r5, r6, pc}

080a1124 <_ZN5Print5printEPKc>:
 80a1124:	b508      	push	{r3, lr}
 80a1126:	f7ff ffed 	bl	80a1104 <_ZN5Print5writeEPKc>
 80a112a:	bd08      	pop	{r3, pc}

080a112c <_ZN5Print5printEc>:
  return write(str);
}

size_t Print::print(char c)
{
  return write(c);
 80a112c:	6803      	ldr	r3, [r0, #0]
 80a112e:	689b      	ldr	r3, [r3, #8]
 80a1130:	4718      	bx	r3

080a1132 <_ZN5Print11printNumberEmh>:
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;
 80a1132:	2a01      	cmp	r2, #1
 80a1134:	bf98      	it	ls
 80a1136:	220a      	movls	r2, #10
  return println(reinterpret_cast<const char*>(str));
}

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base) {
 80a1138:	b530      	push	{r4, r5, lr}
 80a113a:	460b      	mov	r3, r1
 80a113c:	b08b      	sub	sp, #44	; 0x2c
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
 80a113e:	2100      	movs	r1, #0
 80a1140:	f88d 1024 	strb.w	r1, [sp, #36]	; 0x24
 80a1144:	f10d 0423 	add.w	r4, sp, #35	; 0x23
  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
    unsigned long m = n;
    n /= base;
 80a1148:	fbb3 f5f2 	udiv	r5, r3, r2
    char c = m - base * n;
 80a114c:	fb05 3312 	mls	r3, r5, r2, r3
 80a1150:	b2db      	uxtb	r3, r3
    *--str = c < 10 ? c + '0' : c + 'A' - 10;
 80a1152:	2b09      	cmp	r3, #9
 80a1154:	bf94      	ite	ls
 80a1156:	3330      	addls	r3, #48	; 0x30
 80a1158:	3337      	addhi	r3, #55	; 0x37
 80a115a:	b2db      	uxtb	r3, r3
 80a115c:	4621      	mov	r1, r4
 80a115e:	f804 3901 	strb.w	r3, [r4], #-1
 80a1162:	462b      	mov	r3, r5
  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
 80a1164:	2d00      	cmp	r5, #0
 80a1166:	d1ef      	bne.n	80a1148 <_ZN5Print11printNumberEmh+0x16>
    n /= base;
    char c = m - base * n;
    *--str = c < 10 ? c + '0' : c + 'A' - 10;
  } while(n);

  return write(str);
 80a1168:	f7ff ffcc 	bl	80a1104 <_ZN5Print5writeEPKc>
}
 80a116c:	b00b      	add	sp, #44	; 0x2c
 80a116e:	bd30      	pop	{r4, r5, pc}

080a1170 <_ZN5Print5printEmi>:
    return printNumber(n, base);
  }
}

size_t Print::print(unsigned long n, int base)
{
 80a1170:	b410      	push	{r4}
  if (base == 0) return write(n);
 80a1172:	b922      	cbnz	r2, 80a117e <_ZN5Print5printEmi+0xe>
 80a1174:	6803      	ldr	r3, [r0, #0]
 80a1176:	b2c9      	uxtb	r1, r1
 80a1178:	689b      	ldr	r3, [r3, #8]
  else return printNumber(n, base);
}
 80a117a:	bc10      	pop	{r4}
  }
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
 80a117c:	4718      	bx	r3
  else return printNumber(n, base);
 80a117e:	b2d2      	uxtb	r2, r2
}
 80a1180:	bc10      	pop	{r4}
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
 80a1182:	f7ff bfd6 	b.w	80a1132 <_ZN5Print11printNumberEmh>

080a1186 <_ZN5Print5printEhi>:
  return write(c);
}

size_t Print::print(unsigned char b, int base)
{
  return print((unsigned long) b, base);
 80a1186:	f7ff bff3 	b.w	80a1170 <_ZN5Print5printEmi>

080a118a <_ZN8RGBClassD1Ev>:
#include "rgbled.h"

typedef void (raw_rgb_change_handler_t)(uint8_t, uint8_t, uint8_t);
typedef std::function<raw_rgb_change_handler_t> wiring_rgb_change_handler_t;

class RGBClass {
 80a118a:	b510      	push	{r4, lr}
 80a118c:	4604      	mov	r4, r0
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
 80a118e:	f7ff ff02 	bl	80a0f96 <_ZNSt14_Function_baseD1Ev>
 80a1192:	4620      	mov	r0, r4
 80a1194:	bd10      	pop	{r4, pc}
	...

080a1198 <_GLOBAL__sub_I_RGB>:
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(nullptr) { }
 80a1198:	4803      	ldr	r0, [pc, #12]	; (80a11a8 <_GLOBAL__sub_I_RGB+0x10>)
 80a119a:	2300      	movs	r3, #0
 80a119c:	6083      	str	r3, [r0, #8]
#include "spark_wiring_rgb.h"
#include "spark_wiring_interrupts.h"

#include "core_hal.h"

RGBClass RGB;
 80a119e:	4a03      	ldr	r2, [pc, #12]	; (80a11ac <_GLOBAL__sub_I_RGB+0x14>)
 80a11a0:	4903      	ldr	r1, [pc, #12]	; (80a11b0 <_GLOBAL__sub_I_RGB+0x18>)
 80a11a2:	f000 bbb5 	b.w	80a1910 <__aeabi_atexit>
 80a11a6:	bf00      	nop
 80a11a8:	200007bc 	.word	0x200007bc
 80a11ac:	20000778 	.word	0x20000778
 80a11b0:	080a118b 	.word	0x080a118b

080a11b4 <_ZN8SPIClassD1Ev>:
  Mutex mutex_;
#endif

public:
  SPIClass(HAL_SPI_Interface spi);
  virtual ~SPIClass() {};
 80a11b4:	4770      	bx	lr

080a11b6 <_ZN8SPIClassD0Ev>:
 80a11b6:	b510      	push	{r4, lr}
 80a11b8:	4604      	mov	r4, r0
 80a11ba:	f7fe ff6e 	bl	80a009a <_ZdlPv>
 80a11be:	4620      	mov	r0, r4
 80a11c0:	bd10      	pop	{r4, pc}
	...

080a11c4 <_ZN8SPIClassC1E17HAL_SPI_Interface>:
  if (!info->enabled || info->default_settings)
    return particle::__SPISettings();
  return particle::__SPISettings(info->clock, info->bit_order, info->data_mode);
}

SPIClass::SPIClass(HAL_SPI_Interface spi)
 80a11c4:	b570      	push	{r4, r5, r6, lr}
 80a11c6:	4604      	mov	r4, r0
 80a11c8:	460e      	mov	r6, r1
 80a11ca:	4b07      	ldr	r3, [pc, #28]	; (80a11e8 <_ZN8SPIClassC1E17HAL_SPI_Interface+0x24>)
    Mutex(os_mutex_t handle) : handle_(handle) {}

    /**
     * Creates a new mutex.
     */
    Mutex() : handle_(nullptr)
 80a11cc:	2500      	movs	r5, #0
 80a11ce:	6003      	str	r3, [r0, #0]
 80a11d0:	f840 5f0c 	str.w	r5, [r0, #12]!
    {
        os_mutex_create(&handle_);
 80a11d4:	f7ff fd3e 	bl	80a0c54 <os_mutex_create>
{
  _spi = spi;
  HAL_SPI_Init(_spi);
 80a11d8:	4630      	mov	r0, r6
  return particle::__SPISettings(info->clock, info->bit_order, info->data_mode);
}

SPIClass::SPIClass(HAL_SPI_Interface spi)
{
  _spi = spi;
 80a11da:	7126      	strb	r6, [r4, #4]
  HAL_SPI_Init(_spi);
 80a11dc:	f7ff fdfc 	bl	80a0dd8 <HAL_SPI_Init>
  dividerReference = SPI_CLK_SYSTEM;     // 0 indicates the system clock
 80a11e0:	60a5      	str	r5, [r4, #8]
}
 80a11e2:	4620      	mov	r0, r4
 80a11e4:	bd70      	pop	{r4, r5, r6, pc}
 80a11e6:	bf00      	nop
 80a11e8:	080a2308 	.word	0x080a2308

080a11ec <_ZN8SPIClass5beginEv>:

void SPIClass::begin()
{
    // todo - fetch default pin from HAL
  HAL_SPI_Begin(_spi, SPI_DEFAULT_SS);
 80a11ec:	f64f 71ff 	movw	r1, #65535	; 0xffff
 80a11f0:	7900      	ldrb	r0, [r0, #4]
 80a11f2:	f7ff bdc9 	b.w	80a0d88 <HAL_SPI_Begin>

080a11f6 <_ZN8SPIClass11setBitOrderEh>:
  HAL_SPI_End(_spi);
}

void SPIClass::setBitOrder(uint8_t bitOrder)
{
  HAL_SPI_Set_Bit_Order(_spi, bitOrder);
 80a11f6:	7900      	ldrb	r0, [r0, #4]
 80a11f8:	f7ff bdce 	b.w	80a0d98 <HAL_SPI_Set_Bit_Order>

080a11fc <_ZN8SPIClass11setDataModeEh>:
}

void SPIClass::setDataMode(uint8_t mode)
{
  HAL_SPI_Set_Data_Mode(_spi, mode);
 80a11fc:	7900      	ldrb	r0, [r0, #4]
 80a11fe:	f7ff bdd3 	b.w	80a0da8 <HAL_SPI_Set_Data_Mode>
	...

080a1204 <_Z17divisorShiftScaleh>:
uint8_t divisorShiftScale(uint8_t divider)
{
    unsigned result = 0;
    for (; result<arraySize(clock_divisors); result++)
    {
        if (clock_divisors[result]==divider)
 80a1204:	4a05      	ldr	r2, [pc, #20]	; (80a121c <_Z17divisorShiftScaleh+0x18>)
    SPI_CLOCK_DIV256
};

uint8_t divisorShiftScale(uint8_t divider)
{
    unsigned result = 0;
 80a1206:	2300      	movs	r3, #0
    for (; result<arraySize(clock_divisors); result++)
    {
        if (clock_divisors[result]==divider)
 80a1208:	5c99      	ldrb	r1, [r3, r2]
 80a120a:	4281      	cmp	r1, r0
 80a120c:	d002      	beq.n	80a1214 <_Z17divisorShiftScaleh+0x10>
};

uint8_t divisorShiftScale(uint8_t divider)
{
    unsigned result = 0;
    for (; result<arraySize(clock_divisors); result++)
 80a120e:	3301      	adds	r3, #1
 80a1210:	2b08      	cmp	r3, #8
 80a1212:	d1f9      	bne.n	80a1208 <_Z17divisorShiftScaleh+0x4>
    {
        if (clock_divisors[result]==divider)
            break;
    }
    return result+1;
 80a1214:	1c58      	adds	r0, r3, #1
}
 80a1216:	b2c0      	uxtb	r0, r0
 80a1218:	4770      	bx	lr
 80a121a:	bf00      	nop
 80a121c:	080a2310 	.word	0x080a2310

080a1220 <_ZN8SPIClass19computeClockDividerEjjRhRj>:

void SPIClass::computeClockDivider(unsigned reference, unsigned targetSpeed, uint8_t& divider, unsigned& clock)
{
    clock = reference;
    uint8_t scale = 0;
    clock >>= 1;        // div2 is the first
 80a1220:	0840      	lsrs	r0, r0, #1
        HAL_SPI_Set_Clock_Divider(_spi, rate);
    }
}

void SPIClass::computeClockDivider(unsigned reference, unsigned targetSpeed, uint8_t& divider, unsigned& clock)
{
 80a1222:	b530      	push	{r4, r5, lr}
    clock = reference;
    uint8_t scale = 0;
    clock >>= 1;        // div2 is the first
 80a1224:	6018      	str	r0, [r3, #0]
 80a1226:	2400      	movs	r4, #0
    while (clock > targetSpeed && scale<7) {
 80a1228:	6818      	ldr	r0, [r3, #0]
 80a122a:	b2e5      	uxtb	r5, r4
 80a122c:	4288      	cmp	r0, r1
 80a122e:	d906      	bls.n	80a123e <_ZN8SPIClass19computeClockDividerEjjRhRj+0x1e>
 80a1230:	3401      	adds	r4, #1
 80a1232:	2c08      	cmp	r4, #8
 80a1234:	d002      	beq.n	80a123c <_ZN8SPIClass19computeClockDividerEjjRhRj+0x1c>
        clock >>= 1;
 80a1236:	0840      	lsrs	r0, r0, #1
 80a1238:	6018      	str	r0, [r3, #0]
void SPIClass::computeClockDivider(unsigned reference, unsigned targetSpeed, uint8_t& divider, unsigned& clock)
{
    clock = reference;
    uint8_t scale = 0;
    clock >>= 1;        // div2 is the first
    while (clock > targetSpeed && scale<7) {
 80a123a:	e7f5      	b.n	80a1228 <_ZN8SPIClass19computeClockDividerEjjRhRj+0x8>
 80a123c:	2507      	movs	r5, #7
        clock >>= 1;
        scale++;
    }
    divider = clock_divisors[scale];
 80a123e:	4b02      	ldr	r3, [pc, #8]	; (80a1248 <_ZN8SPIClass19computeClockDividerEjjRhRj+0x28>)
 80a1240:	5d5b      	ldrb	r3, [r3, r5]
 80a1242:	7013      	strb	r3, [r2, #0]
 80a1244:	bd30      	pop	{r4, r5, pc}
 80a1246:	bf00      	nop
 80a1248:	080a2310 	.word	0x080a2310

080a124c <_ZN8SPIClass13setClockSpeedEjj>:
}

unsigned SPIClass::setClockSpeed(unsigned value, unsigned value_scale)
{
 80a124c:	b570      	push	{r4, r5, r6, lr}
 80a124e:	4604      	mov	r4, r0
    // actual speed is the system clock divided by some scalar
    unsigned targetSpeed = value*value_scale;
 80a1250:	fb02 f501 	mul.w	r5, r2, r1
    }
    divider = clock_divisors[scale];
}

unsigned SPIClass::setClockSpeed(unsigned value, unsigned value_scale)
{
 80a1254:	b088      	sub	sp, #32
    // actual speed is the system clock divided by some scalar
    unsigned targetSpeed = value*value_scale;
    hal_spi_info_t info;
    querySpiInfo(_spi, &info);
 80a1256:	7906      	ldrb	r6, [r0, #4]
#include "core_hal.h"
#include "spark_macros.h"

static void querySpiInfo(HAL_SPI_Interface spi, hal_spi_info_t* info)
{
  memset(info, 0, sizeof(hal_spi_info_t));
 80a1258:	2214      	movs	r2, #20
 80a125a:	2100      	movs	r1, #0
 80a125c:	a803      	add	r0, sp, #12
 80a125e:	f000 fcbe 	bl	80a1bde <memset>
  info->version = HAL_SPI_INFO_VERSION_1;
 80a1262:	230b      	movs	r3, #11
  HAL_SPI_Info(spi, info, nullptr);
 80a1264:	a903      	add	r1, sp, #12
 80a1266:	4630      	mov	r0, r6
 80a1268:	2200      	movs	r2, #0
#include "spark_macros.h"

static void querySpiInfo(HAL_SPI_Interface spi, hal_spi_info_t* info)
{
  memset(info, 0, sizeof(hal_spi_info_t));
  info->version = HAL_SPI_INFO_VERSION_1;
 80a126a:	f8ad 300c 	strh.w	r3, [sp, #12]
  HAL_SPI_Info(spi, info, nullptr);
 80a126e:	f7ff fdc3 	bl	80a0df8 <HAL_SPI_Info>
    unsigned targetSpeed = value*value_scale;
    hal_spi_info_t info;
    querySpiInfo(_spi, &info);
    uint8_t rate;
    unsigned clock;
    computeClockDivider(info.system_clock, targetSpeed, rate, clock);
 80a1272:	ab02      	add	r3, sp, #8
 80a1274:	f10d 0207 	add.w	r2, sp, #7
 80a1278:	4629      	mov	r1, r5
 80a127a:	9804      	ldr	r0, [sp, #16]
 80a127c:	f7ff ffd0 	bl	80a1220 <_ZN8SPIClass19computeClockDividerEjjRhRj>
    HAL_SPI_Set_Clock_Divider(_spi, rate);
 80a1280:	7920      	ldrb	r0, [r4, #4]
 80a1282:	f89d 1007 	ldrb.w	r1, [sp, #7]
 80a1286:	f7ff fd97 	bl	80a0db8 <HAL_SPI_Set_Clock_Divider>
    return clock;
}
 80a128a:	9802      	ldr	r0, [sp, #8]
 80a128c:	b008      	add	sp, #32
 80a128e:	bd70      	pop	{r4, r5, r6, pc}

080a1290 <_ZN8SPIClass15setClockDividerEh>:
    }
    return result+1;
}

void SPIClass::setClockDivider(uint8_t rate)
{
 80a1290:	b538      	push	{r3, r4, r5, lr}
 80a1292:	4604      	mov	r4, r0
    if (dividerReference)
 80a1294:	68a5      	ldr	r5, [r4, #8]
    }
    return result+1;
}

void SPIClass::setClockDivider(uint8_t rate)
{
 80a1296:	4608      	mov	r0, r1
    if (dividerReference)
 80a1298:	b14d      	cbz	r5, 80a12ae <_ZN8SPIClass15setClockDividerEh+0x1e>
    {
        // determine the clock speed
        uint8_t scale = divisorShiftScale(rate);
 80a129a:	f7ff ffb3 	bl	80a1204 <_Z17divisorShiftScaleh>
        unsigned targetSpeed = dividerReference>>scale;
        setClockSpeed(targetSpeed);
 80a129e:	2201      	movs	r2, #1
 80a12a0:	fa25 f100 	lsr.w	r1, r5, r0
 80a12a4:	4620      	mov	r0, r4
    }
    else
    {
        HAL_SPI_Set_Clock_Divider(_spi, rate);
    }
}
 80a12a6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    if (dividerReference)
    {
        // determine the clock speed
        uint8_t scale = divisorShiftScale(rate);
        unsigned targetSpeed = dividerReference>>scale;
        setClockSpeed(targetSpeed);
 80a12aa:	f7ff bfcf 	b.w	80a124c <_ZN8SPIClass13setClockSpeedEjj>
    }
    else
    {
        HAL_SPI_Set_Clock_Divider(_spi, rate);
 80a12ae:	7920      	ldrb	r0, [r4, #4]
    }
}
 80a12b0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        unsigned targetSpeed = dividerReference>>scale;
        setClockSpeed(targetSpeed);
    }
    else
    {
        HAL_SPI_Set_Clock_Divider(_spi, rate);
 80a12b4:	f7ff bd80 	b.w	80a0db8 <HAL_SPI_Set_Clock_Divider>

080a12b8 <_ZN8SPIClass8transferEh>:
    HAL_SPI_Set_Clock_Divider(_spi, rate);
    return clock;
}

byte SPIClass::transfer(byte _data)
{
 80a12b8:	b508      	push	{r3, lr}
  return HAL_SPI_Send_Receive_Data(_spi, _data);
 80a12ba:	7900      	ldrb	r0, [r0, #4]
 80a12bc:	f7ff fd84 	bl	80a0dc8 <HAL_SPI_Send_Receive_Data>
}
 80a12c0:	b2c0      	uxtb	r0, r0
 80a12c2:	bd08      	pop	{r3, pc}

080a12c4 <_ZN8SPIClass9isEnabledEv>:
  //To Do
}

bool SPIClass::isEnabled()
{
  return HAL_SPI_Is_Enabled(_spi);
 80a12c4:	7900      	ldrb	r0, [r0, #4]
 80a12c6:	f7ff bd8f 	b.w	80a0de8 <HAL_SPI_Is_Enabled>

080a12ca <_ZN6StringD1Ev>:
	init();
	char buf[33];
	dtoa(value, decimalPlaces, buf);
        *this = buf;
}
String::~String()
 80a12ca:	b510      	push	{r4, lr}
 80a12cc:	4604      	mov	r4, r0
{
	free(buffer);
 80a12ce:	6800      	ldr	r0, [r0, #0]
 80a12d0:	f7ff fe4e 	bl	80a0f70 <free>
}
 80a12d4:	4620      	mov	r0, r4
 80a12d6:	bd10      	pop	{r4, pc}

080a12d8 <_ZN6String10invalidateEv>:
	len = 0;
	flags = 0;
}

void String::invalidate(void)
{
 80a12d8:	b510      	push	{r4, lr}
 80a12da:	4604      	mov	r4, r0
	if (buffer) free(buffer);
 80a12dc:	6800      	ldr	r0, [r0, #0]
 80a12de:	b108      	cbz	r0, 80a12e4 <_ZN6String10invalidateEv+0xc>
 80a12e0:	f7ff fe46 	bl	80a0f70 <free>
	buffer = NULL;
 80a12e4:	2300      	movs	r3, #0
 80a12e6:	6023      	str	r3, [r4, #0]
	capacity = len = 0;
 80a12e8:	60a3      	str	r3, [r4, #8]
 80a12ea:	6063      	str	r3, [r4, #4]
 80a12ec:	bd10      	pop	{r4, pc}

080a12ee <_ZN6String12changeBufferEj>:
	}
	return 0;
}

unsigned char String::changeBuffer(unsigned int maxStrLen)
{
 80a12ee:	b538      	push	{r3, r4, r5, lr}
 80a12f0:	4604      	mov	r4, r0
 80a12f2:	460d      	mov	r5, r1
	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
 80a12f4:	6800      	ldr	r0, [r0, #0]
 80a12f6:	3101      	adds	r1, #1
 80a12f8:	f7ff fe42 	bl	80a0f80 <realloc>
	if (newbuffer) {
 80a12fc:	b110      	cbz	r0, 80a1304 <_ZN6String12changeBufferEj+0x16>
		buffer = newbuffer;
		capacity = maxStrLen;
 80a12fe:	e884 0021 	stmia.w	r4, {r0, r5}
		return 1;
 80a1302:	2001      	movs	r0, #1
	}
	return 0;
}
 80a1304:	bd38      	pop	{r3, r4, r5, pc}

080a1306 <_ZN6String7reserveEj>:
	buffer = NULL;
	capacity = len = 0;
}

unsigned char String::reserve(unsigned int size)
{
 80a1306:	b510      	push	{r4, lr}
	if (buffer && capacity >= size) return 1;
 80a1308:	6803      	ldr	r3, [r0, #0]
	buffer = NULL;
	capacity = len = 0;
}

unsigned char String::reserve(unsigned int size)
{
 80a130a:	4604      	mov	r4, r0
	if (buffer && capacity >= size) return 1;
 80a130c:	b113      	cbz	r3, 80a1314 <_ZN6String7reserveEj+0xe>
 80a130e:	6843      	ldr	r3, [r0, #4]
 80a1310:	428b      	cmp	r3, r1
 80a1312:	d207      	bcs.n	80a1324 <_ZN6String7reserveEj+0x1e>
	if (changeBuffer(size)) {
 80a1314:	4620      	mov	r0, r4
 80a1316:	f7ff ffea 	bl	80a12ee <_ZN6String12changeBufferEj>
 80a131a:	b120      	cbz	r0, 80a1326 <_ZN6String7reserveEj+0x20>
		if (len == 0) buffer[0] = 0;
 80a131c:	68a3      	ldr	r3, [r4, #8]
 80a131e:	b90b      	cbnz	r3, 80a1324 <_ZN6String7reserveEj+0x1e>
 80a1320:	6822      	ldr	r2, [r4, #0]
 80a1322:	7013      	strb	r3, [r2, #0]
 80a1324:	2001      	movs	r0, #1
		return 1;
	}
	return 0;
}
 80a1326:	bd10      	pop	{r4, pc}

080a1328 <_ZN6String4copyEPKcj>:
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
 80a1328:	b570      	push	{r4, r5, r6, lr}
 80a132a:	460e      	mov	r6, r1
	if (!reserve(length)) {
 80a132c:	4611      	mov	r1, r2
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
 80a132e:	4604      	mov	r4, r0
 80a1330:	4615      	mov	r5, r2
	if (!reserve(length)) {
 80a1332:	f7ff ffe8 	bl	80a1306 <_ZN6String7reserveEj>
 80a1336:	b918      	cbnz	r0, 80a1340 <_ZN6String4copyEPKcj+0x18>
		invalidate();
 80a1338:	4620      	mov	r0, r4
 80a133a:	f7ff ffcd 	bl	80a12d8 <_ZN6String10invalidateEv>
		return *this;
 80a133e:	e009      	b.n	80a1354 <_ZN6String4copyEPKcj+0x2c>
	}
	len = length;
	memcpy(buffer, cstr, length);
 80a1340:	462a      	mov	r2, r5
 80a1342:	4631      	mov	r1, r6
{
	if (!reserve(length)) {
		invalidate();
		return *this;
	}
	len = length;
 80a1344:	60a5      	str	r5, [r4, #8]
	memcpy(buffer, cstr, length);
 80a1346:	6820      	ldr	r0, [r4, #0]
 80a1348:	f000 fc3e 	bl	80a1bc8 <memcpy>
	buffer[len] = 0;
 80a134c:	6822      	ldr	r2, [r4, #0]
 80a134e:	68a3      	ldr	r3, [r4, #8]
 80a1350:	2100      	movs	r1, #0
 80a1352:	54d1      	strb	r1, [r2, r3]
	return *this;
}
 80a1354:	4620      	mov	r0, r4
 80a1356:	bd70      	pop	{r4, r5, r6, pc}

080a1358 <_ZN6StringC1EPK19__FlashStringHelper>:
{
	init();
	*this = value;
}

String::String(const __FlashStringHelper *pstr)
 80a1358:	b538      	push	{r3, r4, r5, lr}
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
 80a135a:	2300      	movs	r3, #0
{
	init();
	*this = value;
}

String::String(const __FlashStringHelper *pstr)
 80a135c:	4604      	mov	r4, r0
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
 80a135e:	6003      	str	r3, [r0, #0]
	capacity = 0;
 80a1360:	6043      	str	r3, [r0, #4]
	len = 0;
 80a1362:	6083      	str	r3, [r0, #8]
	flags = 0;
 80a1364:	7303      	strb	r3, [r0, #12]

String::String(const __FlashStringHelper *pstr)
{
	init();
	const char* cstr = reinterpret_cast<const char*>(pstr);
	if (cstr) copy(cstr, strlen(cstr));
 80a1366:	460d      	mov	r5, r1
 80a1368:	b139      	cbz	r1, 80a137a <_ZN6StringC1EPK19__FlashStringHelper+0x22>
 80a136a:	4608      	mov	r0, r1
 80a136c:	f000 fc68 	bl	80a1c40 <strlen>
 80a1370:	4629      	mov	r1, r5
 80a1372:	4602      	mov	r2, r0
 80a1374:	4620      	mov	r0, r4
 80a1376:	f7ff ffd7 	bl	80a1328 <_ZN6String4copyEPKcj>
}
 80a137a:	4620      	mov	r0, r4
 80a137c:	bd38      	pop	{r3, r4, r5, pc}
	...

080a1380 <_GLOBAL__sub_I_System>:
    WAKEUP_REASON_RTC = 2,
    WAKEUP_REASON_PIN_OR_RTC = 3
};

struct SleepResult {
    SleepResult() {}
 80a1380:	f64f 739c 	movw	r3, #65436	; 0xff9c
    return wokenUpByRtc();
}

system_error_t SleepResult::error() const {
    return err_;
}
 80a1384:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a1386:	4c0d      	ldr	r4, [pc, #52]	; (80a13bc <_GLOBAL__sub_I_System+0x3c>)
 80a1388:	2500      	movs	r5, #0
 80a138a:	8063      	strh	r3, [r4, #2]
 80a138c:	f64f 73ff 	movw	r3, #65535	; 0xffff

class SystemClass {
public:

    SystemClass(System_Mode_TypeDef mode = DEFAULT) {
        set_system_mode(mode);
 80a1390:	4628      	mov	r0, r5
    WAKEUP_REASON_RTC = 2,
    WAKEUP_REASON_PIN_OR_RTC = 3
};

struct SleepResult {
    SleepResult() {}
 80a1392:	80a3      	strh	r3, [r4, #4]
 80a1394:	7025      	strb	r5, [r4, #0]

class SystemClass {
public:

    SystemClass(System_Mode_TypeDef mode = DEFAULT) {
        set_system_mode(mode);
 80a1396:	f7ff fdaf 	bl	80a0ef8 <set_system_mode>
        return get_flag(flag) != 0;
    }

    inline int resetReason() const
    {
        int reason = RESET_REASON_NONE;
 80a139a:	a802      	add	r0, sp, #8
 80a139c:	f840 5d04 	str.w	r5, [r0, #-4]!
        HAL_Core_Get_Last_Reset_Info(&reason, nullptr, nullptr);
 80a13a0:	462a      	mov	r2, r5
 80a13a2:	4629      	mov	r1, r5
 80a13a4:	f7ff fc5e 	bl	80a0c64 <HAL_Core_Get_Last_Reset_Info>
        return reason;
 80a13a8:	9b01      	ldr	r3, [sp, #4]
class SystemClass {
public:

    SystemClass(System_Mode_TypeDef mode = DEFAULT) {
        set_system_mode(mode);
        if (resetReason() == RESET_REASON_POWER_MANAGEMENT) {
 80a13aa:	2b1e      	cmp	r3, #30
 80a13ac:	d104      	bne.n	80a13b8 <_GLOBAL__sub_I_System+0x38>
            // Woken up from standby mode
            sleepResult_ = SleepResult(WAKEUP_REASON_PIN_OR_RTC, SYSTEM_ERROR_NONE, WKP);
 80a13ae:	2303      	movs	r3, #3
 80a13b0:	7023      	strb	r3, [r4, #0]
 80a13b2:	2311      	movs	r3, #17
 80a13b4:	8065      	strh	r5, [r4, #2]
 80a13b6:	80a3      	strh	r3, [r4, #4]
 80a13b8:	b003      	add	sp, #12
 80a13ba:	bd30      	pop	{r4, r5, pc}
 80a13bc:	200007cc 	.word	0x200007cc

080a13c0 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT>:
            calendar_time_cache = Convert_UnixTime_To_CalendarTime(unix_time);
            unix_time_cache = unix_time;
    }
}

const char* TimeClass::format_spec = TIME_FORMAT_DEFAULT;
 80a13c0:	4b02      	ldr	r3, [pc, #8]	; (80a13cc <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0xc>)
 80a13c2:	681a      	ldr	r2, [r3, #0]
 80a13c4:	4b02      	ldr	r3, [pc, #8]	; (80a13d0 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0x10>)
 80a13c6:	601a      	str	r2, [r3, #0]
 80a13c8:	4770      	bx	lr
 80a13ca:	bf00      	nop
 80a13cc:	20000710 	.word	0x20000710
 80a13d0:	200007d4 	.word	0x200007d4

080a13d4 <_ZN11USARTSerialD1Ev>:
private:
  HAL_USART_Serial _serial;
  bool _blocking;
public:
  USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer);
  virtual ~USARTSerial() {};
 80a13d4:	4770      	bx	lr

080a13d6 <_ZN11USARTSerial14blockOnOverrunEb>:
    HAL_USART_Half_Duplex(_serial, Enable);
}

void USARTSerial::blockOnOverrun(bool block)
{
  _blocking = block;
 80a13d6:	7441      	strb	r1, [r0, #17]
 80a13d8:	4770      	bx	lr

080a13da <_ZN11USARTSerial17availableForWriteEv>:
}


int USARTSerial::availableForWrite(void)
{
  return HAL_USART_Available_Data_For_Write(_serial);
 80a13da:	7c00      	ldrb	r0, [r0, #16]
 80a13dc:	f7ff bd4c 	b.w	80a0e78 <HAL_USART_Available_Data_For_Write>

080a13e0 <_ZN11USARTSerial9availableEv>:
}

int USARTSerial::available(void)
{
  return HAL_USART_Available_Data(_serial);
 80a13e0:	7c00      	ldrb	r0, [r0, #16]
 80a13e2:	f7ff bd21 	b.w	80a0e28 <HAL_USART_Available_Data>

080a13e6 <_ZN11USARTSerial4peekEv>:
}

int USARTSerial::peek(void)
{
  return HAL_USART_Peek_Data(_serial);
 80a13e6:	7c00      	ldrb	r0, [r0, #16]
 80a13e8:	f7ff bd2e 	b.w	80a0e48 <HAL_USART_Peek_Data>

080a13ec <_ZN11USARTSerial4readEv>:
}

int USARTSerial::read(void)
{
  return HAL_USART_Read_Data(_serial);
 80a13ec:	7c00      	ldrb	r0, [r0, #16]
 80a13ee:	f7ff bd23 	b.w	80a0e38 <HAL_USART_Read_Data>

080a13f2 <_ZN11USARTSerial5flushEv>:
}

void USARTSerial::flush()
{
  HAL_USART_Flush_Data(_serial);
 80a13f2:	7c00      	ldrb	r0, [r0, #16]
 80a13f4:	f7ff bd30 	b.w	80a0e58 <HAL_USART_Flush_Data>

080a13f8 <_ZN11USARTSerialD0Ev>:
 80a13f8:	b510      	push	{r4, lr}
 80a13fa:	4604      	mov	r4, r0
 80a13fc:	f7fe fe4d 	bl	80a009a <_ZdlPv>
 80a1400:	4620      	mov	r0, r4
 80a1402:	bd10      	pop	{r4, pc}

080a1404 <_ZN11USARTSerial5writeEh>:
}

size_t USARTSerial::write(uint8_t c)
{
 80a1404:	b570      	push	{r4, r5, r6, lr}
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || HAL_USART_Available_Data_For_Write(_serial) > 0) {
 80a1406:	7c45      	ldrb	r5, [r0, #17]
{
  HAL_USART_Flush_Data(_serial);
}

size_t USARTSerial::write(uint8_t c)
{
 80a1408:	4604      	mov	r4, r0
 80a140a:	460e      	mov	r6, r1
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || HAL_USART_Available_Data_For_Write(_serial) > 0) {
 80a140c:	b925      	cbnz	r5, 80a1418 <_ZN11USARTSerial5writeEh+0x14>
 80a140e:	7c00      	ldrb	r0, [r0, #16]
 80a1410:	f7ff fd32 	bl	80a0e78 <HAL_USART_Available_Data_For_Write>
 80a1414:	2800      	cmp	r0, #0
 80a1416:	dd05      	ble.n	80a1424 <_ZN11USARTSerial5writeEh+0x20>
    // the HAL always blocks.
	  return HAL_USART_Write_Data(_serial, c);
 80a1418:	4631      	mov	r1, r6
 80a141a:	7c20      	ldrb	r0, [r4, #16]
  }
  return 0;
}
 80a141c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
size_t USARTSerial::write(uint8_t c)
{
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || HAL_USART_Available_Data_For_Write(_serial) > 0) {
    // the HAL always blocks.
	  return HAL_USART_Write_Data(_serial, c);
 80a1420:	f7ff bcfa 	b.w	80a0e18 <HAL_USART_Write_Data>
  }
  return 0;
}
 80a1424:	4628      	mov	r0, r5
 80a1426:	bd70      	pop	{r4, r5, r6, pc}

080a1428 <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_>:
#include "spark_wiring_constants.h"
#include "module_info.h"

// Constructors ////////////////////////////////////////////////////////////////

USARTSerial::USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer)
 80a1428:	b510      	push	{r4, lr}
 80a142a:	4604      	mov	r4, r0
 80a142c:	4608      	mov	r0, r1
 80a142e:	4611      	mov	r1, r2
  protected:
    void setWriteError(int err = 1) { write_error = err; }
    size_t printf_impl(bool newline, const char* format, ...);

  public:
    Print() : write_error(0) {}
 80a1430:	2200      	movs	r2, #0
 80a1432:	6062      	str	r2, [r4, #4]
 80a1434:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80a1438:	60a2      	str	r2, [r4, #8]
 80a143a:	4a05      	ldr	r2, [pc, #20]	; (80a1450 <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_+0x28>)
{
  _serial = serial;
 80a143c:	7420      	strb	r0, [r4, #16]
#include "spark_wiring_constants.h"
#include "module_info.h"

// Constructors ////////////////////////////////////////////////////////////////

USARTSerial::USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer)
 80a143e:	6022      	str	r2, [r4, #0]
{
  _serial = serial;
  // Default is blocking mode
  _blocking = true;
 80a1440:	2201      	movs	r2, #1
 80a1442:	7462      	strb	r2, [r4, #17]
  HAL_USART_Init(serial, rx_buffer, tx_buffer);
 80a1444:	461a      	mov	r2, r3
 80a1446:	f7ff fcdf 	bl	80a0e08 <HAL_USART_Init>
}
 80a144a:	4620      	mov	r0, r4
 80a144c:	bd10      	pop	{r4, pc}
 80a144e:	bf00      	nop
 80a1450:	080a234c 	.word	0x080a234c

080a1454 <_ZN11USARTSerial9isEnabledEv>:
USARTSerial::operator bool() {
  return true;
}

bool USARTSerial::isEnabled() {
  return HAL_USART_Is_Enabled(_serial);
 80a1454:	7c00      	ldrb	r0, [r0, #16]
 80a1456:	f7ff bd07 	b.w	80a0e68 <HAL_USART_Is_Enabled>
	...

080a145c <_Z22__fetch_global_Serial1v>:
static Ring_Buffer* serial1_rx_buffer = NULL;
static Ring_Buffer* serial1_tx_buffer = NULL;
#endif

USARTSerial& __fetch_global_Serial1()
{
 80a145c:	b538      	push	{r3, r4, r5, lr}
#if ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
	static USARTSerial serial1(HAL_USART_SERIAL1, &serial1_rx_buffer, &serial1_tx_buffer);
 80a145e:	4d0c      	ldr	r5, [pc, #48]	; (80a1490 <_Z22__fetch_global_Serial1v+0x34>)
 80a1460:	6829      	ldr	r1, [r5, #0]
 80a1462:	f011 0401 	ands.w	r4, r1, #1
 80a1466:	d111      	bne.n	80a148c <_Z22__fetch_global_Serial1v+0x30>
 80a1468:	4628      	mov	r0, r5
 80a146a:	f7fe fe23 	bl	80a00b4 <__cxa_guard_acquire>
 80a146e:	b168      	cbz	r0, 80a148c <_Z22__fetch_global_Serial1v+0x30>
 80a1470:	4a08      	ldr	r2, [pc, #32]	; (80a1494 <_Z22__fetch_global_Serial1v+0x38>)
 80a1472:	4621      	mov	r1, r4
 80a1474:	4b08      	ldr	r3, [pc, #32]	; (80a1498 <_Z22__fetch_global_Serial1v+0x3c>)
 80a1476:	4809      	ldr	r0, [pc, #36]	; (80a149c <_Z22__fetch_global_Serial1v+0x40>)
 80a1478:	f7ff ffd6 	bl	80a1428 <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_>
 80a147c:	4628      	mov	r0, r5
 80a147e:	f7fe fe1e 	bl	80a00be <__cxa_guard_release>
 80a1482:	4a07      	ldr	r2, [pc, #28]	; (80a14a0 <_Z22__fetch_global_Serial1v+0x44>)
 80a1484:	4907      	ldr	r1, [pc, #28]	; (80a14a4 <_Z22__fetch_global_Serial1v+0x48>)
 80a1486:	4805      	ldr	r0, [pc, #20]	; (80a149c <_Z22__fetch_global_Serial1v+0x40>)
 80a1488:	f000 fa42 	bl	80a1910 <__aeabi_atexit>
    serial1_tx_buffer = new Ring_Buffer();
  }
  static USARTSerial serial1(HAL_USART_SERIAL1, serial1_rx_buffer, serial1_tx_buffer);
#endif
	return serial1;
}
 80a148c:	4803      	ldr	r0, [pc, #12]	; (80a149c <_Z22__fetch_global_Serial1v+0x40>)
 80a148e:	bd38      	pop	{r3, r4, r5, pc}
 80a1490:	20000870 	.word	0x20000870
 80a1494:	20000874 	.word	0x20000874
 80a1498:	200007ec 	.word	0x200007ec
 80a149c:	200007d8 	.word	0x200007d8
 80a14a0:	20000778 	.word	0x20000778
 80a14a4:	080a13d5 	.word	0x080a13d5

080a14a8 <_ZN9USBSerial14blockOnOverrunEb>:
  HAL_USB_USART_Flush_Data(_serial);
}

void USBSerial::blockOnOverrun(bool block)
{
  _blocking = block;
 80a14a8:	7441      	strb	r1, [r0, #17]
 80a14aa:	4770      	bx	lr

080a14ac <_ZN9USBSerialD1Ev>:
#include "spark_wiring_platform.h"
#include "usb_hal.h"
#include "system_task.h"
#include "spark_wiring_startup.h"

class USBSerial : public Stream
 80a14ac:	4770      	bx	lr

080a14ae <_ZN9USBSerial4readEv>:


// Read data from buffer
int USBSerial::read()
{
	return HAL_USB_USART_Receive_Data(_serial, false);
 80a14ae:	2100      	movs	r1, #0
 80a14b0:	7c00      	ldrb	r0, [r0, #16]
 80a14b2:	f7ff bd01 	b.w	80a0eb8 <HAL_USB_USART_Receive_Data>

080a14b6 <_ZN9USBSerial4peekEv>:
  _blocking = block;
}

int USBSerial::peek()
{
	return HAL_USB_USART_Receive_Data(_serial, true);
 80a14b6:	2101      	movs	r1, #1
 80a14b8:	7c00      	ldrb	r0, [r0, #16]
 80a14ba:	f7ff bcfd 	b.w	80a0eb8 <HAL_USB_USART_Receive_Data>

080a14be <_ZN9USBSerial17availableForWriteEv>:
	return HAL_USB_USART_Receive_Data(_serial, false);
}

int USBSerial::availableForWrite()
{
  return HAL_USB_USART_Available_Data_For_Write(_serial);
 80a14be:	7c00      	ldrb	r0, [r0, #16]
 80a14c0:	f7ff bcf2 	b.w	80a0ea8 <HAL_USB_USART_Available_Data_For_Write>

080a14c4 <_ZN9USBSerial9availableEv>:
}

int USBSerial::available()
{
	return HAL_USB_USART_Available_Data(_serial);
 80a14c4:	7c00      	ldrb	r0, [r0, #16]
 80a14c6:	f7ff bce7 	b.w	80a0e98 <HAL_USB_USART_Available_Data>

080a14ca <_ZN9USBSerial5writeEh>:
}

size_t USBSerial::write(uint8_t byte)
{
 80a14ca:	b538      	push	{r3, r4, r5, lr}
 80a14cc:	4604      	mov	r4, r0
  if (HAL_USB_USART_Available_Data_For_Write(_serial) > 0 || _blocking) {
 80a14ce:	7c00      	ldrb	r0, [r0, #16]
{
	return HAL_USB_USART_Available_Data(_serial);
}

size_t USBSerial::write(uint8_t byte)
{
 80a14d0:	460d      	mov	r5, r1
  if (HAL_USB_USART_Available_Data_For_Write(_serial) > 0 || _blocking) {
 80a14d2:	f7ff fce9 	bl	80a0ea8 <HAL_USB_USART_Available_Data_For_Write>
 80a14d6:	2800      	cmp	r0, #0
 80a14d8:	dc01      	bgt.n	80a14de <_ZN9USBSerial5writeEh+0x14>
 80a14da:	7c60      	ldrb	r0, [r4, #17]
 80a14dc:	b120      	cbz	r0, 80a14e8 <_ZN9USBSerial5writeEh+0x1e>
    HAL_USB_USART_Send_Data(_serial, byte);
 80a14de:	4629      	mov	r1, r5
 80a14e0:	7c20      	ldrb	r0, [r4, #16]
 80a14e2:	f7ff fcf1 	bl	80a0ec8 <HAL_USB_USART_Send_Data>
    return 1;
 80a14e6:	2001      	movs	r0, #1
  }
  return 0;
}
 80a14e8:	bd38      	pop	{r3, r4, r5, pc}

080a14ea <_ZN9USBSerial5flushEv>:

void USBSerial::flush()
{
  HAL_USB_USART_Flush_Data(_serial);
 80a14ea:	7c00      	ldrb	r0, [r0, #16]
 80a14ec:	f7ff bcf4 	b.w	80a0ed8 <HAL_USB_USART_Flush_Data>

080a14f0 <_ZN9USBSerialD0Ev>:
 80a14f0:	b510      	push	{r4, lr}
 80a14f2:	4604      	mov	r4, r0
 80a14f4:	f7fe fdd1 	bl	80a009a <_ZdlPv>
 80a14f8:	4620      	mov	r0, r4
 80a14fa:	bd10      	pop	{r4, pc}

080a14fc <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>:

  HAL_USB_USART_Config conf = acquireSerialBuffer();
  HAL_USB_USART_Init(_serial, &conf);
}

USBSerial::USBSerial(HAL_USB_USART_Serial serial, const HAL_USB_USART_Config& conf)
 80a14fc:	b510      	push	{r4, lr}
 80a14fe:	4604      	mov	r4, r0
 80a1500:	2300      	movs	r3, #0
 80a1502:	6063      	str	r3, [r4, #4]
 80a1504:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80a1508:	60a3      	str	r3, [r4, #8]
 80a150a:	4b05      	ldr	r3, [pc, #20]	; (80a1520 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config+0x24>)
 80a150c:	4608      	mov	r0, r1
 80a150e:	6023      	str	r3, [r4, #0]
{
  _serial = serial;
  _blocking = true;
 80a1510:	2301      	movs	r3, #1
  HAL_USB_USART_Init(_serial, &conf);
}

USBSerial::USBSerial(HAL_USB_USART_Serial serial, const HAL_USB_USART_Config& conf)
{
  _serial = serial;
 80a1512:	7421      	strb	r1, [r4, #16]
  _blocking = true;
 80a1514:	7463      	strb	r3, [r4, #17]

  HAL_USB_USART_Init(_serial, &conf);
 80a1516:	4611      	mov	r1, r2
 80a1518:	f7ff fcb6 	bl	80a0e88 <HAL_USB_USART_Init>
}
 80a151c:	4620      	mov	r0, r4
 80a151e:	bd10      	pop	{r4, pc}
 80a1520:	080a237c 	.word	0x080a237c

080a1524 <_Z19acquireSerialBufferv>:

// Preinstantiate Objects //////////////////////////////////////////////////////
#ifdef SPARK_USB_SERIAL

HAL_USB_USART_Config __attribute__((weak)) acquireSerialBuffer()
{
 80a1524:	b510      	push	{r4, lr}
 80a1526:	4604      	mov	r4, r0
  HAL_USB_USART_Config conf = {0};
 80a1528:	2214      	movs	r2, #20
 80a152a:	2100      	movs	r1, #0
 80a152c:	f000 fb57 	bl	80a1bde <memset>

#if defined(USB_SERIAL_USERSPACE_BUFFERS) && ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
  static uint8_t serial_rx_buffer[USB_RX_BUFFER_SIZE];
  static uint8_t serial_tx_buffer[USB_TX_BUFFER_SIZE];

  conf.rx_buffer = serial_rx_buffer;
 80a1530:	4b05      	ldr	r3, [pc, #20]	; (80a1548 <_Z19acquireSerialBufferv+0x24>)
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
#endif

  return conf;
}
 80a1532:	4620      	mov	r0, r4

#if defined(USB_SERIAL_USERSPACE_BUFFERS) && ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
  static uint8_t serial_rx_buffer[USB_RX_BUFFER_SIZE];
  static uint8_t serial_tx_buffer[USB_TX_BUFFER_SIZE];

  conf.rx_buffer = serial_rx_buffer;
 80a1534:	6063      	str	r3, [r4, #4]
  conf.tx_buffer = serial_tx_buffer;
 80a1536:	4b05      	ldr	r3, [pc, #20]	; (80a154c <_Z19acquireSerialBufferv+0x28>)
 80a1538:	60e3      	str	r3, [r4, #12]
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
 80a153a:	f240 1301 	movw	r3, #257	; 0x101
 80a153e:	8123      	strh	r3, [r4, #8]
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
 80a1540:	2381      	movs	r3, #129	; 0x81
 80a1542:	8223      	strh	r3, [r4, #16]
#endif

  return conf;
}
 80a1544:	bd10      	pop	{r4, pc}
 80a1546:	bf00      	nop
 80a1548:	2000097d 	.word	0x2000097d
 80a154c:	200008fc 	.word	0x200008fc

080a1550 <_Z16_fetch_usbserialv>:

USBSerial& _fetch_usbserial()
{
 80a1550:	b530      	push	{r4, r5, lr}
  HAL_USB_USART_Config conf = acquireSerialBuffer();
	static USBSerial _usbserial(HAL_USB_USART_SERIAL, conf);
 80a1552:	4d0e      	ldr	r5, [pc, #56]	; (80a158c <_Z16_fetch_usbserialv+0x3c>)

  return conf;
}

USBSerial& _fetch_usbserial()
{
 80a1554:	b087      	sub	sp, #28
  HAL_USB_USART_Config conf = acquireSerialBuffer();
 80a1556:	a801      	add	r0, sp, #4
 80a1558:	f7ff ffe4 	bl	80a1524 <_Z19acquireSerialBufferv>
	static USBSerial _usbserial(HAL_USB_USART_SERIAL, conf);
 80a155c:	6829      	ldr	r1, [r5, #0]
 80a155e:	f011 0401 	ands.w	r4, r1, #1
 80a1562:	d110      	bne.n	80a1586 <_Z16_fetch_usbserialv+0x36>
 80a1564:	4628      	mov	r0, r5
 80a1566:	f7fe fda5 	bl	80a00b4 <__cxa_guard_acquire>
 80a156a:	b160      	cbz	r0, 80a1586 <_Z16_fetch_usbserialv+0x36>
 80a156c:	aa01      	add	r2, sp, #4
 80a156e:	4621      	mov	r1, r4
 80a1570:	4807      	ldr	r0, [pc, #28]	; (80a1590 <_Z16_fetch_usbserialv+0x40>)
 80a1572:	f7ff ffc3 	bl	80a14fc <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>
 80a1576:	4628      	mov	r0, r5
 80a1578:	f7fe fda1 	bl	80a00be <__cxa_guard_release>
 80a157c:	4a05      	ldr	r2, [pc, #20]	; (80a1594 <_Z16_fetch_usbserialv+0x44>)
 80a157e:	4906      	ldr	r1, [pc, #24]	; (80a1598 <_Z16_fetch_usbserialv+0x48>)
 80a1580:	4803      	ldr	r0, [pc, #12]	; (80a1590 <_Z16_fetch_usbserialv+0x40>)
 80a1582:	f000 f9c5 	bl	80a1910 <__aeabi_atexit>
	return _usbserial;
}
 80a1586:	4802      	ldr	r0, [pc, #8]	; (80a1590 <_Z16_fetch_usbserialv+0x40>)
 80a1588:	b007      	add	sp, #28
 80a158a:	bd30      	pop	{r4, r5, pc}
 80a158c:	200008f8 	.word	0x200008f8
 80a1590:	20000a80 	.word	0x20000a80
 80a1594:	20000778 	.word	0x20000778
 80a1598:	080a14ad 	.word	0x080a14ad

080a159c <_Z23acquireUSBSerial1Bufferv>:

#if Wiring_USBSerial1

HAL_USB_USART_Config __attribute__((weak)) acquireUSBSerial1Buffer()
{
 80a159c:	b510      	push	{r4, lr}
 80a159e:	4604      	mov	r4, r0
  HAL_USB_USART_Config conf = {0};
 80a15a0:	2214      	movs	r2, #20
 80a15a2:	2100      	movs	r1, #0
 80a15a4:	f000 fb1b 	bl	80a1bde <memset>

#if defined(USB_SERIAL_USERSPACE_BUFFERS) && ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
  static uint8_t usbserial1_rx_buffer[USB_RX_BUFFER_SIZE];
  static uint8_t usbserial1_tx_buffer[USB_TX_BUFFER_SIZE];

  conf.rx_buffer = usbserial1_rx_buffer;
 80a15a8:	4b05      	ldr	r3, [pc, #20]	; (80a15c0 <_Z23acquireUSBSerial1Bufferv+0x24>)
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
#endif

  return conf;
}
 80a15aa:	4620      	mov	r0, r4

#if defined(USB_SERIAL_USERSPACE_BUFFERS) && ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
  static uint8_t usbserial1_rx_buffer[USB_RX_BUFFER_SIZE];
  static uint8_t usbserial1_tx_buffer[USB_TX_BUFFER_SIZE];

  conf.rx_buffer = usbserial1_rx_buffer;
 80a15ac:	6063      	str	r3, [r4, #4]
  conf.tx_buffer = usbserial1_tx_buffer;
 80a15ae:	4b05      	ldr	r3, [pc, #20]	; (80a15c4 <_Z23acquireUSBSerial1Bufferv+0x28>)
 80a15b0:	60e3      	str	r3, [r4, #12]
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
 80a15b2:	f240 1301 	movw	r3, #257	; 0x101
 80a15b6:	8123      	strh	r3, [r4, #8]
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
 80a15b8:	2381      	movs	r3, #129	; 0x81
 80a15ba:	8223      	strh	r3, [r4, #16]
#endif

  return conf;
}
 80a15bc:	bd10      	pop	{r4, pc}
 80a15be:	bf00      	nop
 80a15c0:	20000b30 	.word	0x20000b30
 80a15c4:	20000a98 	.word	0x20000a98

080a15c8 <_Z17_fetch_usbserial1v>:

USBSerial& _fetch_usbserial1()
{
 80a15c8:	b510      	push	{r4, lr}
  HAL_USB_USART_Config conf = acquireUSBSerial1Buffer();
  static USBSerial _usbserial1(HAL_USB_USART_SERIAL1, conf);
 80a15ca:	4c0e      	ldr	r4, [pc, #56]	; (80a1604 <_Z17_fetch_usbserial1v+0x3c>)

  return conf;
}

USBSerial& _fetch_usbserial1()
{
 80a15cc:	b086      	sub	sp, #24
  HAL_USB_USART_Config conf = acquireUSBSerial1Buffer();
 80a15ce:	a801      	add	r0, sp, #4
 80a15d0:	f7ff ffe4 	bl	80a159c <_Z23acquireUSBSerial1Bufferv>
  static USBSerial _usbserial1(HAL_USB_USART_SERIAL1, conf);
 80a15d4:	6823      	ldr	r3, [r4, #0]
 80a15d6:	07db      	lsls	r3, r3, #31
 80a15d8:	d410      	bmi.n	80a15fc <_Z17_fetch_usbserial1v+0x34>
 80a15da:	4620      	mov	r0, r4
 80a15dc:	f7fe fd6a 	bl	80a00b4 <__cxa_guard_acquire>
 80a15e0:	b160      	cbz	r0, 80a15fc <_Z17_fetch_usbserial1v+0x34>
 80a15e2:	aa01      	add	r2, sp, #4
 80a15e4:	2101      	movs	r1, #1
 80a15e6:	4808      	ldr	r0, [pc, #32]	; (80a1608 <_Z17_fetch_usbserial1v+0x40>)
 80a15e8:	f7ff ff88 	bl	80a14fc <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>
 80a15ec:	4620      	mov	r0, r4
 80a15ee:	f7fe fd66 	bl	80a00be <__cxa_guard_release>
 80a15f2:	4a06      	ldr	r2, [pc, #24]	; (80a160c <_Z17_fetch_usbserial1v+0x44>)
 80a15f4:	4906      	ldr	r1, [pc, #24]	; (80a1610 <_Z17_fetch_usbserial1v+0x48>)
 80a15f6:	4804      	ldr	r0, [pc, #16]	; (80a1608 <_Z17_fetch_usbserial1v+0x40>)
 80a15f8:	f000 f98a 	bl	80a1910 <__aeabi_atexit>
  return _usbserial1;
}
 80a15fc:	4802      	ldr	r0, [pc, #8]	; (80a1608 <_Z17_fetch_usbserial1v+0x40>)
 80a15fe:	b006      	add	sp, #24
 80a1600:	bd10      	pop	{r4, pc}
 80a1602:	bf00      	nop
 80a1604:	20000a94 	.word	0x20000a94
 80a1608:	20000b1c 	.word	0x20000b1c
 80a160c:	20000778 	.word	0x20000778
 80a1610:	080a14ad 	.word	0x080a14ad

080a1614 <_ZN5spark9WiFiClassD1Ev>:
        wlan_set_ipaddress_source(source, true, NULL);
    }

public:
    WiFiClass() {}
    ~WiFiClass() {}
 80a1614:	4770      	bx	lr

080a1616 <_ZN5spark9WiFiClass5readyEv>:
    bool connecting(void) {
        return network_connecting(*this, 0, NULL);
    }

    bool ready(void) {
        return network_ready(*this, 0, NULL);
 80a1616:	2200      	movs	r2, #0
 80a1618:	4611      	mov	r1, r2
 80a161a:	4610      	mov	r0, r2
 80a161c:	f7ff bc98 	b.w	80a0f50 <network_ready>

080a1620 <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t>:
    void setIPAddressSource(IPAddressSource source) {
        wlan_set_ipaddress_source(source, true, NULL);
    }

public:
    WiFiClass() {}
 80a1620:	4803      	ldr	r0, [pc, #12]	; (80a1630 <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t+0x10>)
 80a1622:	4b04      	ldr	r3, [pc, #16]	; (80a1634 <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t+0x14>)
one second timeout is reached). If the aforementioned "bug" is ever fixed by
TI, no changes need to be made to this function, as it would be implemented
the same way.
*****************************************************************************/

    WiFiClass WiFi;
 80a1624:	4a04      	ldr	r2, [pc, #16]	; (80a1638 <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t+0x18>)
 80a1626:	4905      	ldr	r1, [pc, #20]	; (80a163c <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t+0x1c>)
 80a1628:	6003      	str	r3, [r0, #0]
 80a162a:	f000 b971 	b.w	80a1910 <__aeabi_atexit>
 80a162e:	bf00      	nop
 80a1630:	20000c34 	.word	0x20000c34
 80a1634:	080a23ac 	.word	0x080a23ac
 80a1638:	20000778 	.word	0x20000778
 80a163c:	080a1615 	.word	0x080a1615

080a1640 <serialEventRun>:

/**
 * Provides background processing of serial data.
 */
void serialEventRun()
{
 80a1640:	b508      	push	{r3, lr}
    if (serialEvent && Serial.available()>0)
 80a1642:	4b14      	ldr	r3, [pc, #80]	; (80a1694 <serialEventRun+0x54>)
 80a1644:	b133      	cbz	r3, 80a1654 <serialEventRun+0x14>
 80a1646:	f7ff ff83 	bl	80a1550 <_Z16_fetch_usbserialv>
 80a164a:	6803      	ldr	r3, [r0, #0]
 80a164c:	691b      	ldr	r3, [r3, #16]
 80a164e:	4798      	blx	r3
 80a1650:	2800      	cmp	r0, #0
 80a1652:	dc16      	bgt.n	80a1682 <serialEventRun+0x42>
        serialEvent();

    if (serialEvent1 && Serial1.available()>0)
 80a1654:	4b10      	ldr	r3, [pc, #64]	; (80a1698 <serialEventRun+0x58>)
 80a1656:	b133      	cbz	r3, 80a1666 <serialEventRun+0x26>
 80a1658:	f7ff ff00 	bl	80a145c <_Z22__fetch_global_Serial1v>
 80a165c:	6803      	ldr	r3, [r0, #0]
 80a165e:	691b      	ldr	r3, [r3, #16]
 80a1660:	4798      	blx	r3
 80a1662:	2800      	cmp	r0, #0
 80a1664:	dc10      	bgt.n	80a1688 <serialEventRun+0x48>
        serialEvent1();

#if Wiring_Serial2
    if (serialEventRun2) serialEventRun2();
 80a1666:	4b0d      	ldr	r3, [pc, #52]	; (80a169c <serialEventRun+0x5c>)
 80a1668:	b10b      	cbz	r3, 80a166e <serialEventRun+0x2e>
 80a166a:	f3af 8000 	nop.w
#if Wiring_Serial5
    if (serialEventRun5) serialEventRun5();
#endif

#if Wiring_USBSerial1
    if (usbSerialEvent1 && USBSerial1.available()>0)
 80a166e:	4b0c      	ldr	r3, [pc, #48]	; (80a16a0 <serialEventRun+0x60>)
 80a1670:	b17b      	cbz	r3, 80a1692 <serialEventRun+0x52>
 80a1672:	f7ff ffa9 	bl	80a15c8 <_Z17_fetch_usbserial1v>
 80a1676:	6803      	ldr	r3, [r0, #0]
 80a1678:	691b      	ldr	r3, [r3, #16]
 80a167a:	4798      	blx	r3
 80a167c:	2800      	cmp	r0, #0
 80a167e:	dc06      	bgt.n	80a168e <serialEventRun+0x4e>
 80a1680:	bd08      	pop	{r3, pc}
 * Provides background processing of serial data.
 */
void serialEventRun()
{
    if (serialEvent && Serial.available()>0)
        serialEvent();
 80a1682:	f3af 8000 	nop.w
 80a1686:	e7e5      	b.n	80a1654 <serialEventRun+0x14>

    if (serialEvent1 && Serial1.available()>0)
        serialEvent1();
 80a1688:	f3af 8000 	nop.w
 80a168c:	e7eb      	b.n	80a1666 <serialEventRun+0x26>
    if (serialEventRun5) serialEventRun5();
#endif

#if Wiring_USBSerial1
    if (usbSerialEvent1 && USBSerial1.available()>0)
        usbSerialEvent1();
 80a168e:	f3af 8000 	nop.w
 80a1692:	bd08      	pop	{r3, pc}
	...

080a16a4 <_post_loop>:
#if Wiring_Serial5
void serialEvent5() __attribute__((weak));
#endif

void _post_loop()
{
 80a16a4:	b508      	push	{r3, lr}
	serialEventRun();
 80a16a6:	f7ff ffcb 	bl	80a1640 <serialEventRun>
		return !timeout_fn;
	}

	static inline system_tick_t current_time()
	{
		return HAL_Timer_Get_Milli_Seconds();
 80a16aa:	f7ff faf3 	bl	80a0c94 <HAL_Timer_Get_Milli_Seconds>
	/**
	 * Lifesign that the application is still working normally.
	 */
	static void checkin()
	{
		last_checkin = current_time();
 80a16ae:	4b01      	ldr	r3, [pc, #4]	; (80a16b4 <_post_loop+0x10>)
 80a16b0:	6018      	str	r0, [r3, #0]
 80a16b2:	bd08      	pop	{r3, pc}
 80a16b4:	20000c40 	.word	0x20000c40

080a16b8 <_Z33system_initialize_user_backup_ramv>:
 * the dynamically linked application module.
 */
void system_initialize_user_backup_ram()
{
    size_t len = &link_global_retained_end-&link_global_retained_start;
    memcpy(&link_global_retained_start, &link_global_retained_initial_values, len);
 80a16b8:	4802      	ldr	r0, [pc, #8]	; (80a16c4 <_Z33system_initialize_user_backup_ramv+0xc>)
 80a16ba:	4a03      	ldr	r2, [pc, #12]	; (80a16c8 <_Z33system_initialize_user_backup_ramv+0x10>)
 80a16bc:	4903      	ldr	r1, [pc, #12]	; (80a16cc <_Z33system_initialize_user_backup_ramv+0x14>)
 80a16be:	1a12      	subs	r2, r2, r0
 80a16c0:	f000 ba82 	b.w	80a1bc8 <memcpy>
 80a16c4:	40024000 	.word	0x40024000
 80a16c8:	40024004 	.word	0x40024004
 80a16cc:	080a2450 	.word	0x080a2450

080a16d0 <_Z27ctrl_request_custom_handlerP12ctrl_request>:
bool __backup_ram_was_valid() { return false; }

#endif

// Default handler for CTRL_REQUEST_APP_CUSTOM requests
void __attribute((weak)) ctrl_request_custom_handler(ctrl_request* req) {
 80a16d0:	b507      	push	{r0, r1, r2, lr}
    system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
 80a16d2:	2300      	movs	r3, #0
 80a16d4:	9300      	str	r3, [sp, #0]
 80a16d6:	461a      	mov	r2, r3
 80a16d8:	f06f 0177 	mvn.w	r1, #119	; 0x77
 80a16dc:	f7ff fc26 	bl	80a0f2c <system_ctrl_set_result>
}
 80a16e0:	b003      	add	sp, #12
 80a16e2:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080a16e8 <_ZL20ctrl_request_handlerP12ctrl_request>:
// Callback invoked to process a logging configuration request
void(*log_process_ctrl_request_callback)(ctrl_request* req) = nullptr;
#endif

// Application handler for control requests
static void ctrl_request_handler(ctrl_request* req) {
 80a16e8:	b507      	push	{r0, r1, r2, lr}
    switch (req->type) {
 80a16ea:	8843      	ldrh	r3, [r0, #2]
 80a16ec:	2b0a      	cmp	r3, #10
 80a16ee:	d008      	beq.n	80a1702 <_ZL20ctrl_request_handlerP12ctrl_request+0x1a>
 80a16f0:	2b50      	cmp	r3, #80	; 0x50
 80a16f2:	d109      	bne.n	80a1708 <_ZL20ctrl_request_handlerP12ctrl_request+0x20>
#if Wiring_LogConfig
    case CTRL_REQUEST_LOG_CONFIG: {
        if (log_process_ctrl_request_callback) {
 80a16f4:	4b09      	ldr	r3, [pc, #36]	; (80a171c <_ZL20ctrl_request_handlerP12ctrl_request+0x34>)
 80a16f6:	681b      	ldr	r3, [r3, #0]
 80a16f8:	b13b      	cbz	r3, 80a170a <_ZL20ctrl_request_handlerP12ctrl_request+0x22>
    }
    default:
        system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
        break;
    }
}
 80a16fa:	b003      	add	sp, #12
 80a16fc:	f85d eb04 	ldr.w	lr, [sp], #4
static void ctrl_request_handler(ctrl_request* req) {
    switch (req->type) {
#if Wiring_LogConfig
    case CTRL_REQUEST_LOG_CONFIG: {
        if (log_process_ctrl_request_callback) {
            log_process_ctrl_request_callback(req);
 80a1700:	4718      	bx	r3
        }
        break;
    }
#endif
    case CTRL_REQUEST_APP_CUSTOM: {
        ctrl_request_custom_handler(req);
 80a1702:	f7ff ffe5 	bl	80a16d0 <_Z27ctrl_request_custom_handlerP12ctrl_request>
        break;
 80a1706:	e006      	b.n	80a1716 <_ZL20ctrl_request_handlerP12ctrl_request+0x2e>
    }
    default:
        system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
 80a1708:	2300      	movs	r3, #0
 80a170a:	9300      	str	r3, [sp, #0]
 80a170c:	461a      	mov	r2, r3
 80a170e:	f06f 0177 	mvn.w	r1, #119	; 0x77
 80a1712:	f7ff fc0b 	bl	80a0f2c <system_ctrl_set_result>
        break;
    }
}
 80a1716:	b003      	add	sp, #12
 80a1718:	f85d fb04 	ldr.w	pc, [sp], #4
 80a171c:	20000c38 	.word	0x20000c38

080a1720 <module_user_init_hook>:

void module_user_init_hook()
{
 80a1720:	b538      	push	{r3, r4, r5, lr}
#if PLATFORM_BACKUP_RAM
    backup_ram_was_valid_ =  __backup_sram_signature==signature;
 80a1722:	4c10      	ldr	r4, [pc, #64]	; (80a1764 <module_user_init_hook+0x44>)
 80a1724:	4d10      	ldr	r5, [pc, #64]	; (80a1768 <module_user_init_hook+0x48>)
 80a1726:	6823      	ldr	r3, [r4, #0]
 80a1728:	42ab      	cmp	r3, r5
 80a172a:	4b10      	ldr	r3, [pc, #64]	; (80a176c <module_user_init_hook+0x4c>)
 80a172c:	bf0c      	ite	eq
 80a172e:	2201      	moveq	r2, #1
 80a1730:	2200      	movne	r2, #0
 80a1732:	701a      	strb	r2, [r3, #0]
    if (!backup_ram_was_valid_) {
 80a1734:	d002      	beq.n	80a173c <module_user_init_hook+0x1c>
        system_initialize_user_backup_ram();
 80a1736:	f7ff ffbf 	bl	80a16b8 <_Z33system_initialize_user_backup_ramv>
        __backup_sram_signature = signature;
 80a173a:	6025      	str	r5, [r4, #0]
#endif

    // todo - add a RNG define for that capability
#if defined(STM32F2XX)
    // Initialize the default stdlib PRNG using hardware RNG as a seed
    srand(HAL_RNG_GetRandomNumber());
 80a173c:	f7ff fa9a 	bl	80a0c74 <HAL_RNG_GetRandomNumber>
 80a1740:	f000 fa56 	bl	80a1bf0 <srand>

    // If the user defines random_seed_from_cloud, call it with a seed value
    // generated by a hardware RNG as well.
    if (random_seed_from_cloud) {
 80a1744:	4b0a      	ldr	r3, [pc, #40]	; (80a1770 <module_user_init_hook+0x50>)
 80a1746:	b11b      	cbz	r3, 80a1750 <module_user_init_hook+0x30>
        uint32_t seed = HAL_RNG_GetRandomNumber();
 80a1748:	f7ff fa94 	bl	80a0c74 <HAL_RNG_GetRandomNumber>
        random_seed_from_cloud(seed);
 80a174c:	f3af 8000 	nop.w
    }
#endif
    // Register the random_seed_from_cloud handler
    spark_set_random_seed_from_cloud_handler(&random_seed_from_cloud, nullptr);
 80a1750:	2100      	movs	r1, #0
 80a1752:	4807      	ldr	r0, [pc, #28]	; (80a1770 <module_user_init_hook+0x50>)
 80a1754:	f7ff fbf4 	bl	80a0f40 <spark_set_random_seed_from_cloud_handler>

    // Register application handler for the control requests
    system_ctrl_set_app_request_handler(ctrl_request_handler, nullptr);
}
 80a1758:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
#endif
    // Register the random_seed_from_cloud handler
    spark_set_random_seed_from_cloud_handler(&random_seed_from_cloud, nullptr);

    // Register application handler for the control requests
    system_ctrl_set_app_request_handler(ctrl_request_handler, nullptr);
 80a175c:	2100      	movs	r1, #0
 80a175e:	4805      	ldr	r0, [pc, #20]	; (80a1774 <module_user_init_hook+0x54>)
 80a1760:	f7ff bbda 	b.w	80a0f18 <system_ctrl_set_app_request_handler>
 80a1764:	40024000 	.word	0x40024000
 80a1768:	9a271c1e 	.word	0x9a271c1e
 80a176c:	20000c3c 	.word	0x20000c3c
 80a1770:	00000000 	.word	0x00000000
 80a1774:	080a16e9 	.word	0x080a16e9

080a1778 <pinAvailable>:

/*
 * @brief Perform safety check on desired pin to see if it's already
 * being used.  Return 0 if used, otherwise return 1 if available.
 */
bool pinAvailable(uint16_t pin) {
 80a1778:	b510      	push	{r4, lr}
 80a177a:	4604      	mov	r4, r0

  // SPI safety check
#ifndef SPARK_WIRING_NO_SPI
  if(SPI.isEnabled() == true && (pin == SCK || pin == MOSI || pin == MISO))
 80a177c:	480f      	ldr	r0, [pc, #60]	; (80a17bc <pinAvailable+0x44>)
 80a177e:	f7ff fda1 	bl	80a12c4 <_ZN8SPIClass9isEnabledEv>
 80a1782:	b128      	cbz	r0, 80a1790 <pinAvailable+0x18>
 80a1784:	f1a4 030d 	sub.w	r3, r4, #13
 80a1788:	2b02      	cmp	r3, #2
 80a178a:	d801      	bhi.n	80a1790 <pinAvailable+0x18>
  {
    return 0; // 'pin' is used
 80a178c:	2000      	movs	r0, #0
 80a178e:	bd10      	pop	{r4, pc}
  }
#endif
  // I2C safety check
#ifndef SPARK_WIRING_NO_I2C
  if(Wire.isEnabled() == true && (pin == SCL || pin == SDA))
 80a1790:	f000 f864 	bl	80a185c <_Z19__fetch_global_Wirev>
 80a1794:	f7ff fc5a 	bl	80a104c <_ZN7TwoWire9isEnabledEv>
 80a1798:	b108      	cbz	r0, 80a179e <pinAvailable+0x26>
 80a179a:	2c01      	cmp	r4, #1
 80a179c:	d9f6      	bls.n	80a178c <pinAvailable+0x14>
    return 0; // 'pin' is used
  }
#endif
#ifndef SPARK_WIRING_NO_USART_SERIAL
  // Serial1 safety check
  if(Serial1.isEnabled() == true && (pin == RX || pin == TX))
 80a179e:	f7ff fe5d 	bl	80a145c <_Z22__fetch_global_Serial1v>
 80a17a2:	f7ff fe57 	bl	80a1454 <_ZN11USARTSerial9isEnabledEv>
 80a17a6:	b118      	cbz	r0, 80a17b0 <pinAvailable+0x38>
 80a17a8:	f1a4 0312 	sub.w	r3, r4, #18
 80a17ac:	2b01      	cmp	r3, #1
 80a17ae:	d9ed      	bls.n	80a178c <pinAvailable+0x14>
  {
    return 0; // 'pin' is used
  }
#endif

  if (pin >= TOTAL_PINS)
 80a17b0:	2c17      	cmp	r4, #23
 80a17b2:	bf8c      	ite	hi
 80a17b4:	2000      	movhi	r0, #0
 80a17b6:	2001      	movls	r0, #1
    return 0;
  else
    return 1; // 'pin' is available
}
 80a17b8:	bd10      	pop	{r4, pc}
 80a17ba:	bf00      	nop
 80a17bc:	20000c74 	.word	0x20000c74

080a17c0 <pinMode>:
 * or INPUT_PULLDOWN
 */
void pinMode(uint16_t pin, PinMode setMode)
{

  if(pin >= TOTAL_PINS || setMode == PIN_MODE_NONE )
 80a17c0:	2817      	cmp	r0, #23
/*
 * @brief Set the mode of the pin to OUTPUT, INPUT, INPUT_PULLUP,
 * or INPUT_PULLDOWN
 */
void pinMode(uint16_t pin, PinMode setMode)
{
 80a17c2:	b538      	push	{r3, r4, r5, lr}
 80a17c4:	4604      	mov	r4, r0
 80a17c6:	460d      	mov	r5, r1

  if(pin >= TOTAL_PINS || setMode == PIN_MODE_NONE )
 80a17c8:	d80a      	bhi.n	80a17e0 <pinMode+0x20>
 80a17ca:	29ff      	cmp	r1, #255	; 0xff
 80a17cc:	d008      	beq.n	80a17e0 <pinMode+0x20>
  {
    return;
  }

  // Safety check
  if( !pinAvailable(pin) ) {
 80a17ce:	f7ff ffd3 	bl	80a1778 <pinAvailable>
 80a17d2:	b128      	cbz	r0, 80a17e0 <pinMode+0x20>
    return;
  }

  HAL_Pin_Mode(pin, setMode);
 80a17d4:	4629      	mov	r1, r5
 80a17d6:	4620      	mov	r0, r4
}
 80a17d8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  // Safety check
  if( !pinAvailable(pin) ) {
    return;
  }

  HAL_Pin_Mode(pin, setMode);
 80a17dc:	f7ff ba6a 	b.w	80a0cb4 <HAL_Pin_Mode>
 80a17e0:	bd38      	pop	{r3, r4, r5, pc}

080a17e2 <digitalWrite>:

/*
 * @brief Sets a GPIO pin to HIGH or LOW.
 */
void digitalWrite(pin_t pin, uint8_t value)
{
 80a17e2:	b538      	push	{r3, r4, r5, lr}
 80a17e4:	4604      	mov	r4, r0
 80a17e6:	460d      	mov	r5, r1
    PinMode mode = HAL_Get_Pin_Mode(pin);
 80a17e8:	f7ff fa6c 	bl	80a0cc4 <HAL_Get_Pin_Mode>
    if (mode==PIN_MODE_NONE || is_input_mode(mode))
 80a17ec:	28ff      	cmp	r0, #255	; 0xff
 80a17ee:	d010      	beq.n	80a1812 <digitalWrite+0x30>
}

inline bool is_input_mode(PinMode mode) {
    return  mode == INPUT ||
            mode == INPUT_PULLUP ||
            mode == INPUT_PULLDOWN ||
 80a17f0:	2806      	cmp	r0, #6
 80a17f2:	d804      	bhi.n	80a17fe <digitalWrite+0x1c>
 80a17f4:	234d      	movs	r3, #77	; 0x4d
 80a17f6:	fa23 f000 	lsr.w	r0, r3, r0
 80a17fa:	07c3      	lsls	r3, r0, #31
 80a17fc:	d409      	bmi.n	80a1812 <digitalWrite+0x30>
{
    PinMode mode = HAL_Get_Pin_Mode(pin);
    if (mode==PIN_MODE_NONE || is_input_mode(mode))
        return;
  // Safety check
  if( !pinAvailable(pin) ) {
 80a17fe:	4620      	mov	r0, r4
 80a1800:	f7ff ffba 	bl	80a1778 <pinAvailable>
 80a1804:	b128      	cbz	r0, 80a1812 <digitalWrite+0x30>
    return;
  }

  HAL_GPIO_Write(pin, value);
 80a1806:	4629      	mov	r1, r5
 80a1808:	4620      	mov	r0, r4
}
 80a180a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  // Safety check
  if( !pinAvailable(pin) ) {
    return;
  }

  HAL_GPIO_Write(pin, value);
 80a180e:	f7ff ba61 	b.w	80a0cd4 <HAL_GPIO_Write>
 80a1812:	bd38      	pop	{r3, r4, r5, pc}

080a1814 <shiftOut>:
  }
  return value;
}

void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, uint8_t val)
{
 80a1814:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80a1818:	4690      	mov	r8, r2
 80a181a:	461e      	mov	r6, r3
 80a181c:	4607      	mov	r7, r0
    if (bitOrder == LSBFIRST)
      digitalWrite(dataPin, !!(val & (1 << i)));
    else
      digitalWrite(dataPin, !!(val & (1 << (7 - i))));

    digitalWrite(clockPin, HIGH);
 80a181e:	460d      	mov	r5, r1
  }
  return value;
}

void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, uint8_t val)
{
 80a1820:	2407      	movs	r4, #7
  uint8_t i;

  for (i = 0; i < 8; i++)  {
    if (bitOrder == LSBFIRST)
 80a1822:	f1b8 0f00 	cmp.w	r8, #0
 80a1826:	d104      	bne.n	80a1832 <shiftOut+0x1e>
      digitalWrite(dataPin, !!(val & (1 << i)));
 80a1828:	f1c4 0107 	rsb	r1, r4, #7
 80a182c:	fa46 f101 	asr.w	r1, r6, r1
 80a1830:	e001      	b.n	80a1836 <shiftOut+0x22>
    else
      digitalWrite(dataPin, !!(val & (1 << (7 - i))));
 80a1832:	fa46 f104 	asr.w	r1, r6, r4
 80a1836:	f001 0101 	and.w	r1, r1, #1
 80a183a:	4638      	mov	r0, r7
 80a183c:	f7ff ffd1 	bl	80a17e2 <digitalWrite>

    digitalWrite(clockPin, HIGH);
 80a1840:	2101      	movs	r1, #1
 80a1842:	4628      	mov	r0, r5
 80a1844:	f7ff ffcd 	bl	80a17e2 <digitalWrite>
    digitalWrite(clockPin, LOW);
 80a1848:	2100      	movs	r1, #0
 80a184a:	4628      	mov	r0, r5
 80a184c:	f7ff ffc9 	bl	80a17e2 <digitalWrite>

void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, uint8_t val)
{
  uint8_t i;

  for (i = 0; i < 8; i++)  {
 80a1850:	f114 34ff 	adds.w	r4, r4, #4294967295	; 0xffffffff
 80a1854:	d2e5      	bcs.n	80a1822 <shiftOut+0xe>
      digitalWrite(dataPin, !!(val & (1 << (7 - i))));

    digitalWrite(clockPin, HIGH);
    digitalWrite(clockPin, LOW);
  }
}
 80a1856:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	...

080a185c <_Z19__fetch_global_Wirev>:
#include "i2c_hal.h"

#ifndef SPARK_WIRING_NO_I2C

TwoWire& __fetch_global_Wire()
{
 80a185c:	b538      	push	{r3, r4, r5, lr}
	static TwoWire wire(HAL_I2C_INTERFACE1);
 80a185e:	4d0b      	ldr	r5, [pc, #44]	; (80a188c <_Z19__fetch_global_Wirev+0x30>)
 80a1860:	6829      	ldr	r1, [r5, #0]
 80a1862:	f011 0401 	ands.w	r4, r1, #1
 80a1866:	d10f      	bne.n	80a1888 <_Z19__fetch_global_Wirev+0x2c>
 80a1868:	4628      	mov	r0, r5
 80a186a:	f7fe fc23 	bl	80a00b4 <__cxa_guard_acquire>
 80a186e:	b158      	cbz	r0, 80a1888 <_Z19__fetch_global_Wirev+0x2c>
 80a1870:	4621      	mov	r1, r4
 80a1872:	4807      	ldr	r0, [pc, #28]	; (80a1890 <_Z19__fetch_global_Wirev+0x34>)
 80a1874:	f7ff fbc4 	bl	80a1000 <_ZN7TwoWireC1E17HAL_I2C_Interface>
 80a1878:	4628      	mov	r0, r5
 80a187a:	f7fe fc20 	bl	80a00be <__cxa_guard_release>
 80a187e:	4a05      	ldr	r2, [pc, #20]	; (80a1894 <_Z19__fetch_global_Wirev+0x38>)
 80a1880:	4905      	ldr	r1, [pc, #20]	; (80a1898 <_Z19__fetch_global_Wirev+0x3c>)
 80a1882:	4803      	ldr	r0, [pc, #12]	; (80a1890 <_Z19__fetch_global_Wirev+0x34>)
 80a1884:	f000 f844 	bl	80a1910 <__aeabi_atexit>
	return wire;
}
 80a1888:	4801      	ldr	r0, [pc, #4]	; (80a1890 <_Z19__fetch_global_Wirev+0x34>)
 80a188a:	bd38      	pop	{r3, r4, r5, pc}
 80a188c:	20000c44 	.word	0x20000c44
 80a1890:	20000c48 	.word	0x20000c48
 80a1894:	20000778 	.word	0x20000778
 80a1898:	080a0fa9 	.word	0x080a0fa9

080a189c <_GLOBAL__sub_I_INADDR_NONE>:
#include "spark_wiring_ipaddress.h"

const IPAddress INADDR_NONE(0, 0, 0, 0);
 80a189c:	b513      	push	{r0, r1, r4, lr}
 80a189e:	4c08      	ldr	r4, [pc, #32]	; (80a18c0 <_GLOBAL__sub_I_INADDR_NONE+0x24>)
 80a18a0:	2300      	movs	r3, #0
 80a18a2:	461a      	mov	r2, r3
 80a18a4:	4619      	mov	r1, r3
 80a18a6:	9300      	str	r3, [sp, #0]
 80a18a8:	4620      	mov	r0, r4
 80a18aa:	f7ff fc01 	bl	80a10b0 <_ZN9IPAddressC1Ehhhh>
 80a18ae:	4620      	mov	r0, r4
 80a18b0:	4a04      	ldr	r2, [pc, #16]	; (80a18c4 <_GLOBAL__sub_I_INADDR_NONE+0x28>)
 80a18b2:	4905      	ldr	r1, [pc, #20]	; (80a18c8 <_GLOBAL__sub_I_INADDR_NONE+0x2c>)
 80a18b4:	b002      	add	sp, #8
 80a18b6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80a18ba:	f000 b829 	b.w	80a1910 <__aeabi_atexit>
 80a18be:	bf00      	nop
 80a18c0:	20000c5c 	.word	0x20000c5c
 80a18c4:	20000778 	.word	0x20000778
 80a18c8:	080a1055 	.word	0x080a1055

080a18cc <_GLOBAL__sub_I_SPI>:
#ifndef SPARK_WIRING_NO_SPI

SPIClass SPI(HAL_SPI_INTERFACE1);

#if Wiring_SPI1
SPIClass SPI1(HAL_SPI_INTERFACE2);
 80a18cc:	b570      	push	{r4, r5, r6, lr}
#include "core_hal.h"
#include "spark_macros.h"

#ifndef SPARK_WIRING_NO_SPI

SPIClass SPI(HAL_SPI_INTERFACE1);
 80a18ce:	4c0c      	ldr	r4, [pc, #48]	; (80a1900 <_GLOBAL__sub_I_SPI+0x34>)
 80a18d0:	4e0c      	ldr	r6, [pc, #48]	; (80a1904 <_GLOBAL__sub_I_SPI+0x38>)
 80a18d2:	4d0d      	ldr	r5, [pc, #52]	; (80a1908 <_GLOBAL__sub_I_SPI+0x3c>)
 80a18d4:	2100      	movs	r1, #0
 80a18d6:	4620      	mov	r0, r4
 80a18d8:	f7ff fc74 	bl	80a11c4 <_ZN8SPIClassC1E17HAL_SPI_Interface>
 80a18dc:	4620      	mov	r0, r4

#if Wiring_SPI1
SPIClass SPI1(HAL_SPI_INTERFACE2);
 80a18de:	4c0b      	ldr	r4, [pc, #44]	; (80a190c <_GLOBAL__sub_I_SPI+0x40>)
#include "core_hal.h"
#include "spark_macros.h"

#ifndef SPARK_WIRING_NO_SPI

SPIClass SPI(HAL_SPI_INTERFACE1);
 80a18e0:	4632      	mov	r2, r6
 80a18e2:	4629      	mov	r1, r5
 80a18e4:	f000 f814 	bl	80a1910 <__aeabi_atexit>

#if Wiring_SPI1
SPIClass SPI1(HAL_SPI_INTERFACE2);
 80a18e8:	2101      	movs	r1, #1
 80a18ea:	4620      	mov	r0, r4
 80a18ec:	f7ff fc6a 	bl	80a11c4 <_ZN8SPIClassC1E17HAL_SPI_Interface>
 80a18f0:	4632      	mov	r2, r6
 80a18f2:	4629      	mov	r1, r5
 80a18f4:	4620      	mov	r0, r4
 80a18f6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 80a18fa:	f000 b809 	b.w	80a1910 <__aeabi_atexit>
 80a18fe:	bf00      	nop
 80a1900:	20000c74 	.word	0x20000c74
 80a1904:	20000778 	.word	0x20000778
 80a1908:	080a11b5 	.word	0x080a11b5
 80a190c:	20000c84 	.word	0x20000c84

080a1910 <__aeabi_atexit>:
 80a1910:	460b      	mov	r3, r1
 80a1912:	4601      	mov	r1, r0
 80a1914:	4618      	mov	r0, r3
 80a1916:	f000 b949 	b.w	80a1bac <__cxa_atexit>
	...

080a191c <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj>:
 80a191c:	4b24      	ldr	r3, [pc, #144]	; (80a19b0 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0x94>)
 80a191e:	681a      	ldr	r2, [r3, #0]
 80a1920:	07d0      	lsls	r0, r2, #31
 80a1922:	bf5c      	itt	pl
 80a1924:	2201      	movpl	r2, #1
 80a1926:	601a      	strpl	r2, [r3, #0]
 80a1928:	4b22      	ldr	r3, [pc, #136]	; (80a19b4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0x98>)
 80a192a:	681a      	ldr	r2, [r3, #0]
 80a192c:	07d1      	lsls	r1, r2, #31
 80a192e:	bf5c      	itt	pl
 80a1930:	2201      	movpl	r2, #1
 80a1932:	601a      	strpl	r2, [r3, #0]
 80a1934:	4b20      	ldr	r3, [pc, #128]	; (80a19b8 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0x9c>)
 80a1936:	681a      	ldr	r2, [r3, #0]
 80a1938:	07d2      	lsls	r2, r2, #31
 80a193a:	bf5c      	itt	pl
 80a193c:	2201      	movpl	r2, #1
 80a193e:	601a      	strpl	r2, [r3, #0]
 80a1940:	4b1e      	ldr	r3, [pc, #120]	; (80a19bc <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xa0>)
 80a1942:	681a      	ldr	r2, [r3, #0]
 80a1944:	07d0      	lsls	r0, r2, #31
 80a1946:	bf5c      	itt	pl
 80a1948:	2201      	movpl	r2, #1
 80a194a:	601a      	strpl	r2, [r3, #0]
 80a194c:	4b1c      	ldr	r3, [pc, #112]	; (80a19c0 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xa4>)
 80a194e:	681a      	ldr	r2, [r3, #0]
 80a1950:	07d1      	lsls	r1, r2, #31
 80a1952:	bf5c      	itt	pl
 80a1954:	2201      	movpl	r2, #1
 80a1956:	601a      	strpl	r2, [r3, #0]
 80a1958:	4b1a      	ldr	r3, [pc, #104]	; (80a19c4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xa8>)
 80a195a:	681a      	ldr	r2, [r3, #0]
 80a195c:	07d2      	lsls	r2, r2, #31
 80a195e:	bf5c      	itt	pl
 80a1960:	2201      	movpl	r2, #1
 80a1962:	601a      	strpl	r2, [r3, #0]
 80a1964:	4b18      	ldr	r3, [pc, #96]	; (80a19c8 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xac>)
 80a1966:	681a      	ldr	r2, [r3, #0]
 80a1968:	07d0      	lsls	r0, r2, #31
 80a196a:	bf5c      	itt	pl
 80a196c:	2201      	movpl	r2, #1
 80a196e:	601a      	strpl	r2, [r3, #0]
 80a1970:	4b16      	ldr	r3, [pc, #88]	; (80a19cc <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xb0>)
 80a1972:	681a      	ldr	r2, [r3, #0]
 80a1974:	07d1      	lsls	r1, r2, #31
 80a1976:	bf5c      	itt	pl
 80a1978:	2201      	movpl	r2, #1
 80a197a:	601a      	strpl	r2, [r3, #0]
 80a197c:	4b14      	ldr	r3, [pc, #80]	; (80a19d0 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xb4>)
 80a197e:	681a      	ldr	r2, [r3, #0]
 80a1980:	07d2      	lsls	r2, r2, #31
 80a1982:	bf5c      	itt	pl
 80a1984:	2201      	movpl	r2, #1
 80a1986:	601a      	strpl	r2, [r3, #0]
 80a1988:	4b12      	ldr	r3, [pc, #72]	; (80a19d4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xb8>)
 80a198a:	681a      	ldr	r2, [r3, #0]
 80a198c:	07d0      	lsls	r0, r2, #31
 80a198e:	bf5c      	itt	pl
 80a1990:	2201      	movpl	r2, #1
 80a1992:	601a      	strpl	r2, [r3, #0]
 80a1994:	4b10      	ldr	r3, [pc, #64]	; (80a19d8 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xbc>)
 80a1996:	681a      	ldr	r2, [r3, #0]
 80a1998:	07d1      	lsls	r1, r2, #31
 80a199a:	bf5c      	itt	pl
 80a199c:	2201      	movpl	r2, #1
 80a199e:	601a      	strpl	r2, [r3, #0]
 80a19a0:	4b0e      	ldr	r3, [pc, #56]	; (80a19dc <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xc0>)
 80a19a2:	681a      	ldr	r2, [r3, #0]
 80a19a4:	07d2      	lsls	r2, r2, #31
 80a19a6:	bf5c      	itt	pl
 80a19a8:	2201      	movpl	r2, #1
 80a19aa:	601a      	strpl	r2, [r3, #0]
 80a19ac:	4770      	bx	lr
 80a19ae:	bf00      	nop
 80a19b0:	20000cc0 	.word	0x20000cc0
 80a19b4:	20000cbc 	.word	0x20000cbc
 80a19b8:	20000cb8 	.word	0x20000cb8
 80a19bc:	20000cb4 	.word	0x20000cb4
 80a19c0:	20000cb0 	.word	0x20000cb0
 80a19c4:	20000cac 	.word	0x20000cac
 80a19c8:	20000ca8 	.word	0x20000ca8
 80a19cc:	20000ca4 	.word	0x20000ca4
 80a19d0:	20000ca0 	.word	0x20000ca0
 80a19d4:	20000c9c 	.word	0x20000c9c
 80a19d8:	20000c98 	.word	0x20000c98
 80a19dc:	20000c94 	.word	0x20000c94

080a19e0 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj>:
 80a19e0:	4b18      	ldr	r3, [pc, #96]	; (80a1a44 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x64>)
 80a19e2:	681a      	ldr	r2, [r3, #0]
 80a19e4:	07d1      	lsls	r1, r2, #31
 80a19e6:	bf5c      	itt	pl
 80a19e8:	2201      	movpl	r2, #1
 80a19ea:	601a      	strpl	r2, [r3, #0]
 80a19ec:	4b16      	ldr	r3, [pc, #88]	; (80a1a48 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x68>)
 80a19ee:	681a      	ldr	r2, [r3, #0]
 80a19f0:	07d2      	lsls	r2, r2, #31
 80a19f2:	bf5c      	itt	pl
 80a19f4:	2201      	movpl	r2, #1
 80a19f6:	601a      	strpl	r2, [r3, #0]
 80a19f8:	4b14      	ldr	r3, [pc, #80]	; (80a1a4c <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x6c>)
 80a19fa:	681a      	ldr	r2, [r3, #0]
 80a19fc:	07d0      	lsls	r0, r2, #31
 80a19fe:	bf5c      	itt	pl
 80a1a00:	2201      	movpl	r2, #1
 80a1a02:	601a      	strpl	r2, [r3, #0]
 80a1a04:	4b12      	ldr	r3, [pc, #72]	; (80a1a50 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x70>)
 80a1a06:	681a      	ldr	r2, [r3, #0]
 80a1a08:	07d1      	lsls	r1, r2, #31
 80a1a0a:	bf5c      	itt	pl
 80a1a0c:	2201      	movpl	r2, #1
 80a1a0e:	601a      	strpl	r2, [r3, #0]
 80a1a10:	4b10      	ldr	r3, [pc, #64]	; (80a1a54 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x74>)
 80a1a12:	681a      	ldr	r2, [r3, #0]
 80a1a14:	07d2      	lsls	r2, r2, #31
 80a1a16:	bf5c      	itt	pl
 80a1a18:	2201      	movpl	r2, #1
 80a1a1a:	601a      	strpl	r2, [r3, #0]
 80a1a1c:	4b0e      	ldr	r3, [pc, #56]	; (80a1a58 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x78>)
 80a1a1e:	681a      	ldr	r2, [r3, #0]
 80a1a20:	07d0      	lsls	r0, r2, #31
 80a1a22:	bf5c      	itt	pl
 80a1a24:	2201      	movpl	r2, #1
 80a1a26:	601a      	strpl	r2, [r3, #0]
 80a1a28:	4b0c      	ldr	r3, [pc, #48]	; (80a1a5c <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x7c>)
 80a1a2a:	681a      	ldr	r2, [r3, #0]
 80a1a2c:	07d1      	lsls	r1, r2, #31
 80a1a2e:	bf5c      	itt	pl
 80a1a30:	2201      	movpl	r2, #1
 80a1a32:	601a      	strpl	r2, [r3, #0]
 80a1a34:	4b0a      	ldr	r3, [pc, #40]	; (80a1a60 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x80>)
 80a1a36:	681a      	ldr	r2, [r3, #0]
 80a1a38:	07d2      	lsls	r2, r2, #31
 80a1a3a:	bf5c      	itt	pl
 80a1a3c:	2201      	movpl	r2, #1
 80a1a3e:	601a      	strpl	r2, [r3, #0]
 80a1a40:	4770      	bx	lr
 80a1a42:	bf00      	nop
 80a1a44:	20000ce0 	.word	0x20000ce0
 80a1a48:	20000cdc 	.word	0x20000cdc
 80a1a4c:	20000cd8 	.word	0x20000cd8
 80a1a50:	20000cd4 	.word	0x20000cd4
 80a1a54:	20000cd0 	.word	0x20000cd0
 80a1a58:	20000ccc 	.word	0x20000ccc
 80a1a5c:	20000cc8 	.word	0x20000cc8
 80a1a60:	20000cc4 	.word	0x20000cc4

080a1a64 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj>:
 80a1a64:	4b18      	ldr	r3, [pc, #96]	; (80a1ac8 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x64>)
 80a1a66:	681a      	ldr	r2, [r3, #0]
 80a1a68:	07d1      	lsls	r1, r2, #31
 80a1a6a:	bf5c      	itt	pl
 80a1a6c:	2201      	movpl	r2, #1
 80a1a6e:	601a      	strpl	r2, [r3, #0]
 80a1a70:	4b16      	ldr	r3, [pc, #88]	; (80a1acc <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x68>)
 80a1a72:	681a      	ldr	r2, [r3, #0]
 80a1a74:	07d2      	lsls	r2, r2, #31
 80a1a76:	bf5c      	itt	pl
 80a1a78:	2201      	movpl	r2, #1
 80a1a7a:	601a      	strpl	r2, [r3, #0]
 80a1a7c:	4b14      	ldr	r3, [pc, #80]	; (80a1ad0 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x6c>)
 80a1a7e:	681a      	ldr	r2, [r3, #0]
 80a1a80:	07d0      	lsls	r0, r2, #31
 80a1a82:	bf5c      	itt	pl
 80a1a84:	2201      	movpl	r2, #1
 80a1a86:	601a      	strpl	r2, [r3, #0]
 80a1a88:	4b12      	ldr	r3, [pc, #72]	; (80a1ad4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x70>)
 80a1a8a:	681a      	ldr	r2, [r3, #0]
 80a1a8c:	07d1      	lsls	r1, r2, #31
 80a1a8e:	bf5c      	itt	pl
 80a1a90:	2201      	movpl	r2, #1
 80a1a92:	601a      	strpl	r2, [r3, #0]
 80a1a94:	4b10      	ldr	r3, [pc, #64]	; (80a1ad8 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x74>)
 80a1a96:	681a      	ldr	r2, [r3, #0]
 80a1a98:	07d2      	lsls	r2, r2, #31
 80a1a9a:	bf5c      	itt	pl
 80a1a9c:	2201      	movpl	r2, #1
 80a1a9e:	601a      	strpl	r2, [r3, #0]
 80a1aa0:	4b0e      	ldr	r3, [pc, #56]	; (80a1adc <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x78>)
 80a1aa2:	681a      	ldr	r2, [r3, #0]
 80a1aa4:	07d0      	lsls	r0, r2, #31
 80a1aa6:	bf5c      	itt	pl
 80a1aa8:	2201      	movpl	r2, #1
 80a1aaa:	601a      	strpl	r2, [r3, #0]
 80a1aac:	4b0c      	ldr	r3, [pc, #48]	; (80a1ae0 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x7c>)
 80a1aae:	681a      	ldr	r2, [r3, #0]
 80a1ab0:	07d1      	lsls	r1, r2, #31
 80a1ab2:	bf5c      	itt	pl
 80a1ab4:	2201      	movpl	r2, #1
 80a1ab6:	601a      	strpl	r2, [r3, #0]
 80a1ab8:	4b0a      	ldr	r3, [pc, #40]	; (80a1ae4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x80>)
 80a1aba:	681a      	ldr	r2, [r3, #0]
 80a1abc:	07d2      	lsls	r2, r2, #31
 80a1abe:	bf5c      	itt	pl
 80a1ac0:	2201      	movpl	r2, #1
 80a1ac2:	601a      	strpl	r2, [r3, #0]
 80a1ac4:	4770      	bx	lr
 80a1ac6:	bf00      	nop
 80a1ac8:	20000d00 	.word	0x20000d00
 80a1acc:	20000cfc 	.word	0x20000cfc
 80a1ad0:	20000cf8 	.word	0x20000cf8
 80a1ad4:	20000cf4 	.word	0x20000cf4
 80a1ad8:	20000cf0 	.word	0x20000cf0
 80a1adc:	20000cec 	.word	0x20000cec
 80a1ae0:	20000ce8 	.word	0x20000ce8
 80a1ae4:	20000ce4 	.word	0x20000ce4

080a1ae8 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj>:
 80a1ae8:	4b24      	ldr	r3, [pc, #144]	; (80a1b7c <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0x94>)
 80a1aea:	681a      	ldr	r2, [r3, #0]
 80a1aec:	07d0      	lsls	r0, r2, #31
 80a1aee:	bf5c      	itt	pl
 80a1af0:	2201      	movpl	r2, #1
 80a1af2:	601a      	strpl	r2, [r3, #0]
 80a1af4:	4b22      	ldr	r3, [pc, #136]	; (80a1b80 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0x98>)
 80a1af6:	681a      	ldr	r2, [r3, #0]
 80a1af8:	07d1      	lsls	r1, r2, #31
 80a1afa:	bf5c      	itt	pl
 80a1afc:	2201      	movpl	r2, #1
 80a1afe:	601a      	strpl	r2, [r3, #0]
 80a1b00:	4b20      	ldr	r3, [pc, #128]	; (80a1b84 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0x9c>)
 80a1b02:	681a      	ldr	r2, [r3, #0]
 80a1b04:	07d2      	lsls	r2, r2, #31
 80a1b06:	bf5c      	itt	pl
 80a1b08:	2201      	movpl	r2, #1
 80a1b0a:	601a      	strpl	r2, [r3, #0]
 80a1b0c:	4b1e      	ldr	r3, [pc, #120]	; (80a1b88 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xa0>)
 80a1b0e:	681a      	ldr	r2, [r3, #0]
 80a1b10:	07d0      	lsls	r0, r2, #31
 80a1b12:	bf5c      	itt	pl
 80a1b14:	2201      	movpl	r2, #1
 80a1b16:	601a      	strpl	r2, [r3, #0]
 80a1b18:	4b1c      	ldr	r3, [pc, #112]	; (80a1b8c <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xa4>)
 80a1b1a:	681a      	ldr	r2, [r3, #0]
 80a1b1c:	07d1      	lsls	r1, r2, #31
 80a1b1e:	bf5c      	itt	pl
 80a1b20:	2201      	movpl	r2, #1
 80a1b22:	601a      	strpl	r2, [r3, #0]
 80a1b24:	4b1a      	ldr	r3, [pc, #104]	; (80a1b90 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xa8>)
 80a1b26:	681a      	ldr	r2, [r3, #0]
 80a1b28:	07d2      	lsls	r2, r2, #31
 80a1b2a:	bf5c      	itt	pl
 80a1b2c:	2201      	movpl	r2, #1
 80a1b2e:	601a      	strpl	r2, [r3, #0]
 80a1b30:	4b18      	ldr	r3, [pc, #96]	; (80a1b94 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xac>)
 80a1b32:	681a      	ldr	r2, [r3, #0]
 80a1b34:	07d0      	lsls	r0, r2, #31
 80a1b36:	bf5c      	itt	pl
 80a1b38:	2201      	movpl	r2, #1
 80a1b3a:	601a      	strpl	r2, [r3, #0]
 80a1b3c:	4b16      	ldr	r3, [pc, #88]	; (80a1b98 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xb0>)
 80a1b3e:	681a      	ldr	r2, [r3, #0]
 80a1b40:	07d1      	lsls	r1, r2, #31
 80a1b42:	bf5c      	itt	pl
 80a1b44:	2201      	movpl	r2, #1
 80a1b46:	601a      	strpl	r2, [r3, #0]
 80a1b48:	4b14      	ldr	r3, [pc, #80]	; (80a1b9c <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xb4>)
 80a1b4a:	681a      	ldr	r2, [r3, #0]
 80a1b4c:	07d2      	lsls	r2, r2, #31
 80a1b4e:	bf5c      	itt	pl
 80a1b50:	2201      	movpl	r2, #1
 80a1b52:	601a      	strpl	r2, [r3, #0]
 80a1b54:	4b12      	ldr	r3, [pc, #72]	; (80a1ba0 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xb8>)
 80a1b56:	681a      	ldr	r2, [r3, #0]
 80a1b58:	07d0      	lsls	r0, r2, #31
 80a1b5a:	bf5c      	itt	pl
 80a1b5c:	2201      	movpl	r2, #1
 80a1b5e:	601a      	strpl	r2, [r3, #0]
 80a1b60:	4b10      	ldr	r3, [pc, #64]	; (80a1ba4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xbc>)
 80a1b62:	681a      	ldr	r2, [r3, #0]
 80a1b64:	07d1      	lsls	r1, r2, #31
 80a1b66:	bf5c      	itt	pl
 80a1b68:	2201      	movpl	r2, #1
 80a1b6a:	601a      	strpl	r2, [r3, #0]
 80a1b6c:	4b0e      	ldr	r3, [pc, #56]	; (80a1ba8 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xc0>)
 80a1b6e:	681a      	ldr	r2, [r3, #0]
 80a1b70:	07d2      	lsls	r2, r2, #31
 80a1b72:	bf5c      	itt	pl
 80a1b74:	2201      	movpl	r2, #1
 80a1b76:	601a      	strpl	r2, [r3, #0]
 80a1b78:	4770      	bx	lr
 80a1b7a:	bf00      	nop
 80a1b7c:	20000d30 	.word	0x20000d30
 80a1b80:	20000d2c 	.word	0x20000d2c
 80a1b84:	20000d28 	.word	0x20000d28
 80a1b88:	20000d24 	.word	0x20000d24
 80a1b8c:	20000d20 	.word	0x20000d20
 80a1b90:	20000d1c 	.word	0x20000d1c
 80a1b94:	20000d18 	.word	0x20000d18
 80a1b98:	20000d14 	.word	0x20000d14
 80a1b9c:	20000d10 	.word	0x20000d10
 80a1ba0:	20000d0c 	.word	0x20000d0c
 80a1ba4:	20000d08 	.word	0x20000d08
 80a1ba8:	20000d04 	.word	0x20000d04

080a1bac <__cxa_atexit>:
 80a1bac:	b510      	push	{r4, lr}
 80a1bae:	4c05      	ldr	r4, [pc, #20]	; (80a1bc4 <__cxa_atexit+0x18>)
 80a1bb0:	4613      	mov	r3, r2
 80a1bb2:	b12c      	cbz	r4, 80a1bc0 <__cxa_atexit+0x14>
 80a1bb4:	460a      	mov	r2, r1
 80a1bb6:	4601      	mov	r1, r0
 80a1bb8:	2002      	movs	r0, #2
 80a1bba:	f3af 8000 	nop.w
 80a1bbe:	bd10      	pop	{r4, pc}
 80a1bc0:	4620      	mov	r0, r4
 80a1bc2:	bd10      	pop	{r4, pc}
 80a1bc4:	00000000 	.word	0x00000000

080a1bc8 <memcpy>:
 80a1bc8:	b510      	push	{r4, lr}
 80a1bca:	1e43      	subs	r3, r0, #1
 80a1bcc:	440a      	add	r2, r1
 80a1bce:	4291      	cmp	r1, r2
 80a1bd0:	d004      	beq.n	80a1bdc <memcpy+0x14>
 80a1bd2:	f811 4b01 	ldrb.w	r4, [r1], #1
 80a1bd6:	f803 4f01 	strb.w	r4, [r3, #1]!
 80a1bda:	e7f8      	b.n	80a1bce <memcpy+0x6>
 80a1bdc:	bd10      	pop	{r4, pc}

080a1bde <memset>:
 80a1bde:	4603      	mov	r3, r0
 80a1be0:	4402      	add	r2, r0
 80a1be2:	4293      	cmp	r3, r2
 80a1be4:	d002      	beq.n	80a1bec <memset+0xe>
 80a1be6:	f803 1b01 	strb.w	r1, [r3], #1
 80a1bea:	e7fa      	b.n	80a1be2 <memset+0x4>
 80a1bec:	4770      	bx	lr
	...

080a1bf0 <srand>:
 80a1bf0:	b538      	push	{r3, r4, r5, lr}
 80a1bf2:	4b12      	ldr	r3, [pc, #72]	; (80a1c3c <srand+0x4c>)
 80a1bf4:	4605      	mov	r5, r0
 80a1bf6:	681c      	ldr	r4, [r3, #0]
 80a1bf8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80a1bfa:	b9d3      	cbnz	r3, 80a1c32 <srand+0x42>
 80a1bfc:	2018      	movs	r0, #24
 80a1bfe:	f7ff f9af 	bl	80a0f60 <malloc>
 80a1c02:	f243 330e 	movw	r3, #13070	; 0x330e
 80a1c06:	63a0      	str	r0, [r4, #56]	; 0x38
 80a1c08:	8003      	strh	r3, [r0, #0]
 80a1c0a:	f64a 33cd 	movw	r3, #43981	; 0xabcd
 80a1c0e:	8043      	strh	r3, [r0, #2]
 80a1c10:	f241 2334 	movw	r3, #4660	; 0x1234
 80a1c14:	8083      	strh	r3, [r0, #4]
 80a1c16:	f24e 636d 	movw	r3, #58989	; 0xe66d
 80a1c1a:	80c3      	strh	r3, [r0, #6]
 80a1c1c:	f64d 63ec 	movw	r3, #57068	; 0xdeec
 80a1c20:	8103      	strh	r3, [r0, #8]
 80a1c22:	2305      	movs	r3, #5
 80a1c24:	8143      	strh	r3, [r0, #10]
 80a1c26:	230b      	movs	r3, #11
 80a1c28:	8183      	strh	r3, [r0, #12]
 80a1c2a:	2201      	movs	r2, #1
 80a1c2c:	2300      	movs	r3, #0
 80a1c2e:	e9c0 2304 	strd	r2, r3, [r0, #16]
 80a1c32:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80a1c34:	2200      	movs	r2, #0
 80a1c36:	611d      	str	r5, [r3, #16]
 80a1c38:	615a      	str	r2, [r3, #20]
 80a1c3a:	bd38      	pop	{r3, r4, r5, pc}
 80a1c3c:	20000774 	.word	0x20000774

080a1c40 <strlen>:
 80a1c40:	4603      	mov	r3, r0
 80a1c42:	f813 2b01 	ldrb.w	r2, [r3], #1
 80a1c46:	2a00      	cmp	r2, #0
 80a1c48:	d1fb      	bne.n	80a1c42 <strlen+0x2>
 80a1c4a:	1a18      	subs	r0, r3, r0
 80a1c4c:	3801      	subs	r0, #1
 80a1c4e:	4770      	bx	lr

080a1c50 <dynalib_user>:
 80a1c50:	001d 080a 005d 080a 0089 080a 008d 080a     ....]...........
 80a1c60:	0000 0000 6548 6c6c 326f 6120 6167 6e69     ....Hello2 again
 80a1c70:	0000 0000                                   ....

080a1c74 <_ZTV12Adafruit_GFX>:
	...
 80a1c84:	04c9 080a 10d9 080a 00a1 080a 01c5 080a     ................
 80a1c94:	02e5 080a 0301 080a 0285 080a 031b 080a     ................
 80a1ca4:	0353 080a 036f 080a                         S...o...

080a1cac <_ZL4font>:
 80a1cac:	0000 0000 3e00 4f5b 3e5b 6b3e 6b4f 1c3e     .....>[O[>>kOk>.
 80a1cbc:	7c3e 1c3e 3c18 3c7e 1c18 7d57 1c57 5e1c     >|>..<~<..W}W..^
 80a1ccc:	5e7f 001c 3c18 0018 e7ff e7c3 00ff 2418     .^...<.........$
 80a1cdc:	0018 e7ff e7db 30ff 3a48 0e06 2926 2979     .......0H:..&)y)
 80a1cec:	4026 057f 0705 7f40 2505 5a3f e73c 5a3c     &@....@..%?Z<.<Z
 80a1cfc:	3e7f 1c1c 0808 1c1c 7f3e 2214 227f 5f14     .>......>.."."._
 80a1d0c:	005f 5f5f 0906 017f 007f 8966 6a95 6060     _.__......f..j``
 80a1d1c:	6060 9460 ffa2 94a2 0408 047e 1008 7e20     ```.......~... ~
 80a1d2c:	1020 0808 1c2a 0808 2a1c 0808 101e 1010      ...*....*......
 80a1d3c:	0c10 0c1e 0c1e 3830 383e 0630 3e0e 060e     ......08>80..>..
 80a1d4c:	0000 0000 0000 5f00 0000 0700 0700 1400     ......._........
 80a1d5c:	147f 147f 2a24 2a7f 2312 0813 6264 4936     ....$*.*.#..db6I
 80a1d6c:	2056 0050 0708 0003 1c00 4122 0000 2241     V P......."A..A"
 80a1d7c:	001c 1c2a 1c7f 082a 3e08 0808 8000 3070     ..*...*..>....p0
 80a1d8c:	0800 0808 0808 0000 6060 2000 0810 0204     ........``. ....
 80a1d9c:	513e 4549 003e 7f42 0040 4972 4949 2146     >QIE>.B.@.rIIIF!
 80a1dac:	4941 334d 1418 7f12 2710 4545 3945 4a3c     AIM3.....'EEE9<J
 80a1dbc:	4949 4131 1121 0709 4936 4949 4636 4949     II1A!...6III6FII
 80a1dcc:	1e29 0000 0014 0000 3440 0000 0800 2214     ).......@4....."
 80a1ddc:	1441 1414 1414 4100 1422 0208 5901 0609     A......A"....Y..
 80a1dec:	413e 595d 7c4e 1112 7c12 497f 4949 3e36     >A]YN|...|.III6>
 80a1dfc:	4141 2241 417f 4141 7f3e 4949 4149 097f     AAA".AAA>.IIIA..
 80a1e0c:	0909 3e01 4141 7351 087f 0808 007f 7f41     ...>AAQs......A.
 80a1e1c:	0041 4020 3f41 7f01 1408 4122 407f 4040     A. @A?...."A.@@@
 80a1e2c:	7f40 1c02 7f02 047f 1008 3e7f 4141 3e41     @..........>AAA>
 80a1e3c:	097f 0909 3e06 5141 5e21 097f 2919 2646     .....>AQ!^...)F&
 80a1e4c:	4949 3249 0103 017f 3f03 4040 3f40 201f     III2.....?@@@?. 
 80a1e5c:	2040 3f1f 3840 3f40 1463 1408 0363 7804     @ .?@8@?c...c..x
 80a1e6c:	0304 5961 4d49 0043 417f 4141 0402 1008     ..aYIMC..AAA....
 80a1e7c:	0020 4141 7f41 0204 0201 4004 4040 4040      .AAA......@@@@@
 80a1e8c:	0300 0807 2000 5454 4078 287f 4444 3838     ..... TTx@.(DD88
 80a1e9c:	4444 2844 4438 2844 387f 5454 1854 0800     DDD(8DD(.8TTT...
 80a1eac:	097e 1802 a4a4 789c 087f 0404 0078 7d44     ~......x....x.D}
 80a1ebc:	0040 4020 3d40 7f00 2810 0044 4100 407f     @. @@=...(D..A.@
 80a1ecc:	7c00 7804 7804 087c 0404 3878 4444 3844     .|.x.x|...x8DDD8
 80a1edc:	18fc 2424 1818 2424 fc18 087c 0404 4808     ..$$..$$..|....H
 80a1eec:	5454 2454 0404 443f 3c24 4040 7c20 201c     TTT$..?D$<@@ |. 
 80a1efc:	2040 3c1c 3040 3c40 2844 2810 4c44 9090     @ .<@0@<D(.(DL..
 80a1f0c:	7c90 6444 4c54 0044 3608 0041 0000 0077     .|DdTLD..6A...w.
 80a1f1c:	0000 3641 0008 0102 0402 3c02 2326 3c26     ..A6.......<&#&<
 80a1f2c:	a11e 61a1 3a12 4040 7a20 5438 5554 2159     ...a.:@@ z8TTUY!
 80a1f3c:	5555 4179 5421 7854 2141 5455 4078 5420     UUyA!TTxA!UTx@ T
 80a1f4c:	7955 0c40 521e 1272 5539 5555 3959 5454     Uy@..Rr.9UUUY9TT
 80a1f5c:	5954 5539 5454 0058 4500 417c 0200 7d45     TY9UTTX..E|A..E}
 80a1f6c:	0042 4501 407c 29f0 2924 f0f0 2528 f028     B..E|@.)$)..(%(.
 80a1f7c:	547c 4555 2000 5454 547c 0a7c 7f09 3249     |TUE. TT|T|...I2
 80a1f8c:	4949 3249 4832 4848 3232 484a 3048 413a     III22HHH22JHH0:A
 80a1f9c:	2141 3a7a 4042 7820 9d00 a0a0 397d 4444     A!z:B@ x....}9DD
 80a1fac:	3944 403d 4040 3c3d ff24 2424 7e48 4349     D9=@@@=<$.$$H~IC
 80a1fbc:	2b66 fc2f 2b2f 09ff f629 c020 7e88 0309     f+/./+..). ..~..
 80a1fcc:	5420 7954 0041 4400 417d 4830 4a48 3832      TTyA..D}A0HHJ28
 80a1fdc:	4040 7a22 7a00 0a0a 7d72 190d 7d31 2926     @@"z.z..r}..1}&)
 80a1fec:	2f29 2628 2929 2629 4830 404d 3820 0808     )/(&)))&0HM@ 8..
 80a1ffc:	0808 0808 0808 2f38 c810 baac 102f 3428     ......8/..../.(4
 80a200c:	00fa 7b00 0000 1408 142a 2222 2a14 0814     ...{....*."".*..
 80a201c:	00aa 0055 aaaa aa55 aa55 0000 ff00 1000     ..U...U.U.......
 80a202c:	1010 00ff 1414 ff14 1000 ff10 ff00 1010     ................
 80a203c:	10f0 14f0 1414 00fc 1414 00f7 00ff ff00     ................
 80a204c:	ff00 1414 04f4 14fc 1714 1f10 1010 101f     ................
 80a205c:	141f 1414 001f 1010 f010 0000 0000 101f     ................
 80a206c:	1010 1f10 1010 1010 10f0 0000 ff00 1010     ................
 80a207c:	1010 1010 1010 ff10 0010 0000 14ff 0000     ................
 80a208c:	00ff 00ff 1f00 1710 0000 04fc 14f4 1714     ................
 80a209c:	1710 1414 04f4 00f4 ff00 f700 1414 1414     ................
 80a20ac:	1414 f714 f700 1414 1714 1014 1f10 1f10     ................
 80a20bc:	1414 f414 1014 f010 f010 0000 101f 001f     ................
 80a20cc:	0000 141f 0000 fc00 0014 f000 f010 1010     ................
 80a20dc:	10ff 14ff 1414 14ff 1010 1f10 0000 0000     ................
 80a20ec:	10f0 ffff ffff f0ff f0f0 f0f0 ffff 00ff     ................
 80a20fc:	0000 0000 ffff 0f0f 0f0f 380f 4444 4438     ...........8DD8D
 80a210c:	2a7c 3e2a 7e14 0202 0606 7e02 7e02 6302     |**>.~.....~.~.c
 80a211c:	4955 6341 4438 3c44 4004 207e 201e 0206     UIAc8DD<.@~ . ..
 80a212c:	027e 9902 e7a5 99a5 2a1c 2a49 4c1c 0172     ~........*I*.Lr.
 80a213c:	4c72 4a30 4d4d 3030 7848 3048 62bc 465a     rL0JMM00HxH0.bZF
 80a214c:	3e3d 4949 0049 017e 0101 2a7e 2a2a 2a2a     =>III.~...~*****
 80a215c:	4444 445f 4044 4a51 4044 4440 514a 0040     DD_DD@QJD@@DJQ@.
 80a216c:	ff00 0301 80e0 00ff 0800 6b08 086b 1236     ...........kk.6.
 80a217c:	2436 0636 090f 060f 0000 1818 0000 1000     6$6.............
 80a218c:	0010 4030 01ff 0001 011f 1e01 1900 171d     ..0@............
 80a219c:	0012 3c3c 3c3c 0000 0000 0000               ..<<<<......

080a21a8 <_ZTV16Adafruit_SSD1306>:
	...
 80a21b0:	00c5 080a 0169 080a 04c9 080a 10d9 080a     ....i...........
 80a21c0:	086d 080a 01c5 080a 06d5 080a 0561 080a     m...........a...
 80a21d0:	0285 080a 031b 080a 0353 080a 036f 080a     ........S...o...

080a21e0 <_ZTV7TwoWire>:
	...
 80a21e8:	0fa9 080a 0ff3 080a 0fcb 080a 0fab 080a     ................
 80a21f8:	0fd3 080a 0fdb 080a 0fe3 080a 0feb 080a     ................

080a2208 <_ZTV9IPAddress>:
	...
 80a2210:	1063 080a 1055 080a 1057 080a 0066 6e6c     c...U...W...f.ln
 80a2220:	6600 006e 6f63 6564 6400 7465 6961 006c     .fn.code.detail.
 80a2230:	0a0d 2500 3130 7530 0020 205d 2500 0064     ...%010u .] .%d.
 80a2240:	202c 2800 3a29 0020 5b20 6300 646f 2065     , .(): . [.code 
 80a2250:	203d 2500 0069 6564 6174 6c69 2073 203d     = .%i.details = 
 80a2260:	6200 7561 0064 6553 6972 6c61 5500 4253     .baud.Serial.USB
 80a2270:	6553 6972 6c61 0031 7974 6570 7000 7261     Serial1.type.par
 80a2280:	6d61 6300 646d 6900 0064 6e68 0064 7473     am.cmd.id.hnd.st
 80a2290:	6d72 6600 6c69 0074 766c 006c 6461 4864     rm.filt.lvl.addH
 80a22a0:	6e61 6c64 7265 7200 6d65 766f 4865 6e61     andler.removeHan
 80a22b0:	6c64 7265 6500 756e 486d 6e61 6c64 7265     dler.enumHandler
 80a22c0:	0073 534a 4e4f 7453 6572 6d61 6f4c 4867     s.JSONStreamLogH
 80a22d0:	6e61 6c64 7265 6100 7070 6e00 6e6f 0065     andler.app.none.
 80a22e0:	7274 6361 0065 6e69 6f66 7700 7261 006e     trace.info.warn.
 80a22f0:	7265 6f72 0072 6170 696e 0063 6c61 006c     error.panic.all.

080a2300 <_ZTV8SPIClass>:
	...
 80a2308:	11b5 080a 11b7 080a                         ........

080a2310 <_ZL14clock_divisors>:
 80a2310:	0800 1810 2820 3830 005a 2b25 3330 3a64     .... (08Z.%+03d:
 80a2320:	3025 7532 2500 2d59 6d25 252d 5464 4825     %02u.%Y-%m-%dT%H
 80a2330:	253a 3a4d 5325 7a25 6100 6373 6974 656d     :%M:%S%z.asctime
 80a2340:	0000 0000                                   ....

080a2344 <_ZTV11USARTSerial>:
	...
 80a234c:	13d5 080a 13f9 080a 1405 080a 10d9 080a     ................
 80a235c:	13e1 080a 13ed 080a 13e7 080a 13f3 080a     ................
 80a236c:	13d7 080a 13db 080a                         ........

080a2374 <_ZTV9USBSerial>:
	...
 80a237c:	14ad 080a 14f1 080a 14cb 080a 10d9 080a     ................
 80a238c:	14c5 080a 14af 080a 14b7 080a 14eb 080a     ................
 80a239c:	14bf 080a 14a9 080a                         ........

080a23a4 <_ZTVN5spark9WiFiClassE>:
	...
 80a23ac:	1617 080a                                   ....

080a23b0 <__sf_fake_stdin>:
	...

080a23d0 <__sf_fake_stdout>:
	...

080a23f0 <__sf_fake_stderr>:
	...
 80a2410:	0043                                        C.

080a2412 <link_const_variable_data_end>:
	...

080a2414 <link_constructors_location>:
 80a2414:	080a0175 	.word	0x080a0175
 80a2418:	080a055d 	.word	0x080a055d
 80a241c:	080a0c51 	.word	0x080a0c51
 80a2420:	080a10c9 	.word	0x080a10c9
 80a2424:	080a1199 	.word	0x080a1199
 80a2428:	080a1381 	.word	0x080a1381
 80a242c:	080a13c1 	.word	0x080a13c1
 80a2430:	080a1621 	.word	0x080a1621
 80a2434:	080a189d 	.word	0x080a189d
 80a2438:	080a18cd 	.word	0x080a18cd
 80a243c:	080a191d 	.word	0x080a191d
 80a2440:	080a19e1 	.word	0x080a19e1
 80a2444:	080a1a65 	.word	0x080a1a65
 80a2448:	080a1ae9 	.word	0x080a1ae9

080a244c <link_constructors_end>:
 80a244c:	00000000 	.word	0x00000000
